<!DOCTYPE html>
<html lang="en">
	<head>
	<script type="text/javascript">
		if (window.location.protocol == "https:") {
			var restOfUrl = window.location.href.substr(6);
			window.location = "http:" + restOfUrl;
		}
	</script>		
		<title>FTD Blueprint Bulk Modification Tool</title>
		<meta charset="utf-8">
		
	<link rel='shortcut icon' href='ico/favicon.ico' type='image/x-icon'/ >
	<link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.css">
	<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/css/theme.blue.min.css">
<style>


hr{
	width:90%;
}

.subtext{
margin:4px;
}

.hidden{
	display:none;
}
.ui-header {
background: #D0D0FF !important;
}

.ui-collapsible-content {
	margin-left:4px !important;
	margin-right:4px !important;
    padding: 0px;
}

.ui-collapsible-heading{
	margin-left:4px;
	margin-right:4px;
}
.ui-listview{
	margin: 0px !important;
}

.tablesorter-blue{
	margin:0 0;
	text-align: center;
}
#disqus_thread{
	margin: 0 0;
	padding: 0.8em;
}
#container{
	background-color:#8CCFFF;
}

.bigbox{
	width:22px;
	height:22px;
	vertical-align:middle; 
}

.checkbox{
	margin: 0px;
	font-weight:bold !important;
	padding-top:12px;
	padding-left:8px;
	align:right;
	vertical-align:middle; 
	display:inline;
}

.ui-slider-track.ui-mini {
	margin-left:58px;
}

.box{
	
    border: 2px solid black;

}


tbody tr:nth-child(even) td:nth-child(odd){background: #E0E0F0}
tbody tr:nth-child(odd) td:nth-child(even){background: #FFFFFF}
tbody tr:nth-child(even) td:nth-child(even){background: #F0F0FF}
tbody tr:nth-child(odd) td:nth-child(odd){background: #F0F0F0}


</style>
	<script src="js/links.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.js"></script>
	<script src="http://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/js/jquery.tablesorter.min.js"></script>
	
	<script src="http://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.2/jszip.min.js"></script>		
	<script src="js/itemtable.js"></script>	
<script>


var QuatTable = {0:"0,0,0,1",1:"0,0.707106781186547,0,0.707106781186547",2:"0,1,0,0",3:"0,0.707106781186547,0,-0.707106781186547",4:"0.707106781186547,0,0,0.707106781186547",5:"0.5,0.5,-0.5,0.5",6:"0,-0.707106781186547,0.707106781186547,0",7:"-0.5,0.5,-0.5,-0.5",8:"0,-0.707106781186547,-0.707106781186547,0",9:"0.5,0.5,0.5,-0.5",10:"-0.707106781186547,0,0,0.707106781186547",11:"-0.5,0.5,0.5,0.5",12:"0,0,-1,0",13:"-0.707106781186547,0,-0.707106781186547,0",14:"1,0,0,0",15:"0.707106781186547,0,-0.707106781186547,0",16:"0,0,-0.707106781186547,0.707106781186547",17:"0.707106781186547,0.707106781186547,0,0",18:"0,0,0.707106781186547,0.707106781186547",19:"-0.707106781186547,0.707106781186547,0,0",20:"0.5,0.5,0.5,0.5",21:"0.5,-0.5,-0.5,0.5",22:"-0.5,0.5,-0.5,0.5",23:"-0.5,-0.5,0.5,0.5",}
var RotTable = {"0,0,0,1":0,"0,1,0,1":1,"0,1,0,0":2,"0,1,0,-1":3,"1,0,0,1":4,"1,1,-1,1":5,"0,1,-1,0":6,"1,-1,1,1":7,"0,1,1,0":8,"1,1,1,-1":9,"1,0,0,-1":10,"1,-1,-1,-1":11,"0,0,1,0":12,"1,0,1,0":13,"1,0,0,0":14,"1,0,-1,0":15,"0,0,1,-1":16,"1,1,0,0":17,"0,0,1,1":18,"1,-1,0,0":19,"1,1,1,1":20,"1,-1,-1,1":21,"1,-1,1,-1":22,"1,1,-1,-1":23}

var BeamAxisRot = [1,8,0];
var BeamAxisPriority = [3,2,1];

var runningCount=0;
var runningTimeOut=1200;

var currentBlueprints;
var currentFilenames;
var fileIndex = 0;








$(document).ready(function(){

	
	
	$( ".lb" ).click(function() {
	  $($(this).attr("btarget")).click();
	  
  
	});
	

	
	$(function() {
  // simple reflow widget (table with 1 header row)
  
  $("#table1").tablesorter({
    theme: 'blue',
    widgets: ['reflow'],
    widgetOptions : {
      // class name added to make it responsive (class name within media query)
      reflow_className    : 'ui-table-reflow',
      // header attribute containing modified header name
      reflow_headerAttrib : 'data-name',
      // data attribute added to each tbody cell
      // it contains the header cell text, visible upon reflow
      reflow_dataAttrib   : 'data-title',
	 

	  
	  
    },	
	selectorHeaders: "thead th"
  });
  
});


});


//rotation*vector*rotation_conjugate
//inverse x and inverse w to flip along yz plane



//pos as [x,y,z] quat as[x,y,z,w]
// transforms co-ordinate pos by the quaternion quat
function posTransform(pos,quat){
	var p = [pos[0],pos[1],pos[2],0];
	var transpos = quatmul(quat,quatmul(p,quatconj(quat)));
	return [Math.round(transpos[0]),Math.round(transpos[1]),Math.round(transpos[2])]
}

function posTransformNR(pos,quat){
	var p = [pos[0],pos[1],pos[2],0];
	var transpos = quatmul(quat,quatmul(p,quatconj(quat)));
	return [(transpos[0]),(transpos[1]),(transpos[2])]
}

//combining 2 quat transforms e.g. q1 then q2 = applying q2*q1 or quatmul(q2,q1);


function atos(a){
	var s="";
	if(a){
		s=""+a[0];
	}
	for (var i=1;i<a.length;i++){
		s=s + "," + a[i];
	}
	return s;
}

function stoa(s){
	var temp=s.split(",");
	return [parseFloat(temp[0]),parseFloat(temp[1]),parseFloat(temp[2]),parseFloat(temp[3])];
}

function stoa3(s){
	var temp=s.split(",");
	return [parseFloat(temp[0]),parseFloat(temp[1]),parseFloat(temp[2])];
}


function stoar(s){
	var temp=s.split(",");
	return [Math.round(parseFloat(temp[0])),Math.round(parseFloat(temp[1])),Math.round(parseFloat(temp[2]))];
}

function getQuat(rotation){
	return JSON.parse("[" + QuatTable[rotation] + "]");
}

function getRot(quat){
	var quatstr=atos(getquatformatted(quat));
	return RotTable[quatstr];
}

//quat as array
function getquatformatted(quat){
	var q=[quat[0],quat[1],quat[2],quat[3]];
	var r = Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]);
	q[0]=Math.round(q[0]*r);
	q[1]=Math.round(q[1]*r);
	q[2]=Math.round(q[2]*r);
	q[3]=Math.round(q[3]*r);
	for(var i=0;i<4;i++){
		if(q[i]>0){
			break;
		}else if(q[i]<0){
			q=quatneg(q);
			break;
		}
	}
	return q;
}

//quat as array
function getquatnormalized(quat){
	var q=[quat[0],quat[1],quat[2],quat[3]];
	var r = Math.sqrt(Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]));
	q[0]=q[0]/r;
	q[1]=q[1]/r;
	q[2]=q[2]/r;
	q[3]=q[3]/r;
	return q;
}

//quat in x, y, z, w
function quatneg(q){
 return[-q[0],-q[1],-q[2],-q[3]];
}
//quat in x, y, z, w
function quatconj(q){
 return[-q[0],-q[1],-q[2],q[3]];
}

//quat in x, y, z, w
function quatmul(q,r){
 return [q[3] * r[0] + q[0] * r[3] + q[1] * r[2] - q[2] * r[1],
     q[3] * r[1] - q[0] * r[2] + q[1] * r[3] + q[2] * r[0],
     q[3] * r[2] + q[0] * r[1] - q[1] * r[0] + q[2] * r[3],
     q[3] * r[3] - q[0] * r[0] - q[1] * r[1] - q[2] * r[2]];
}

function loadLinks(){
	$('#linklist').empty();
	for(var i=0;i<LinkList.length;i++){
		$('#linklist').append(LinkList[i]);
	}
	
}

function loadError(message){
	if(message){
		alert(message);
	}else{
		alert("failure");
	}	
}

function openFile() {

	var selectedFiles = document.getElementById('blueprintfile').files;
	var outputstring = "";
	currentBlueprints=[];
	currentFilenames=[];
	fileIndex = 0;
	runningCount = selectedFiles.length;
	runningTimeOut = 1200;
	$("#table1 tbody").empty();  
	for(var fi=0;fi<selectedFiles.length;fi++){
		var selectedFile=selectedFiles[fi];
		outputstring +=  "<tr><td>" + selectedFile.name  + "</td></tr>";
		if (selectedFile){
			var reader = new FileReader();
			reader.fileName = selectedFile.name;
			reader.onload = function(evt) {
									
				if(evt){
					currentBlueprints[fileIndex]=JSON.parse(evt.target.result);
					currentFilenames[fileIndex]=this.fileName;
					fileIndex++;
				}
				runningCount -=1;
			}
			reader.readAsText(selectedFile);
		}
				
		//console.log(selectedFile.name + " : " + selectedFile.size);
				
	}
	
	function waitRunning() {
		
		if((runningCount>0)&&(runningTimeOut>0)) {
			console.log("wait");
			runningTimeOut-=1;
			setTimeout(waitRunning, 100);
			return;
		}else{
			console.log("done");
			if(runningCount>runningTimeOut){
				console.log("Time Out during processing.");
			}
			if(fileIndex>0){
			
				$("#table1 tbody").append(outputstring); 

				$("#table1").trigger("update");
				$("#blueprintpanel").collapsible("expand");

				
				$(".dl").prop('disabled',false);
				$(".dl").parent().removeClass('ui-state-disabled');				
			}
			
			
		}
	}
	waitRunning();
		
	
	return true;

}


//returns different block ID if blocks needs to be converted



function downloadBlueprint(){
 

  var zipfile = new JSZip();

 for(var fi=0;fi<currentBlueprints.length;fi++){
	var CurrentBlueprint=currentBlueprints[fi];
	var CurrentFilename=currentFilenames[fi];

					
			try{    										
					

					var GuidToID= {}
					var localShapedBlocks

					//maps block ID of block to beam
					var blockToBeam = {}
					var blockToBeam2m = {}
					var blockToBeam3m = {}

					//maps block ID of beam to block
					var beamToBlock = {}
					var beamToBlock2m = {}
					var beamToBlock3m = {}


					var slopeBlockToBeam = {}
					var slopeBeamToBlock = {}
					var slopeBeamToBlockM = {}

					//maintains a list of blockID:newBlockID to facilitate switching blocks via convertblocks() function
					var conversionIndex = {}

					//maintains a list of blockID to keep via clearhull() function
					var keepIndex = {}

					//maintains a list of blockID to determine color changes via colorblocks() function
					var blockColorIndex = {}
					var replaceOldIndex = {}

					//blockID:blockname
					var nameID = {}





					var ItemDic

					var selectedcolor

					var allowedcolor = -1;

					

						function getBlock(bid){
							var tempBlock=ItemTable[ItemDic[bid]];
							tempBlock.blockId=GuidToID[ItemDic[bid]];
							return tempBlock;
						}
						

						//convert blocks between materials. also changes shield color.
						function convertblocks(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  convertblocks(SClist[scID]);
						 }
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
							if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
							  blocklist[blockIndex] = getconverted(blocklist[blockIndex]);
							  if(document.getElementById("shieldcolor").checked){
							   if (nameID[blocklist[blockIndex]]=="Shield Color Changer"){
								blocks.BP1[blockIndex] = "" + document.getElementById("shieldr").value + "," +  document.getElementById("shieldg").value + "," + document.getElementById("shieldb").value + "," + document.getElementById("shielda").value;
							   }
							  }
							}
						 }
						 cleanBlueprint(blocks);
						}


						function mirrorVehicle(blocks){
							var SClist=blocks.SCs;
							blocks.designChanged = true;
							for(var scID = 0; scID < SClist.length; scID++){
								var curSC=SClist[scID];
								curSC.LocalPosition=flipX(curSC.LocalPosition);
								curSC.LocalRotation=quatMirror(curSC.LocalRotation);
								mirrorVehicle(curSC);
							}
							var blocklist=blocks.BlockIds;
							var positionList=blocks.BLP;
							var rotationList = blocks.BLR;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

								blocklist[blockIndex]=mirrordata.blockID;
								positionList[blockIndex]=mirrordata.position;
								rotationList[blockIndex]=mirrordata.rotation;
							}
						}

						function rotateBlueprint(blocks,dir){
							var SClist=blocks.SCs;
							blocks.designChanged = true;
							for(var scID = 0; scID < SClist.length; scID++){
								var curSC=SClist[scID];
								curSC.LocalPosition=positionRotate(curSC.LocalPosition,dir);
								curSC.LocalRotation=quatRotate(curSC.LocalRotation,dir);  
							}
							var blocklist=blocks.BlockIds;
							var positionList=blocks.BLP;
							var rotationList = blocks.BLR;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								positionList[blockIndex]=positionRotate(positionList[blockIndex],dir);
								rotationList[blockIndex]=blockRotate(rotationList[blockIndex],dir);
							}
						}

						//builds index of file to keep via the clearhull() function
						function buildkeepIndex(){
						 keepIndex = {};
						 for(var mat in shapedBlocks){
							for (var key in shapedBlocks[mat].blockGuid){
								keepIndex[GuidToID[key]] = true;
							}
							/*
						  var blockcount =  shapedBlocks[mat].blockGuid.length;
						  for(var i=0;i<blockcount;i++){
						   keepIndex[GuidToID[shapedBlocks[mat].blockGuid[i]]] = true;
						  }
						  */
						 }
						}

						//delete everything except structural blocks on the main vehicle
						function clearhull(blocks){
						 blocks.SCs = [];
						 blocks.BlockStringData = [];
						 blocks.BlockStringDataIds = [];
						 blocks.BEI = [];
						 var blocklist=blocks.BlockIds;
						 var blrlist=blocks.BLR;
						 var blplist=blocks.BLP;
						 var bp1list=blocks.BP1;
						 var bp2list=blocks.BP2;
						 var bcilist=blocks.BCI; 
						 var blocknew=[];
						 var blrnew=[];
						 var blpnew=[];
						 var bp1new=[];
						 var bp2new=[];
						 var bcinew=[];
						 var currentIndex = 0;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  if(keepIndex[blocklist[blockIndex]]){
						   blocknew[currentIndex]=blocklist[blockIndex];
						   blrnew[currentIndex]=blrlist[blockIndex];
						   blpnew[currentIndex]=blplist[blockIndex];
						   bp1new[currentIndex]=bp1list[blockIndex];
						   bp2new[currentIndex]=bp2list[blockIndex];   
						   bcinew[currentIndex]=bcilist[blockIndex];   
						   currentIndex +=1;
						  }
						 } 
						 blocks.BlockIds=blocknew;
						 blocks.BLR=blrnew;
						 blocks.BLP=blpnew;
						 blocks.BP1=bp1new;
						 blocks.BP2=bp2new;
						 blocks.BCI=bcinew;
						}

						//randomly color blocks
						function randomcolorblocks(blocks){
						 var SClist=blocks.SCs;
						 //blocks.designChanged = true;
						 if(blocks.COL){
						   for(var i=0;i<28;i++){
							var colorseed = Math.floor((Math.random() * 15));
							var othercolor = 0.0;
							if (Math.random()<0.5){
							 othercolor = 1.0;
							}
							if (colorseed>8){
							 blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + Math.random()  +",0.99";
							}
							else if (colorseed>6){
							 blocks.COL[i]= "" +othercolor + "," + Math.random()  + "," + Math.random()  +",0.99";
							}
							else if (colorseed>4){
							 blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + Math.random()  +",0.99";
							}
							else if (colorseed>2){
							 blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + othercolor  +",0.99";
							}
							else if (colorseed>1){
							 blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + othercolor  +",0.99";
							}   
							else if (colorseed>0){
							 blocks.COL[i]= "" + othercolor + "," + Math.random()  + "," + othercolor  +",0.99";
							}else{
							 blocks.COL[i]= "" + othercolor + "," + othercolor  + "," + Math.random()  +",0.99";
							}
							
						   } 
						 }
						 for(var scID = 0; scID < SClist.length; scID++){

						   randomcolorblocks(SClist[scID]);
						  
						 }
						 var colorlist=blocks.BCI;
						 for(var blockIndex = 0; blockIndex < colorlist.length; blockIndex++){
						   colorlist[blockIndex] = Math.floor((Math.random() * 28));
						 }
						}

						//paint blocks
						function colorblocks(blocks){
						 var SClist=blocks.SCs;
						 //blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  if(!(SClist[scID].COL)){
						   colorblocks(SClist[scID]);
						  }
						 }
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
							if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
							  var newcolor = getNewColor(blocklist[blockIndex]);
							  if (newcolor==32){
								colorlist[blockIndex] = 1+Math.floor((Math.random() * 4));
							  }else if (newcolor==33){
								colorlist[blockIndex] = 28+Math.floor((Math.random() * 4));
							  }else if (newcolor>=0){
							   colorlist[blockIndex] = newcolor;
							  }
							}
						 }
						}

						//turns beam into blocks
						function debeamifyblocks(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  debeamifyblocks(SClist[scID]);
						 } 
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 var positionList=blocks.BLP;
						 var rotationList = blocks.BLR; 
						 newBlockIndex=blocklist.length;
						 blockcount=blocklist.length;
						 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
						  var currentBlock = blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&beamToBlock[currentBlock]){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;
							var targetBlock =beamToBlock[currentBlock];
							var directionArray = getDirectionArray(rotationList[blockIndex]);
							if(directionArray){
							 
							 blocklist[blockIndex]=targetBlock;
							 for(var i=1;i<4;i++){
							  blocklist[newBlockIndex]=targetBlock;
							  rotationList[newBlockIndex]=0;
							  colorlist[newBlockIndex]=colorlist[blockIndex];
							  blocks.BP1[newBlockIndex]="0,0,0,0";
							  blocks.BP2[newBlockIndex]="0,0,0,0";
							  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
							  newBlockIndex+=1;
							 }
							}
						  }else if(ItemDic[currentBlock]&&beamToBlock3m[currentBlock]){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;
							var targetBlock =beamToBlock3m[currentBlock];
							var directionArray = getDirectionArray(rotationList[blockIndex]);
							if(directionArray){
							 
							 blocklist[blockIndex]=targetBlock;
							 for(var i=1;i<3;i++){
							  blocklist[newBlockIndex]=targetBlock;
							  rotationList[newBlockIndex]=0;
							  colorlist[newBlockIndex]=colorlist[blockIndex];
							  blocks.BP1[newBlockIndex]="0,0,0,0";
							  blocks.BP2[newBlockIndex]="0,0,0,0";
							  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
							  newBlockIndex+=1;
							 }
							}
						  }else if(ItemDic[currentBlock]&&beamToBlock2m[currentBlock]){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;
							var targetBlock =beamToBlock2m[currentBlock];
							var directionArray = getDirectionArray(rotationList[blockIndex]);
							if(directionArray){
							 
							 blocklist[blockIndex]=targetBlock;
							 for(var i=1;i<2;i++){
							  blocklist[newBlockIndex]=targetBlock;
							  rotationList[newBlockIndex]=0;
							  colorlist[newBlockIndex]=colorlist[blockIndex];
							  blocks.BP1[newBlockIndex]="0,0,0,0";
							  blocks.BP2[newBlockIndex]="0,0,0,0";
							  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
							  newBlockIndex+=1;
							 }
							}
						  }
						 }
						}


						function debeamifyslopeblocks(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  debeamifyslopeblocks(SClist[scID]);
						 }
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 var positionList=blocks.BLP;
						 var rotationList = blocks.BLR; 
						 newBlockIndex=blocklist.length;
						 blockcount=blocklist.length;
						 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
						  var currentBlock = blocklist[blockIndex];
						  var currentRotation = rotationList[blockIndex];
						  if(ItemDic[currentBlock]&&(slopeBeamToBlock[currentBlock]||slopeBeamToBlockM[currentBlock])){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;
							var targetBlock = 0;
							var targetRotation = 0;
							if(slopeBeamToBlock[currentBlock]){
							 targetBlock = slopeBeamToBlock[currentBlock];
							 targetRotation = slopeBeamToBlockOrientation(currentRotation,false);
							}else if (slopeBeamToBlockM[currentBlock]){
							 targetBlock = slopeBeamToBlockM[currentBlock];
							 targetRotation = slopeBeamToBlockOrientation(currentRotation,true);
							}

							var directionArray = getDirectionArray(rotationList[blockIndex]);
							if(directionArray){
							 
							 blocklist[blockIndex]=targetBlock;
							 rotationList[blockIndex]=targetRotation;
							 for(var i=1;i<4;i++){
							  blocklist[newBlockIndex]=targetBlock;
							  rotationList[newBlockIndex]=targetRotation;
							  colorlist[newBlockIndex]=colorlist[blockIndex];
							  blocks.BP1[newBlockIndex]="0,0,0,0";
							  blocks.BP2[newBlockIndex]="0,0,0,0";
							  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
							  newBlockIndex+=1;
							 }
							}

						  }
						 }
						 
						}


						//get array of to represent block rotation
						function getDirectionArray(rotation){
						 if(rotation==0||rotation==16||rotation==12||rotation==18){
						  return [0,0,1];
						 }else if(rotation==2||rotation==17||rotation==14||rotation==19){
						  return [0,0,-1];
						 }else if(rotation==8||rotation==9||rotation==10||rotation==11){
						  return [0,1,0];
						 }else if(rotation==4||rotation==5||rotation==6||rotation==7){
						  return [0,-1,0];
						 }else if(rotation==1||rotation==20||rotation==13||rotation==22){
						  return [1,0,0];
						 }else if(rotation==3||rotation==21||rotation==15||rotation==23){
						  return [-1,0,0];
						 }else{
						  return false;
						 }
						}


						function beamifyaxisSloped(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
						 var tempBlockIndex = blockIndex;
						 var currentBlock = blocklist[tempBlockIndex];
						 if(ItemDic[currentBlock]){
						  if(slopeBlockToBeam[currentBlock]){
						   
						   var currentColor = colorlist[tempBlockIndex];
						   var currentPosition = positionList[tempBlockIndex];
						   var currentRotation = rotationList[tempBlockIndex];
						   
						   var posArray = JSON.parse("["+currentPosition+"]");
						   posArray[0] = Math.round(posArray[0]);
						   posArray[1] = Math.round(posArray[1]);
						   posArray[2] = Math.round(posArray[2]);
						   var result = true;
						   
						   
						   result = true;
						   for(i=1;i<4;i++){
							var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
							 
							}else{
							 result = false;
							}
						   }
						   if(result){
							for(i=1;i<4;i++){
							 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							 blocklist[blockPositionData[tempPosition]]=-1;
							}
							blocklist[tempBlockIndex]=slopeBlockToBeam[currentBlock];
							rotationList[tempBlockIndex]=rotation;     
						   }
						   
						   
						  }
						 }

						}
						//turn this blocks and adjacent 3 1x1x1 blocks in a particular direction into 1x1x4 beams
						function beamifyaxis(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
						 var tempBlockIndex = blockIndex;
						 var currentBlock = blocklist[tempBlockIndex];
						 if(ItemDic[currentBlock]){
						  if(blockToBeam[currentBlock]){
						 
						   var currentColor = colorlist[tempBlockIndex];
						   var currentPosition = positionList[tempBlockIndex];
						   
						   var posArray = JSON.parse("["+currentPosition+"]");
						   posArray[0] = Math.round(posArray[0]);
						   posArray[1] = Math.round(posArray[1]);
						   posArray[2] = Math.round(posArray[2]);
						   var result = true;
						   
						   
						   result = true;
						   for(i=1;i<4;i++){
							var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
							 
							}else{
							 result = false;
							}
						   }
						   if(result){    
							for(i=1;i<4;i++){
							 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							 blocklist[blockPositionData[tempPosition]]=-1;
							}
							blocklist[tempBlockIndex]=blockToBeam[currentBlock];

							rotationList[tempBlockIndex]=rotation;     
						   }
						   
						   
						  }
						 }

						}

						function beamifyaxis3m(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
						 var tempBlockIndex = blockIndex;
						 var currentBlock = blocklist[tempBlockIndex];
						 if(ItemDic[currentBlock]){
						  if(blockToBeam3m[currentBlock]){
						   var currentColor = colorlist[tempBlockIndex];
						   var currentPosition = positionList[tempBlockIndex];
						   
						   var posArray = JSON.parse("["+currentPosition+"]");
						   posArray[0] = Math.round(posArray[0]);
						   posArray[1] = Math.round(posArray[1]);
						   posArray[2] = Math.round(posArray[2]);
						   var result = true;
						   
						   
						   result = true;
						   for(i=1;i<3;i++){
							var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
							 
							}else{
							 result = false;
							}
						   }
						   if(result){
							for(i=1;i<3;i++){
							 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							 blocklist[blockPositionData[tempPosition]]=-1;
							}
							blocklist[tempBlockIndex]=blockToBeam3m[currentBlock];
							rotationList[tempBlockIndex]=rotation;     
						   }
						   
						   
						  }
						 }

						}

						function beamifyaxis2m(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
						 var tempBlockIndex = blockIndex;
						 var currentBlock = blocklist[tempBlockIndex];
						 if(ItemDic[currentBlock]){
						  if(blockToBeam2m[currentBlock]){
						   var currentColor = colorlist[tempBlockIndex];
						   var currentPosition = positionList[tempBlockIndex];
						   
						   var posArray = JSON.parse("["+currentPosition+"]");
						   posArray[0] = Math.round(posArray[0]);
						   posArray[1] = Math.round(posArray[1]);
						   posArray[2] = Math.round(posArray[2]);
						   var result = true;
						   
						   
						   result = true;
						   for(i=1;i<2;i++){
							var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
							 
							}else{
							 result = false;
							}
						   }
						   if(result){
							for(i=1;i<2;i++){
							 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
							 blocklist[blockPositionData[tempPosition]]=-1;
							}
							blocklist[tempBlockIndex]=blockToBeam2m[currentBlock];
							rotationList[tempBlockIndex]=rotation;     
						   }
						   
						   
						  }
						 }

						}

						function getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData){
						 
						 var queue1=[blockIndex];
						 var queue1index=1; 
						 var queue1process=0;
						 while(queue1process<queue1index){
						  var tempBlockIndex = queue1[queue1process];
						  var currentBlock = blocklist[tempBlockIndex];
						  var currentColor = colorlist[tempBlockIndex];
						  var currentPosition = positionList[tempBlockIndex];
						  var posArray = JSON.parse("["+currentPosition+"]");
						  posArray[0] = Math.round(posArray[0]);
						  posArray[1] = Math.round(posArray[1]);
						  posArray[2] = Math.round(posArray[2]);
						  var tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]);
						  if(blockPositionData[tempPosition]){
						   var tempblock = {}
						   tempblock.blockIndex=tempBlockIndex;
						   tempblock.score=0;
						   localPositionData[tempPosition]=tempblock;
						   delete blockPositionData[tempPosition]; 
						   
						   tempPosition = "" + (posArray[0]+1)+","+(posArray[1])+","+(posArray[2]);
						   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
							queue1[queue1index]=blockPositionData[tempPosition];
							queue1index++;
						   }
						   
						   tempPosition = "" + (posArray[0]-1)+","+(posArray[1])+","+(posArray[2]);
						   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
							queue1[queue1index]=blockPositionData[tempPosition];
							queue1index++;
						   }

						   tempPosition = "" + (posArray[0])+","+(posArray[1]+1)+","+(posArray[2]);
						   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
							queue1[queue1index]=blockPositionData[tempPosition];
							queue1index++;
						   }

						   tempPosition = "" + (posArray[0])+","+(posArray[1]-1)+","+(posArray[2]);
						   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
							queue1[queue1index]=blockPositionData[tempPosition];
							queue1index++;
						   }

						   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]+1);
						   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
							queue1[queue1index]=blockPositionData[tempPosition];
							queue1index++;
						   }

						   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]-1);
						   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
							queue1[queue1index]=blockPositionData[tempPosition];
							queue1index++;
						   }   
						   
						   
						  }
						 
						 
						  queue1process++;
						 }

						}

						//get an array containing 1x1x1 blocks in a direction.
						function getLookbackArray(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData){
						 var tempindex=0;
						 var tempList=[];
						 var tempBlockIndex = blockIndex;
						 var currentBlock = blocklist[tempBlockIndex];
						 var currentColor = colorlist[tempBlockIndex];
						 var currentPosition = positionList[tempBlockIndex];
						 var posArray = JSON.parse("["+currentPosition+"]");
						 posArray[0] = Math.round(posArray[0]);
						 posArray[1] = Math.round(posArray[1]);
						 posArray[2] = Math.round(posArray[2]); 
						 
						 
						 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
						 
						 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
						  tempList[tempindex]=blockPositionData[tempPosition];
						  
						  tempindex+=1;
						  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
						  
						 }
						 return tempList;
						}

						function getLookbackArraySloped(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList){
						 var tempindex=0;
						 var tempList=[];
						 var tempBlockIndex = blockIndex;
						 var currentBlock = blocklist[tempBlockIndex];
						 var currentColor = colorlist[tempBlockIndex];
						 var currentPosition = positionList[tempBlockIndex];
						 var currentRotation = rotationList[tempBlockIndex];
						 var posArray = JSON.parse("["+currentPosition+"]");
						 posArray[0] = Math.round(posArray[0]);
						 posArray[1] = Math.round(posArray[1]);
						 posArray[2] = Math.round(posArray[2]); 
						 
						 
						 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
						 
						 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
						  tempList[tempindex]=blockPositionData[tempPosition];
						  
						  tempindex+=1;
						  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
						  
						 }
						 return tempList;
						}




						function becomeStructure(blocks,subcon){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  if(!(SClist[scID].COL)){
						   //no palette=turret or spinblock
						   becomeStructure(SClist[scID],true);
						  } 
						  
						 }
						 var start=0;
						 if(subcon){
						  start=1;
						 }
						 var deletecount=0;
						 var blocklist=blocks.BlockIds;
						 for(var blockIndex = start; blockIndex < blocklist.length; blockIndex++){
						  var currentBlockInfo = getBlock(blocklist[blockIndex]);
						  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnStructure)){
						   deletecount+=1;
						   blocklist[blockIndex]=-1;
						  }

						 }
						 
						cleanBlueprint(blocks);
						}


						function becomeVehicle(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  becomeVehicle(SClist[scID]);
						 }
						 var deletecount=0;
						 var blocklist=blocks.BlockIds;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlockInfo = getBlock(blocklist[blockIndex]);
						  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnVehicle)){
						   deletecount+=1;
						   blocklist[blockIndex]=-1;
						  }

						 }
						 cleanBlueprint(blocks);
						 
						}


						function cutInHalfSC(blocks,midx){
							var blocklist=blocks.BlockIds;
							var positionList=blocks.BLP;
							var scRotation = "["+blocks.LocalRotation+"]";
							var scPosition = "["+blocks.LocalPosition+"]";
							var scp = JSON.parse(scPosition);
							var q = JSON.parse(scRotation);
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var currentPosition = "["+positionList[blockIndex]+"]";
								var tpa = JSON.parse(currentPosition);
								var tpaq = [tpa[0],tpa[1],tpa[2],0];
								var transpos = quatmul(q,quatmul(tpaq,quatconj(q)));
								var finalx = scp[0]+transpos[0];
								finalx=Math.round(finalx);
								if(finalx>midx){
									blocklist[blockIndex]=-1;
								}
							}
							cleanBlueprint(blocks);
						}

						function cutInHalf(blocks,xshift){
							blocks.designChanged = true;
							var SClist=blocks.SCs;
							var minx=0;
							var maxx=0;
							var midx=0;
							var blocklist=blocks.BlockIds;
							var positionList=blocks.BLP;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var currentPosition = "["+positionList[blockIndex]+"]";
								var tpa = JSON.parse(currentPosition);
								var curx = Math.round(tpa[0]);
								minx=Math.min(curx,minx);
								maxx=Math.max(curx,maxx);
							}
							midx=((minx+maxx)/2)+xshift;

							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var currentPosition = "["+positionList[blockIndex]+"]";
								var tpa = JSON.parse(currentPosition);
								var curx = Math.round(tpa[0]);
								if (curx>midx){
									blocklist[blockIndex]=-1;
								}
							}

							for(var scID = 0; scID < SClist.length; scID++){
								if(!(SClist[scID].COL)){
									var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
									var tpa = JSON.parse(currentPosition);
									var curx = Math.round(tpa[0]);
									if(curx>midx){
										SClist[scID].ItemNumber=-1;
									}else{
										cutInHalfSC(SClist[scID],midx);
									}
								}else{
									SClist[scID].ItemNumber=-1;
								}
							}
							cleanBlueprint(blocks);
						}



						//need to modify when we can check for parts sticking out
						function widenVehicle(blocks,xdist,xshift){
							blocks.designChanged = true;
							var blockPositionData={};
							var SClist=blocks.SCs;
							var minx=0;
							var maxx=0;
							var miny=0;
							var maxy=0;
							var minz=0;
							var maxz=0;
							var midx=0;
							var leftx=0;
							var rightx=0;
							var bestrs;
							var bestls;
							var bestrp;
							var bestlp;	
							var xmove=Math.round(parseFloat(xdist));
							var maxmirrorx=0;
							var rightconnected=false;
							var leftconnected=false;	
							var fillerblock=GuidToID["9a0ae372-beb4-4009-b14e-36ed0715af73"];		
							var blocklist=blocks.BlockIds;
							var positionList=blocks.BLP;
							var rotationList=blocks.BLR;
							var bp1list=blocks.BP1;
							var bp2list=blocks.BP2;
							var colorlist=blocks.BCI;
							var beilist=blocks.BEI;	
							var blockcount=blocklist.length; //needed cause variableblocklist :D
							var beiIndex=0;
							var currentIndex = blockcount; //index to add new blocks
							var currentBeiIndex = beilist.length;; //index to add new blocks
							var currentSCIndex=SClist.length;
							var SCcount=SClist.length;
							for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var currentPosition = "["+positionList[blockIndex]+"]";
								var tpa = JSON.parse(currentPosition);
								var curx = Math.round(tpa[0]);
								blockPositionData[atos(tpa)]=blockIndex;
								minx=Math.min(curx,minx);
								maxx=Math.max(curx,maxx);
								miny=Math.min(tpa[1],miny);
								maxy=Math.max(tpa[1],maxy);
								minz=Math.min(tpa[2],minz);
								maxz=Math.max(tpa[2],maxz);
							}
							var midy=Math.round((miny+maxy)/2);
							var midz=Math.round((minz+maxz)/2);	
							midx=((minx+maxx)/2)+parseFloat(xshift);
							midx=Math.round(midx-0.2);
							leftx=midx;
							rightx=leftx+1;	
							
							for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var tpa = stoar(positionList[blockIndex]);
								var curx = tpa[0];
								if (curx>midx){
									positionList[blockIndex]=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
									if((tpa[0]==rightx)&&(!leftconnected)&&(!rightconnected)){
										leftblock=atos([leftx,tpa[1],tpa[2]]);
										if(blockPositionData[leftblock]!==undefined&&blockPositionData[leftblock]>=0){
											midy=tpa[1];
											midz=tpa[2];
											leftconnected=true;
											rightconnected=true;
										}
									}
									if((tpa[0]==rightx)&&(!rightconnected)){
										if(!bestrp){
											bestrp=atos(tpa);
											bestrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
										}else{
											var currentrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
											if(currentrs<bestrs){
												bestrp=atos(tpa);
												bestrs=currentrs;
											}
										}
										
									}
								
								}else{
									if((tpa[0]==leftx)&&(!leftconnected)){
										if(!bestlp){
											bestlp=atos(tpa);
											bestls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
										}else{
											var currentls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
											if(currentls<bestls){
												bestlp=atos(tpa);
												bestls=currentls;					
											}
										}
									}
								}
							}
							//add filllerblock

							for (var i=rightx;i<(rightx+xmove);i++){
								blocks.BlockIds[currentIndex]=fillerblock;
								blocks.BLP[currentIndex]=atos([i,midy,midz]);
								blocks.BLR[currentIndex]=0;
								blocks.BP1[currentIndex]="0,0,0,0";
								blocks.BP2[currentIndex]="0,0,0,0";
								blocks.BCI[currentIndex]=0;
								currentIndex++;
							}
							
							//connect left
							if((bestlp)&&(!leftconnected)){
								var bestla=stoar(bestlp);
								var starty=Math.min(bestla[1],midy+1);
								var endy=Math.max(bestla[1],midy-1);		
								var startz=Math.min(bestla[2],midz+1);
								var endz=Math.max(bestla[2],midz-1);
								
								for(var y=starty;y<=endy;y++){
									blocks.BlockIds[currentIndex]=fillerblock;
									blocks.BLP[currentIndex]=atos([leftx+1,y,midz]);
									blocks.BLR[currentIndex]=0;
									blocks.BP1[currentIndex]="0,0,0,0";
									blocks.BP2[currentIndex]="0,0,0,0";
									blocks.BCI[currentIndex]=0;
									currentIndex++;		
								}
								for(var z=startz;z<=endz;z++){
									blocks.BlockIds[currentIndex]=fillerblock;
									blocks.BLP[currentIndex]=atos([leftx+1,bestla[1],z]);
									blocks.BLR[currentIndex]=0;
									blocks.BP1[currentIndex]="0,0,0,0";
									blocks.BP2[currentIndex]="0,0,0,0";
									blocks.BCI[currentIndex]=0;
									currentIndex++;		
								}
								leftconnected=true;
							}
							//connect right
							if((bestrp)&&(!rightconnected)){
								var bestra=stoar(bestrp);
								var starty=Math.min(bestra[1],midy+1);
								var endy=Math.max(bestra[1],midy-1);		
								var startz=Math.min(bestra[2],midz+1);
								var endz=Math.max(bestra[2],midz-1);
								
								for(var y=starty;y<=endy;y++){
									blocks.BlockIds[currentIndex]=fillerblock;
									blocks.BLP[currentIndex]=atos([leftx+xmove,y,midz]);
									blocks.BLR[currentIndex]=0;
									blocks.BP1[currentIndex]="0,0,0,0";
									blocks.BP2[currentIndex]="0,0,0,0";
									blocks.BCI[currentIndex]=0;
									currentIndex++;		
								}
								for(var z=startz;z<=endz;z++){
									blocks.BlockIds[currentIndex]=fillerblock;
									blocks.BLP[currentIndex]=atos([leftx+xmove,bestra[1],z]);
									blocks.BLR[currentIndex]=0;
									blocks.BP1[currentIndex]="0,0,0,0";
									blocks.BP2[currentIndex]="0,0,0,0";
									blocks.BCI[currentIndex]=0;
									currentIndex++;		
								}
								rightconnected=true;
							}
							if((!leftconnected)||(!rightconnected)){
								alert("Left and right sides might not be connected properly");
							}


							for(var scID = 0; scID < SCcount; scID++){
								var sctype=getType(SClist[scID].ItemNumber);
								var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
								var tpa = stoar((SClist[scID]).LocalPosition);
								var curx = tpa[0];
								if(curx>midx){			
									(SClist[scID]).LocalPosition=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
									//check if turret disconnected
									if((sctype==2)&&(tpa[0]==rightx)){
										var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
										if(Math.round(newpos[0])==-1){
											alert("A turret or spin block might be disconnected after after the process.");
										}
									}
								}else{
									if((sctype==2)&&(tpa[0]==leftx)){
										var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
										if(Math.round(newpos[0])==1){
											alert("A turret or spin block might be disconnected after after the process.");
										}			
									}
									
								}
							}
							cleanBlueprint(blocks);		
						}



						//need to modify when we can check for parts sticking out
						function cutAndMirror(blocks,xshift,even){
							blocks.designChanged = true;
							var SClist=blocks.SCs;
							var minx=0;
							var maxx=0;
							var midx=0;
							var xmove=0;
							var maxmirrorx=0;
							var blocklist=blocks.BlockIds;
							var positionList=blocks.BLP;
							var rotationList=blocks.BLR;
							var bp1list=blocks.BP1;
							var bp2list=blocks.BP2;
							var colorlist=blocks.BCI;
							var beilist=blocks.BEI;	
							var blockcount=blocklist.length; //needed cause variableblocklist :D
							var beiIndex=0;
							var currentIndex = blockcount; //index to add new blocks
							var currentBeiIndex = beilist.length;; //index to add new blocks
							var currentSCIndex=SClist.length;
							var SCcount=SClist.length;
							for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var currentPosition = "["+positionList[blockIndex]+"]";
								var tpa = JSON.parse(currentPosition);
								var curx = Math.round(tpa[0]);
								minx=Math.min(curx,minx);
								maxx=Math.max(curx,maxx);
							}
							
							midx=((minx+maxx)/2)+xshift;
							midx=Math.round(midx-0.2);
							
							if(even){
								maxmirrorx=midx;
								xmove=(midx*2)+1;
							}else{
								maxmirrorx=midx-1;
								xmove=midx*2;
							}
							
							for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var tpa = stoar(positionList[blockIndex]);
								var curx = tpa[0];
								if (curx>midx){
									blocklist[blockIndex]=-1;
								}else if (curx<=maxmirrorx){
									var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

									blocks.BlockIds[currentIndex]=mirrordata.blockID;
									var newposition=stoar(mirrordata.position);
									newposition[0]=newposition[0]+xmove;
									blocks.BLP[currentIndex]=atos(newposition);
									blocks.BLR[currentIndex]=mirrordata.rotation;
									blocks.BP1[currentIndex]=bp1list[blockIndex];
									blocks.BP2[currentIndex]=bp2list[blockIndex];
									blocks.BCI[currentIndex]=colorlist[blockIndex];
									if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
										blocks.BEI[currentBeiIndex]=currentIndex;
										var beiIncrement = beilist[beiIndex+1]+2;
										for(var i=1;i<beiIncrement;i++){
											blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
										}
										beiIndex+=beiIncrement;
										currentBeiIndex+=beiIncrement;
									}else if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){				
										var beiIncrement = beilist[beiIndex+1]+2;
										beiIndex+=beiIncrement;
									}		
									//blocklist[blockIndex]=-1;			
									currentIndex+=1;
								}
										
							}

							for(var scID = 0; scID < SCcount; scID++){
								if(!(SClist[scID].COL)){
									var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
									var tpa = stoar((SClist[scID]).LocalPosition);
									var curx = tpa[0];
									if(curx>midx){
										SClist[scID].ItemNumber=-1;
									}else if (curx<=maxmirrorx){
										tpa[0]=xmove-tpa[0];
										blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
										blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
										blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
										mirrorVehicle(blocks.SCs[currentSCIndex]);
										currentSCIndex++;			
									}			
								}else{
									SClist[scID].ItemNumber=-1;
								}
							}
							cleanBlueprint(blocks);		
						}


						//need to modify when we can check for parts sticking out
						function jointMirror(blocks,even){
							blocks.designChanged = true;
							var SClist=blocks.SCs;
							var minx=0;
							var maxx=0;
							var xmove=0;
							var maxmirrorx=0;
							var blocklist=blocks.BlockIds;
							var positionList=blocks.BLP;
							var rotationList=blocks.BLR;
							var bp1list=blocks.BP1;
							var bp2list=blocks.BP2;
							var colorlist=blocks.BCI;
							var beilist=blocks.BEI;	
							var blockcount=blocklist.length; //needed cause variableblocklist :D
							var beiIndex=0;
							var currentIndex = blockcount; //index to add new blocks
							var currentBeiIndex = beilist.length;; //index to add new blocks
							var currentSCIndex=SClist.length;
							var SCcount=SClist.length;
							for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var currentPosition = "["+positionList[blockIndex]+"]";
								var tpa = JSON.parse(currentPosition);
								var curx = Math.round(tpa[0]);
								minx=Math.min(curx,minx);
								maxx=Math.max(curx,maxx);
							}
							
							
							
							if(even){
								maxmirrorx=maxx;
								xmove=(maxx*2)+1;
							}else{
								maxmirrorx=maxx-1;
								xmove=maxx*2;
							}


							
							for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								var tpa = stoar(positionList[blockIndex]);
								var curx = tpa[0];
								if (curx<=maxmirrorx){
									var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

									blocks.BlockIds[currentIndex]=mirrordata.blockID;
									var newposition=stoar(mirrordata.position);
									newposition[0]=newposition[0]+xmove;
									blocks.BLP[currentIndex]=atos(newposition);
									blocks.BLR[currentIndex]=mirrordata.rotation;
									blocks.BP1[currentIndex]=bp1list[blockIndex];
									blocks.BP2[currentIndex]=bp2list[blockIndex];
									blocks.BCI[currentIndex]=colorlist[blockIndex];
									if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
										blocks.BEI[currentBeiIndex]=currentIndex;
										var beiIncrement = beilist[beiIndex+1]+2;
										for(var i=1;i<beiIncrement;i++){
											blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
										}
										beiIndex+=beiIncrement;
										currentBeiIndex+=beiIncrement;
									}else if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){				
										var beiIncrement = beilist[beiIndex+1]+2;
										beiIndex+=beiIncrement;
									}		
									//blocklist[blockIndex]=-1;			
									currentIndex+=1;
								}
										
							}

							for(var scID = 0; scID < SCcount; scID++){
								if(!(SClist[scID].COL)){
									var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
									var tpa = stoar((SClist[scID]).LocalPosition);
									var curx = tpa[0];
									if (curx<=maxmirrorx){
										tpa[0]=xmove-tpa[0];
										blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
										blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
										blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
										mirrorVehicle(blocks.SCs[currentSCIndex]);
										currentSCIndex++;			
									}			
								}else{
									SClist[scID].ItemNumber=-1;
								}
							}
							cleanBlueprint(blocks);		
						}




						//turn blocks into beams
						function beamifyblocks(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  beamifyblocks(SClist[scID]);
						 }
						 var blockPositionData = {};
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 var positionList=blocks.BLP;
						 var rotationList = blocks.BLR;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock = blocklist[blockIndex];
						  if(ItemDic[currentBlock]){
						   if(blockToBeam[currentBlock]){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;    
							//var currentPosition = ""+Math.round(tpa[0])+","+Math.round(tpa[1])+","+Math.round(tpa[2]);
							//targetBlock =blockToBeam[currentBlock];    
							blockPositionData[currentPosition]=blockIndex;    
						   }
						  }
						 }
						 
						 //z=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
						   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
						   }

						  }

						 }//z=axis 
						 

						 //y=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
						   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
						   }

						  }
						 }//y=axis 
						 
						 
						 //x=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
						   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
						   }

						  }
						 }//x=axis  

							cleanBlueprint(blocks);
						}

						function beamifyblocks3m(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  beamifyblocks3m(SClist[scID]);
						 }
						 var blockPositionData = {};
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 var positionList=blocks.BLP;
						 var rotationList = blocks.BLR;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock = blocklist[blockIndex];
						  if(ItemDic[currentBlock]){
						   if(blockToBeam3m[currentBlock]){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;    
						 
							blockPositionData[currentPosition]=blockIndex;    
						   }
						  }
						 }
						 
						 //z=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){

						   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis3m(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
						   }

						  }

						 }//z=axis 
						 

						 //y=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){

						   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis3m(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
						   }

						  }
						 }//y=axis 
						 
						 
						 //x=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){

						   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis3m(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
						   }

						  }
						 }//x=axis  

							cleanBlueprint(blocks);
						}


						function beamifyblocks2m(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  beamifyblocks2m(SClist[scID]);
						 }
						 var blockPositionData = {};
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 var positionList=blocks.BLP;
						 var rotationList = blocks.BLR;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock = blocklist[blockIndex];
						  if(ItemDic[currentBlock]){
						   if(blockToBeam2m[currentBlock]){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;    
						 
							blockPositionData[currentPosition]=blockIndex;    
						   }
						  }
						 }
						 
						 //z=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){

						   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis2m(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
						   }

						  }

						 }//z=axis 
						 

						 //y=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){

						   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis2m(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
						   }

						  }
						 }//y=axis 
						 
						 
						 //x=axis
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex];
						  if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){

						   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
						   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxis2m(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
						   }

						  }
						 }//x=axis  

							cleanBlueprint(blocks);
						}



						function getAxis(axis,neg){
							var tempaxis=[0,0,0];
							if(neg){
								tempaxis[axis]=-1;
							}else{
								tempaxis[axis]=1;
							}
							return tempaxis;
						}


						//optimize


						function beamifyblocksOptimized(blocks){	
							var SClist=blocks.SCs;
							blocks.designChanged = true;
							for(var scID = 0; scID < SClist.length; scID++){
								beamifyblocksOptimized(SClist[scID]);
							}
							var blockPositionData = {};
							var blocklist=blocks.BlockIds;
							var colorlist=blocks.BCI;
							var positionList=blocks.BLP;
							var rotationList = blocks.BLR;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								if(ItemDic[currentBlock]){
									if(blockToBeam[currentBlock]){				
										var tpa = stoar(positionList[blockIndex]);
										var currentPosition = atos(tpa);
										blockPositionData[currentPosition]=blockIndex;    
									}
								}
							}

							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock=blocklist[blockIndex];
								if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){

									var localPositionData = {};
									getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
									while(true){
										for(position in localPositionData){
											if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
												delete localPositionData[position];
											}else{
												localPositionData[position].score=0;
											}
										}
										//scoring start
										var localScore=0;
										var beamAxis=0;
										for(position in localPositionData){
											var blockscore=false;
											var currentData=localPositionData[position];
											var lpa = stoar(position);
											var templength;
											var tempdir;
											//scoring for each axis x,y,z
											for (var axis=0;axis<3;axis++){
												templength=1;
												for(var neg=0;neg<2;neg++){
													tempdir=getAxis(axis,neg);
													for(var tempindex=1;tempindex<4;tempindex++){
														var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
														if(localPositionData[tempLocalPosition]!==undefined){
															templength+=1;      
														}else{
															break;
														}
													}
												}
												if (templength>=4){
													
													blockscore=true;
													beamAxis+=1;
													localPositionData[position].score+=(templength-1);
												}
											}
											//score local block
											if(blockscore){
												
												currentData.score+=1;
												localScore+=1;
											}
										}
										
										//proceed if there are beamable blocks
										if (localScore>0){					

											//beamAxis is number of axis that is beamable 

											var scoreTable=[];
											var scoreIndex=0;
											var dedup={};

											//permutate possible beams and scores, then sort
											var minscore=200;
											var scorecap=11;
											for(position in localPositionData){
												var currentData=localPositionData[position];
												var lpa = stoar(position);
												var tempdir1;
												var tempdir2;
												
												for (var axis=0;axis<3;axis++){
												
													dedup={};
													tempdir1=getAxis(axis,true);
													tempdir2=getAxis(axis,false);
													for(tempindex=0;tempindex<4;tempindex++){
														var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
														if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=4)){
															if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-12))){										
																dedup[tempLocalPosition]=true;
																continue;
															}
															var llpa = stoar(tempLocalPosition);
															if(!dedup[tempLocalPosition]){
																var templength=1;
																for(var temptempindex=1;temptempindex<4;temptempindex++){											
																	temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
																	if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=4)){
																		templength+=1;
																	}else{
																		break;
																	}
																}
																if(templength==4){
																	
																	dedup[tempLocalPosition]=true;
																	var scoreBlock=[];
																	for(var temptempindex=0;temptempindex<4;temptempindex++){
																		temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
																		scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
																	}
																	scoreBlock[4]=BeamAxisRot[axis]; //rotation
																	scoreBlock[5]=BeamAxisPriority[axis]; //priority
																	scoreBlock[6]=llpa[axis]; //priority2

																	var tempscore=scoreBlock[0].score+scoreBlock[1].score+scoreBlock[2].score+scoreBlock[3].score;
																	if((tempscore>=16)&&(tempscore<=minscore)){
																		minscore=tempscore;
																		scoreTable[scoreIndex] = scoreBlock;
																		scoreIndex++;
																	}
																}
															}
														}else{
															break;
														}
													}							

												}
										  
											}

											//sort
											var bestscore=199;
											while(scoreTable.length>0){
												scoreTable.sort(function(a, b){
													res=(a[0].score+a[1].score+a[2].score+a[3].score)-(b[0].score+b[1].score+b[2].score+b[3].score);
													if(res==0){
														var resa=(a[5]-b[5]);
														if(resa==0){
															return a[6]-b[6];
														}else{
															return resa;
														}
													}else{
														return res;
													}
												});

												currentScoreBlock=scoreTable[0];
												if((currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score)>bestscore){
													break;
												}else{
													bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score;
													currentScoreBlock[0].score=200;
													currentScoreBlock[1].score=200;
													currentScoreBlock[2].score=200;
													currentScoreBlock[3].score=200;							

													blocklist[currentScoreBlock[1].blockIndex]=-1;
													blocklist[currentScoreBlock[2].blockIndex]=-1;
													blocklist[currentScoreBlock[3].blockIndex]=-1;

													blocklist[currentScoreBlock[0].blockIndex]=blockToBeam[currentBlock];
													rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
												}
											}
										}
										else{
											//exit loop if no beamable blocks
											break;
										}
									}//end while
								   //scoring end
								}
							}
							cleanBlueprint(blocks);
						}


						//optimize3m
						function beamifyblocksOptimized3m(blocks){	
							var SClist=blocks.SCs;
							blocks.designChanged = true;
							for(var scID = 0; scID < SClist.length; scID++){
								beamifyblocksOptimized3m(SClist[scID]);
							}
							var blockPositionData = {};
							var blocklist=blocks.BlockIds;
							var colorlist=blocks.BCI;
							var positionList=blocks.BLP;
							var rotationList = blocks.BLR;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								if(ItemDic[currentBlock]){
									if(blockToBeam3m[currentBlock]){		
											
										var tpa = stoar(positionList[blockIndex]);
										var currentPosition = atos(tpa);
										blockPositionData[currentPosition]=blockIndex;    
									}
								}
							}

							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock=blocklist[blockIndex];
								if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){
									var localPositionData = {};
									getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
									while(true){
										for(position in localPositionData){
											if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
												delete localPositionData[position];
											}else{
												localPositionData[position].score=0;
											}
										}
										//scoring start
										var localScore=0;
										var beamAxis=0;
										for(position in localPositionData){
											var blockscore=false;
											var currentData=localPositionData[position];
											var lpa = stoar(position);
											var templength;
											var tempdir;
											//scoring for each axis x,y,z
											for (var axis=0;axis<3;axis++){
												templength=1;
												for(var neg=0;neg<2;neg++){
													tempdir=getAxis(axis,neg);
													for(var tempindex=1;tempindex<3;tempindex++){
														var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
														if(localPositionData[tempLocalPosition]!==undefined){
															templength+=1;      
														}else{
															break;
														}
													}
												}
												if (templength>=3){
													
													blockscore=true;
													beamAxis+=1;
													localPositionData[position].score+=(templength-1);
												}
											}
											//score local block
											if(blockscore){
												
												currentData.score+=1;
												localScore+=1;
											}
										}
										
										//proceed if there are beamable blocks
										if (localScore>0){					
											
											//beamAxis is number of axis that is beamable 

											var scoreTable=[];
											var scoreIndex=0;
											var dedup={};

											//permutate possible beams and scores, then sort
											var minscore=150;
											var scorecap=7;
											for(position in localPositionData){
												var currentData=localPositionData[position];
												var lpa = stoar(position);
												var tempdir1;
												var tempdir2;
												
												for (var axis=0;axis<3;axis++){
												
													dedup={};
													tempdir1=getAxis(axis,true);
													tempdir2=getAxis(axis,false);
													for(tempindex=0;tempindex<3;tempindex++){
														var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
														if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=3)){
															if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-9))){										
																dedup[tempLocalPosition]=true;
																continue;
															}
															var llpa = stoar(tempLocalPosition);
															if(!dedup[tempLocalPosition]){
																var templength=1;
																for(var temptempindex=1;temptempindex<3;temptempindex++){											
																	temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
																	if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=3)){
																		templength+=1;
																	}else{
																		break;
																	}
																}
																if(templength==3){
																	
																	dedup[tempLocalPosition]=true;
																	var scoreBlock=[];
																	for(var temptempindex=0;temptempindex<3;temptempindex++){
																		temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
																		scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
																	}
																	scoreBlock[4]=BeamAxisRot[axis]; //rotation
																	scoreBlock[5]=BeamAxisPriority[axis]; //priority
																	scoreBlock[6]=llpa[axis]; //priority2

																	var tempscore=scoreBlock[0].score+scoreBlock[1].score+scoreBlock[2].score;
																	if((tempscore>=9)&&(tempscore<=minscore)){
																		minscore=tempscore;
																		scoreTable[scoreIndex] = scoreBlock;
																		scoreIndex++;
																	}
																}
															}
														}else{
															break;
														}
													}							

												}
										  
											}

											//sort
											var bestscore=149;
											while(scoreTable.length>0){
												scoreTable.sort(function(a, b){
													res=(a[0].score+a[1].score+a[2].score)-(b[0].score+b[1].score+b[2].score);
													if(res==0){
														var resa=(a[5]-b[5]);
														if(resa==0){
															return a[6]-b[6];
														}else{
															return resa;
														}
													}else{
														return res;
													}
												});

												currentScoreBlock=scoreTable[0];
												if((currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score)>bestscore){
													break;
												}else{
													bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score;
													currentScoreBlock[0].score=150;
													currentScoreBlock[1].score=150;
													currentScoreBlock[2].score=150;
													

													blocklist[currentScoreBlock[1].blockIndex]=-1;
													blocklist[currentScoreBlock[2].blockIndex]=-1;
													

													blocklist[currentScoreBlock[0].blockIndex]=blockToBeam3m[currentBlock];
													rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
												}
											}
										}
										else{
											//exit loop if no beamable blocks
											break;
										}
									}//end while
								   //scoring end
								}
							}
							cleanBlueprint(blocks);
						}



						//optimize2m
						function beamifyblocksOptimized2m(blocks){	
							var SClist=blocks.SCs;
							blocks.designChanged = true;
							for(var scID = 0; scID < SClist.length; scID++){
								beamifyblocksOptimized2m(SClist[scID]);
							}
							var blockPositionData = {};
							var blocklist=blocks.BlockIds;
							var colorlist=blocks.BCI;
							var positionList=blocks.BLP;
							var rotationList = blocks.BLR;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock = blocklist[blockIndex];
								if(ItemDic[currentBlock]){
									if(blockToBeam2m[currentBlock]){		
											
										var tpa = stoar(positionList[blockIndex]);
										var currentPosition = atos(tpa);
										blockPositionData[currentPosition]=blockIndex;    
									}
								}
							}

							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								var currentBlock=blocklist[blockIndex];
								if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){
									var localPositionData = {};
									getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
									while(true){
										for(position in localPositionData){
											if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
												delete localPositionData[position];
											}else{
												localPositionData[position].score=0;
											}
										}
										//scoring start
										var localScore=0;
										var beamAxis=0;
										for(position in localPositionData){
											var blockscore=false;
											var currentData=localPositionData[position];
											var lpa = stoar(position);
											var templength;
											var tempdir;
											//scoring for each axis x,y,z
											for (var axis=0;axis<3;axis++){
												templength=1;
												for(var neg=0;neg<2;neg++){
													tempdir=getAxis(axis,neg);
													for(var tempindex=1;tempindex<2;tempindex++){
														var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
														if(localPositionData[tempLocalPosition]!==undefined){
															templength+=1;      
														}else{
															break;
														}
													}
												}
												if (templength>=2){
													
													blockscore=true;
													beamAxis+=1;
													localPositionData[position].score+=(templength-1);
												}
											}
											//score local block
											if(blockscore){
												
												currentData.score+=1;
												localScore+=1;
											}
										}
										
										//proceed if there are beamable blocks
										if (localScore>0){					
											
											//beamAxis is number of axis that is beamable 

											var scoreTable=[];
											var scoreIndex=0;
											var dedup={};

											//permutate possible beams and scores, then sort
											var minscore=100;
											var scorecap=2;
											for(position in localPositionData){
												var currentData=localPositionData[position];
												var lpa = stoar(position);
												var tempdir1;
												var tempdir2;
												
												for (var axis=0;axis<3;axis++){
												
													dedup={};
													tempdir1=getAxis(axis,true);
													tempdir2=getAxis(axis,false);
													for(tempindex=0;tempindex<2;tempindex++){
														var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
														if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=2)){
															if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-1))){										
																dedup[tempLocalPosition]=true;
																continue;
															}
															var llpa = stoar(tempLocalPosition);
															if(!dedup[tempLocalPosition]){
																var templength=1;
																for(var temptempindex=1;temptempindex<2;temptempindex++){											
																	temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
																	if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=2)){
																		templength+=1;
																	}else{
																		break;
																	}
																}
																if(templength==2){
																	
																	dedup[tempLocalPosition]=true;
																	var scoreBlock=[];
																	for(var temptempindex=0;temptempindex<2;temptempindex++){
																		temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
																		scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
																	}
																	scoreBlock[4]=BeamAxisRot[axis]; //rotation
																	scoreBlock[5]=BeamAxisPriority[axis]; //priority
																	scoreBlock[6]=llpa[axis]; //priority2

																	var tempscore=scoreBlock[0].score+scoreBlock[1].score;
																	if((tempscore>=2)&&(tempscore<=minscore)){
																		minscore=tempscore;
																		scoreTable[scoreIndex] = scoreBlock;
																		scoreIndex++;
																	}
																}
															}
														}else{
															break;
														}
													}							

												}
										  
											}

											//sort
											var bestscore=99;
											while(scoreTable.length>0){
												scoreTable.sort(function(a, b){
													res=(a[0].score+a[1].score)-(b[0].score+b[1].score);
													if(res==0){
														var resa=(a[5]-b[5]);
														if(resa==0){
															return a[6]-b[6];
														}else{
															return resa;
														}
													}else{
														return res;
													}
												});

												currentScoreBlock=scoreTable[0];
												if((currentScoreBlock[0].score+currentScoreBlock[1].score)>bestscore){
													break;
												}else{
													bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score;
													currentScoreBlock[0].score=100;
													currentScoreBlock[1].score=100;
												


													blocklist[currentScoreBlock[1].blockIndex]=-1;
													
													

													blocklist[currentScoreBlock[0].blockIndex]=blockToBeam2m[currentBlock];
													rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
												}
											}
										}
										else{
											//exit loop if no beamable blocks
											break;
										}
									}//end while
								   //scoring end
								}
							}
							cleanBlueprint(blocks);
						}

						function removeOverlap(blocks){
							var blockPosData = {};
							var blocklist=blocks.BlockIds;
							var colorlist=blocks.BCI;
							var positionList=blocks.BLP;
							var rotationList = blocks.BLR;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){		
								var currentBlock = blocklist[blockIndex];
								var blockData = getBlock(currentBlock);
								var tempBlock={};
								var currentPosition = stoar(positionList[blockIndex]);
								tempBlock.blockId=currentBlock;
								tempBlock.blockIndex=blockIndex;
								tempBlock.pos=positionList[blockIndex];
								tempBlock.rot=rotationList[blockIndex];
								tempBlock.bci=colorlist[blockIndex];
								tempBlock.overlap=false;
								if(blockData){
									
									for (var x=blockData.negx;x<=blockData.posx;x++){
										for (var y=blockData.negy;y<=blockData.posy;y++){
											for (var z=blockData.negz;z<=blockData.posz;z++){
												var q=getQuat(rotationList[blockIndex]);
												var temppos=posTransform([x,y,z],q);
												currentPosition
												var strPos=atos([temppos[0]+currentPosition[0],temppos[1]+currentPosition[1],temppos[2]+currentPosition[2]]);
												if (blockPosData[strPos]){
													//overlap
													//maybe can consider performing beam to block here
													tempBlock.overlap=true;
													blocklist[blockIndex]=-1;
												}else{
													blockPosData[strPos]=tempBlock;
													//no overlap
												}
											}
										}
									}
								}else{
									//block not found?
								}
							
							}
							var tempBlockIndex=blocklist.length;
							for(position in blockPosData){
								var tempBlock=blockPosData[position];
								if(tempBlock.overlap){
										var tempbtb=0;
										if(beamToBlock[tempBlock.blockId]){
											tempbtb=beamToBlock[tempBlock.blockId];
										}else if(beamToBlock3m[tempBlock.blockId]){
											tempbtb=beamToBlock3m[tempBlock.blockId];
										}else if(beamToBlock2m[tempBlock.blockId]){
											tempbtb=beamToBlock2m[tempBlock.blockId];
										}
									if(tempbtb){
										var newBlockId=tempbtb;
										blocklist[tempBlockIndex]=newBlockId;
										rotationList[tempBlockIndex]=0;
										colorlist[tempBlockIndex]=tempBlock.bci;
										blocks.BP1[tempBlockIndex]="0,0,0,0";
										blocks.BP2[tempBlockIndex]="0,0,0,0";
										positionList[tempBlockIndex]= position;
										tempBlockIndex+=1;				
									}else if(slopeBeamToBlock[tempBlock.blockId]){
										var newBlockId=slopeBeamToBlock[tempBlock.blockId];
										blocklist[tempBlockIndex]=newBlockId;
										var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],false);
										rotationList[tempBlockIndex]=targetRotation;
										colorlist[tempBlockIndex]=tempBlock.bci;
										blocks.BP1[tempBlockIndex]="0,0,0,0";
										blocks.BP2[tempBlockIndex]="0,0,0,0";
										positionList[tempBlockIndex]= position;
										tempBlockIndex+=1;			
									}else if(slopeBeamToBlockM[tempBlock.blockId]){
										var newBlockId=slopeBeamToBlockM[tempBlock.blockId];
										blocklist[tempBlockIndex]=newBlockId;
										var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],true);
										rotationList[tempBlockIndex]=targetRotation;
										colorlist[tempBlockIndex]=tempBlock.bci;
										blocks.BP1[tempBlockIndex]="0,0,0,0";
										blocks.BP2[tempBlockIndex]="0,0,0,0";
										positionList[tempBlockIndex]= position;
										tempBlockIndex+=1;			
									}

								}
								
							}
							cleanBlueprint(blocks);
						}


						function beamifyslopeblocks(blocks){
						 var SClist=blocks.SCs;
						 blocks.designChanged = true;
						 for(var scID = 0; scID < SClist.length; scID++){
						  beamifyslopeblocks(SClist[scID]);
						 }
						 var blockPositionData = {};
						 var blocklist=blocks.BlockIds;
						 var colorlist=blocks.BCI;
						 var positionList=blocks.BLP;
						 var rotationList = blocks.BLR;
						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock = blocklist[blockIndex];
						  if(ItemDic[currentBlock]){
						   if(slopeBlockToBeam[currentBlock]){
							var currentPosition = "["+positionList[blockIndex]+"]";
							var tpa = JSON.parse(currentPosition);
							var curx = Math.round(tpa[0]);
							var cury = Math.round(tpa[1]);
							var curz = Math.round(tpa[2]);
							currentPosition = ""+curx+","+cury+","+curz;       
							blockPositionData[currentPosition]=blockIndex;    
						   }
						  }
						 }
						 


						 
						 

						 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
						  var currentBlock=blocklist[blockIndex]; 
						  var currentRotation=rotationList[blockIndex];


						  var dirx=0;
						  var diry=0;
						  var dirz=0;

						  switch (currentRotation) {
						   case 0:
						   case 2:
						   case 4:
						   case 6:
						   case 8:
						   case 10:
						   case 12:
						   case 14:
							dirx=1;
							diry=0;
							dirz=0;
							break;
						   case 16:
						   case 17:
						   case 18:
						   case 19:
						   case 20:
						   case 21:
						   case 22:
						   case 23:
							dirx=0;
							diry=1;
							dirz=0;
							break;   
						   case 1:
						   case 3:
						   case 5:
						   case 7:
						   case 9:
						   case 11:
						   case 13:
						   case 15:
							dirx=0;
							diry=0;
							dirz=1;
							break;
						   default:
						  } 
						 

						  if(ItemDic[currentBlock]&&slopeBlockToBeam[currentBlock]){
						  
						   var lookbackArray=getLookbackArraySloped((-dirx),(-diry),(-dirz),blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList);   
						   for(var k=(lookbackArray.length-1);k>=0;k--){
							beamifyaxisSloped(dirx,diry,dirz,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,slopeBlockToBeamOrientation(currentRotation,false));
						   }

						  }

						 }
						 
							cleanBlueprint(blocks);
						}

						function updateBlockCount(blocks){
							var SClist=blocks.SCs;	
							for(var scID = 0; scID < SClist.length; scID++){
								updateBlockCount(SClist[scID]);
							}
							if(blocks.TotalBlockCount!==undefined){
								blocks.TotalBlockCount=blocks.BlockIds.length;
							}
							if(blocks.BlockCount!==undefined){
								blocks.BlockCount=blocks.BlockIds.length;
							}
							if(blocks.LastAliveBlock!==undefined){
								blocks.LastAliveBlock=blocks.BlockIds.length;
							}	
							if(blocks.IndexOfFirstBlockNeedingFullRepairCost!==undefined){
								blocks.IndexOfFirstBlockNeedingFullRepairCost=1000000;
							}	
						}
						
						
						
						function getconverted(bID){
						 if (conversionIndex[bID]){
						  return conversionIndex[bID];  
						 }
						 else return(bID);
						}


						function buildReplaceOldIndex(){
							replaceOldIndex = {};
							for(var key in ItemDic){
								var keyint = parseInt(key);
								var val = ItemDic[keyint];
								if(oldBlocks[val]){
									var tempblock={};
									tempblock.BlockId=GuidToID[oldBlocks[val].Guid];
									tempblock.Rot=oldBlocks[val].Rot;
									replaceOldIndex[keyint]=tempblock;
								}
							}
						}
						
						

						function replaceOld(blocks){
							var SClist=blocks.SCs;
							blocks.designChanged = true;
							for(var scID = 0; scID < SClist.length; scID++){
								replaceOld(SClist[scID]);
							}
							var blocklist=blocks.BlockIds;
							var rotationList = blocks.BLR;
							for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
								if(replaceOldIndex[blocklist[blockIndex]]){
									var replaceData = replaceOldIndex[blocklist[blockIndex]];
									var newRotation = blockRotate(replaceData.Rot,rotationList[blockIndex]);
									var newBlock = replaceData.BlockId;				
									blocklist[blockIndex] = newBlock;
									rotationList[blockIndex] = newRotation;
								}
							}
						}						
						

					//builds a lookup table of blockIDs to convert from:to
					function buildconversionIndex(){
					 conversionIndex = {};
					 for(var mat in shapedBlocks){
					  if(document.getElementById(mat).checked){
					   newmat=document.getElementById(mat+"to").value;
						if (newmat!=mat){
						var blockcount = localShapedBlocks[mat].length;
						for(var i=0;i<blockcount;i++){
						   if(newmat==0){
							conversionIndex[localShapedBlocks[mat][i]]=-1;
						   }else if ((i<localShapedBlocks[newmat].length)&&(localShapedBlocks[newmat][i]>=0)){
						  conversionIndex[localShapedBlocks[mat][i]] = localShapedBlocks[newmat][i];
						 }
						}
					   }
					  }  
					 }
					}

					//get color to paint blocks depending on selected option
					function getNewColor(bID){
					 if(document.getElementById("paint").checked){
					  if(document.getElementById("painttarget").value=="all"){
					   return selectedcolor;      
					  }
					  else if(document.getElementById("painttarget").value=="paintothers"){
					   if(blockColorIndex[bID]!==undefined){
						return -1;
					   }else{
						return selectedcolor;
					   }
					  }else{
					   if(blockColorIndex[bID]!==undefined){
						return blockColorIndex[bID];
					   }else{
						return -1;
					   }
					  }

					 }
					 else{
					  return -1;
					 }
					}


					//builds lookup table to help determine which blocks to color
					function buildblockColorIndex(){
					/*
					painttarget:
					all
					wood
					metal
					alloy
					glass
					stone
					lead
					paintstruct
					paintothers
					*/
					 blockColorIndex = {};
					 
					 if(document.getElementById("paint").checked){
					  selectedcolor=document.getElementById("tocolor").value;
					  
					  if((document.getElementById("painttarget").value=="wood")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
					   var blockcount =  localShapedBlocks["wood"].length;
					   for(var i=0;i<blockcount;i++){
						blockColorIndex[localShapedBlocks["wood"][i]] = selectedcolor;
						
					   }
					  }
					  
					  if((document.getElementById("painttarget").value=="metal")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
					   var blockcount =  localShapedBlocks["metal"].length;
					   for(var i=0;i<blockcount;i++){
						blockColorIndex[localShapedBlocks["metal"][i]] = selectedcolor;
					   }
					  }  

					  if((document.getElementById("painttarget").value=="alloy")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
					   var blockcount =  localShapedBlocks["alloy"].length;
					   for(var i=0;i<blockcount;i++){
						blockColorIndex[localShapedBlocks["alloy"][i]] = selectedcolor;
					   }
					  } 

					  if((document.getElementById("painttarget").value=="glass")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
					   var blockcount =  localShapedBlocks["glass"].length;
					   for(var i=0;i<blockcount;i++){
						blockColorIndex[localShapedBlocks["glass"][i]] = selectedcolor;
					   }
					  }
					  
					  if((document.getElementById("painttarget").value=="heavyarmour")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
					   var blockcount =  localShapedBlocks["heavyarmour"].length;
					   for(var i=0;i<blockcount;i++){
						blockColorIndex[localShapedBlocks["heavyarmour"][i]] = selectedcolor;
					   }
					  }
					  
					  if((document.getElementById("painttarget").value=="stone")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
					   var blockcount =  localShapedBlocks["stone"].length;
					   for(var i=0;i<blockcount;i++){
						blockColorIndex[localShapedBlocks["stone"][i]] = selectedcolor;
					   }
					  }
					  if((document.getElementById("painttarget").value=="lead")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
					   var blockcount =  localShapedBlocks["lead"].length;
					   for(var i=0;i<blockcount;i++){
						blockColorIndex[localShapedBlocks["lead"][i]] = selectedcolor;
					   }
					  }
					 }
					}
					


					function getMirrorData(blockID,position,rotation){
						var newRotation = rotationMirror(rotation);
						var newBlock = blockID;
						var pa=stoar(position);
						pa[0]=(-pa[0]);


						if((ItemDic[blockID])&&(getBlock(blockID))){
							var curBlock = getBlock(blockID);
							var xdiff=Math.round(curBlock.XDiff);

							if(curBlock.MirrorBlock){
								var tempBlock=ItemTable[curBlock.MirrorBlock];
								if(GuidToID[curBlock.MirrorBlock]!==undefined){
									//newBlock=tempBlock.BlockId;
									newBlock=GuidToID[curBlock.MirrorBlock];
									xdiff=Math.round((xdiff+tempBlock.XDiff)/2);	
									
								}
								
							}
							if(xdiff!=0){
								var q=getQuat(newRotation);
								var positionshift=posTransform([-xdiff,0,0],q);
								pa[0]+=positionshift[0];
								pa[1]+=positionshift[1];
								pa[2]+=positionshift[2];
							} 
						}
						pa[0]=Math.round(parseFloat(pa[0]));
						pa[1]=Math.round(parseFloat(pa[1]));
						pa[2]=Math.round(parseFloat(pa[2]));

						var strposition = atos(pa);

						var mirrordata={}
						mirrordata.blockID=newBlock;
						mirrordata.position=strposition;
						mirrordata.rotation=newRotation;
						return mirrordata;
					}

					function cleanBlueprint(blocks){
						var SClist=blocks.SCs;
						var blocklist=blocks.BlockIds;
						var blrlist=blocks.BLR;
						var blplist=blocks.BLP;
						var bp1list=blocks.BP1;
						var bp2list=blocks.BP2;
						var bcilist=blocks.BCI; 
						var beilist=blocks.BEI;
						var blocknew=[];
						var blrnew=[];
						var blpnew=[];
						var bp1new=[];
						var bp2new=[];
						var bcinew=[];
						var beinew=[];
						var scnew=[];
						var newbeiindex=0;
						var currentIndex = 0;
						var beiIndex = 0;
						var newscindex=0;

						for(var scID = 0; scID < SClist.length; scID++){
							if(SClist[scID].ItemNumber>0){
								scnew[newscindex]=SClist[scID];
								newscindex++;
							}
						}

						for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
							if(blocklist[blockIndex]>=0){
								blocknew[currentIndex]=blocklist[blockIndex];
								blrnew[currentIndex]=blrlist[blockIndex];
								blpnew[currentIndex]=blplist[blockIndex];
								bp1new[currentIndex]=bp1list[blockIndex];
								bp2new[currentIndex]=bp2list[blockIndex];   
								bcinew[currentIndex]=bcilist[blockIndex];   

								if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
									beilist[beiIndex]=currentIndex;
									var beiIncrement = beilist[beiIndex+1]+2;
									for(var i=0;i<beiIncrement;i++){
										beinew[newbeiindex+i]=beilist[beiIndex+i];
									}
									beiIndex+=beiIncrement;
									newbeiindex+=beiIncrement;
								}
								currentIndex +=1;
							}else{
								//need to remove stringid references if block is removed
								if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
									var beiIncrement = beilist[beiIndex+1]+2;
									beiIndex+=beiIncrement;
								}
							}
							if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){
							var beiIncrement = beilist[beiIndex+1]+2;
							beiIndex+=beiIncrement;
							}
						}
						
						blocks.BlockIds=blocknew;
						blocks.BLR=blrnew;
						blocks.BLP=blpnew;
						blocks.BP1=bp1new;
						blocks.BP2=bp2new;
						blocks.BCI=bcinew;
						blocks.BEI=beinew;
						blocks.SCs=scnew;
					}

					function getType(blockid){
						var curBlock = getBlock(blockid);
						if(curBlock){
							return curBlock.ItemType;
						}else{
							return -1;
						}
					}

					
					
					function processData(){
					 //getblockdata

						


					 nameID = {}
						
					 
					 ItemDic =  CurrentBlueprint.ItemDictionary;
					 

					 var a1;
					 var a2;
					 var b1;
					 var b2;
					 var c1;
					 var c2;
					 var d1;
					 var d2;
					 var e1;
					 var e2;
					 var f1;
					 var f2;
					 var g1;
					 var g2;
					 
					 var a2m;
					 var a3m;
					 var b2m;
					 var b3m;
					 var c2m;
					 var c3m;
					 var d2m;
					 var d3m;
					 var g2m;
					 var g3m;
					 
					 //for sloped blocks
					 var aa1=-1;
					 var aa2=-1;
					 var aa3=-1;
					 var ab1=-1;
					 var ab2=-1;
					 var ab3=-1;
					 var ac1=-1;
					 var ac2=-1;
					 var ac3=-1;
					 var ad1=-1;
					 var ad2=-1;
					 var ad3=-1;
					 var ae1=-1;
					 var ae2=-1;
					 var ae3=-1;
					 
					 
					 blockToBeam={};
					 beamToBlock={};
					 blockToBeam2m={};
					 blockToBeam3m={};
					 beamToBlock2m={};
					 beamToBlock3m={};


					 
					 slopeBlockToBeam={};
					 slopeBeamToBlock={};
					 slopeBeamToBlockM={};
					  
					 
					 for(var key in ItemDic) {
					  var keyint = parseInt(key);
					  val = ItemDic[keyint];
					  if(ItemTable[val]){
					   nameID[keyint]=(ItemTable[val]).Name;
					   //ItemTable[val].BlockId=keyint;
					   GuidToID[val]=keyint;					   
					  }else{
					   nameID[keyint]=val;
					  }
					  
					  if (val=="9a0ae372-beb4-4009-b14e-36ed0715af73"){
					   a1=keyint;//woodblock
					  }else if(val=="05475442-0e52-4e0b-9fbb-2715f0e54f97"){
					   a2=keyint;//woodbeam
					  }else if(val=="ab699540-efc8-4592-bc97-204f6a874b3a"){
					   b1=keyint;//metalblock
					  }else if(val=="a7f5d8de-4882-4111-9d01-436493e5b2d8"){
					   b2=keyint;//metalbeam
					  }else if(val=="3cc75979-18ac-46c4-9a5b-25b327d99410"){
					   c1=keyint;//alloyblock
					  }else if(val=="9411e401-27da-4546-b805-3334f200f055"){
					   c2=keyint;//alloybeam
					  }else if(val=="2d519ca8-1f12-4a8e-9340-aa6648b5e799"){
					   d1=keyint;//glassblock
					  }else if(val=="395179c1-37a0-4250-851b-5bc19fd601b6"){
					   d2=keyint;//glassbeam
					  }else if(val=="e71e6f97-fbe8-4bf5-9645-d15179ba0c17"){
					   e1=keyint;//leadblock
					  }else if(val=="f5d2db25-114e-473a-8313-96831ccd011e"){
					   e2=keyint;//leadbeam
					  }else if(val=="710ee212-563b-42f8-acd1-57515479524d"){
					   f1=keyint;//stoneblock
					  }else if(val=="c7a19161-b361-4074-8c51-2398a0a70d1b"){
					   f2=keyint;//stonebeam
					  }else if(val=="0c03433e-8947-4e7d-9dec-793526fe06d1"){
					   g1=keyint;//heavyarmour block
					  }else if(val=="867cea4e-6ea4-4fe2-a4a1-b6230308f8f1"){
					   g2=keyint;//heavyarmour beam
					  }else if(val=="bdafa446-f615-49cb-94f3-d7652dde6cec"){
					   aa1=keyint;//wood
					  }else if(val=="2ee817c1-f2a3-407a-847d-b97ffb844e45"){
					   aa2=keyint;//wood
					  }else if(val=="d077c2a4-4578-4965-9318-c14bb7ac1bd6"){
					   aa3=keyint;//wood
					  }else if(val== "5548037e-8428-43f8-bcb6-d730dbcd0a79"){
					   ab1=keyint;//metal
					  }else if(val== "0d554a9d-7d06-48b3-8aea-ffaeaa30380a"){
					   ab2=keyint;//metal
					  }else if(val== "e5d065f6-907b-450d-b998-213cdc54eec1"){
					   ab3=keyint;//metal
					  }else if(val=="911fe222-f9b2-4892-9cd6-8b154d55b2aa"){
					   ac1=keyint;//alloy
					  }else if(val=="9af822b3-80d9-46bd-9ce0-e6e5c2e61da4"){
					   ac2=keyint;//alloy
					  }else if(val=="b5d46bb7-d49e-42f6-817b-323fbf6d62b0"){
					   ac3=keyint;//alloy
					  }else if(val=="174b5b41-b70e-485d-b00a-a61cc9826b2c"){
					   ad1=keyint;//glass
					  }else if(val=="35abb89b-33b8-4cb4-b3d0-ee132247de8d"){
					   ad2=keyint;//glass
					  }else if(val=="0c64d302-c6df-42eb-a0ff-7c90f867ba4b"){
					   ad3=keyint;//glass
					  }else if(val=="78b81c0a-44df-4c24-b2a5-5d273737da60"){
					   ae1=keyint;//heavyarmour
					  }else if(val=="6e5c9f1d-160b-49b1-9b74-606d2f695c7e"){
					   ae2=keyint;//heavyarmour
					  }else if(val=="c61c1c19-cc53-49a2-b207-9de6b9ce328a"){
					   ae3=keyint;//heavyarmour
					  }else if(val=="de36c624-8c78-4b52-8d86-431cec16a306"){
					   a2m=keyint;//woodbeam
					  }else if(val=="39553630-8281-40e4-96fb-b01c1f3537e6"){
					   a3m=keyint;//woodbeam
					  }else if(val=="2a22f176-01c2-42f2-a7d2-2c7054504aa9"){
					   b2m=keyint;//metalbeam
					  }else if(val=="46f54639-5f91-4731-93eb-e5c0a7460538"){
					   b3m=keyint;//metalbeam
					  }else if(val=="8f9dbf41-6c2d-4e7b-855d-b2432c6942a2"){
					   c2m=keyint;//alloybeam
					  }else if(val=="649f2aec-6f59-4157-ac01-0122ce2e6dad"){
					   c3m=keyint;//alloybeam
					  }else if(val=="aa355fd9-295c-43f3-9f11-7a781a9808b0"){
					   d2m=keyint;//glassbeam
					  }else if(val=="049b9d0c-1cb3-4511-be7f-9fad6e0a607e"){
					   d3m=keyint;//glassbeam
					  }else if(val=="242e07fa-399f-4caa-bfc2-1b77bd2bd538"){
					   g2m=keyint;//heavyarmour beam
					  }else if(val=="49714981-369a-4158-aff6-e562ee5f98d5"){
					   g3m=keyint;//heavyarmour beam
					  }
					  



					  
					 /*
					  for(var mat in shapedBlocks){
					   var tempindex = shapedBlocks[mat].blockGuid; 
					   var matID = tempindex[val];
						if(matID!==undefined){	
						 shapedBlocks[mat].blockIds[matID] = keyint;
						}
					  }
					  */
					  
					 }
					 
					 localShapedBlocks={};
					 
					 for(var mat in shapedBlocks){
						localShapedBlocks[mat]=new Array(shapedBlocks[mat].blockIds.length);
						for(var key in shapedBlocks[mat].blockGuid){
							localShapedBlocks[mat][shapedBlocks[mat].blockGuid[key]]=GuidToID[key];
						}
					}
									 
					 
					 blockToBeam[a1]=a2;
					 beamToBlock[a2]=a1;
					 if(a2m&&a3m){
						blockToBeam2m[a1]=a2m;
						blockToBeam3m[a1]=a3m;
						beamToBlock2m[a2m]=a1;	
						beamToBlock3m[a3m]=a1;	
					 }
					 blockToBeam[b1]=b2;
					 beamToBlock[b2]=b1;
					 if(b2m&&b3m){
						blockToBeam2m[b1]=b2m;
						blockToBeam3m[b1]=b3m;
						beamToBlock2m[b2m]=b1;	
						beamToBlock3m[b3m]=b1;	
					 } 
					 blockToBeam[c1]=c2;
					 beamToBlock[c2]=c1;
					 if(c2m&&c3m){
						blockToBeam2m[c1]=c2m;
						blockToBeam3m[c1]=c3m;
						beamToBlock2m[c2m]=c1;	
						beamToBlock3m[c3m]=c1;	
					 }  
					 blockToBeam[d1]=d2;
					 beamToBlock[d2]=d1; 
					 if(d2m&&d3m){
						blockToBeam2m[d1]=d2m;
						blockToBeam3m[d1]=d3m;
						beamToBlock2m[d2m]=d1;	
						beamToBlock3m[d3m]=d1;	
					 }   

					 if(e1&&e2){
					  blockToBeam[e1]=e2;
					  beamToBlock[e2]=e1; 
					 }
					 if(f1&&f2){
					  blockToBeam[f1]=f2;
					  beamToBlock[f2]=f1; 
					 }
					 if(g1&&g2){
					  blockToBeam[g1]=g2;
					  beamToBlock[g2]=g1;
						 if(g2m&&g3m){
							blockToBeam2m[g1]=g2m;
							blockToBeam3m[g1]=g3m;
							beamToBlock2m[g2m]=g1;	
							beamToBlock3m[g3m]=g1;	
						 }
					 }
					 
					 slopeBlockToBeam[aa1]=aa2;
					 slopeBlockToBeam[ab1]=ab2;
					 slopeBlockToBeam[ac1]=ac2;
					 slopeBlockToBeam[ad1]=ad2;
					 slopeBlockToBeam[ae1]=ae2;
					 slopeBeamToBlock[aa2]=aa1;
					 slopeBeamToBlockM[aa3]=aa1;
					 slopeBeamToBlock[ab2]=ab1;
					 slopeBeamToBlockM[ab3]=ab1;
					 slopeBeamToBlock[ac2]=ac1;
					 slopeBeamToBlockM[ac3]=ac1;
					 slopeBeamToBlock[ad2]=ad1;
					 slopeBeamToBlockM[ad3]=ad1;
					 slopeBeamToBlock[ae2]=ae1;
					 slopeBeamToBlockM[ae3]=ae1;
					 


						  if(document.getElementById("paintrestrict").checked){
							allowedcolor=document.getElementById("paintallow").value;
						  }else{
							allowedcolor=-1;
						  }
						  if(document.getElementById("replaceold").checked){
						   buildReplaceOldIndex();
						   replaceOld(CurrentBlueprint.Blueprint);
						  }
						  if(document.getElementById("clearhull").checked){
						   buildkeepIndex();
						   clearhull(CurrentBlueprint.Blueprint);
						  }
						  if(document.getElementById("cutinhalf").checked){
						   var xshift=parseInt(document.getElementById("centershift").value);
						   cutInHalf(CurrentBlueprint.Blueprint,xshift);
						  } 
						  if(document.getElementById("cutandmirror").checked){
						   var xshift=parseInt(document.getElementById("cloneshift").value);
						   var even=document.getElementById("evenclone1").checked;
						   cutAndMirror(CurrentBlueprint.Blueprint,xshift,even);
						   removeOverlap(CurrentBlueprint.Blueprint);
						  } 
						  if(document.getElementById("jointmirror").checked){
						   var even=document.getElementById("evenclone2").checked;
						   jointMirror(CurrentBlueprint.Blueprint,even);
						   removeOverlap(CurrentBlueprint.Blueprint);
						  }
						  
						  if(document.getElementById("widen").checked){
							var xdist=parseInt(document.getElementById("widendistance").value);
							var xshift=parseInt(document.getElementById("widenshift").value);
							widenVehicle(CurrentBlueprint.Blueprint,xdist,xshift);
							removeOverlap(CurrentBlueprint.Blueprint);
						  }
						  
						  
						  
						/*  
						  if(document.getElementById("removeoverlap").checked){
						   removeOverlap(CurrentBlueprint.Blueprint);
						  } 
						 */

						  

						  if (!isNumeric(document.getElementById("shieldr").value)){document.getElementById("shieldr").value=1.0;}
						  if (!isNumeric(document.getElementById("shieldg").value)){document.getElementById("shieldg").value=1.0;}
						  if (!isNumeric(document.getElementById("shieldb").value)){document.getElementById("shieldb").value=1.0;}
						  if (!isNumeric(document.getElementById("shielda").value)){document.getElementById("shielda").value=1.0;}
						  document.getElementById("shieldr").value=Math.min(1.0,document.getElementById("shieldr").value);
						  document.getElementById("shieldg").value=Math.min(1.0,document.getElementById("shieldg").value);
						  document.getElementById("shieldb").value=Math.min(1.0,document.getElementById("shieldb").value);
						  document.getElementById("shielda").value=Math.min(10.0,document.getElementById("shielda").value);
						  document.getElementById("shieldr").value=Math.max(0.0,document.getElementById("shieldr").value);
						  document.getElementById("shieldg").value=Math.max(0.0,document.getElementById("shieldg").value);
						  document.getElementById("shieldb").value=Math.max(0.0,document.getElementById("shieldb").value);
						  document.getElementById("shielda").value=Math.max(0.10,document.getElementById("shielda").value);


						  buildconversionIndex();
						  buildblockColorIndex();
						  convertblocks(CurrentBlueprint.Blueprint);  
						  if(document.getElementById("randomcolor").checked){

						   randomcolorblocks(CurrentBlueprint.Blueprint);
						  }
						  else if(document.getElementById("paint").checked){
						   colorblocks(CurrentBlueprint.Blueprint);
						  }
						  
						  if(document.getElementById("becomeStructure").checked){
						   CurrentBlueprint.Blueprint.ItemNumber=GuidToID["cb5bfa64-c3fd-435c-b0da-3891a86b20d2"];
						   becomeStructure(CurrentBlueprint.Blueprint,false);
						  }else if(document.getElementById("becomeVehicle").checked){
						   CurrentBlueprint.Blueprint.ItemNumber=GuidToID["e63040c9-0027-4fd3-be30-67fe3e950140"];
						   becomeVehicle(CurrentBlueprint.Blueprint);
						  }
						  
						  if(document.getElementById("rotateVehicle").checked){
						   rotateBlueprint(CurrentBlueprint.Blueprint,document.getElementById("rotatedir").value);
						  }   
						  
						  if(document.getElementById("mirrorLateral").checked){
						   mirrorVehicle(CurrentBlueprint.Blueprint);
						  }
						  
						  
						  if(document.getElementById("debeamify").checked){
						   
						   debeamifyblocks(CurrentBlueprint.Blueprint);
						   debeamifyslopeblocks(CurrentBlueprint.Blueprint);
						  }
						  /*
						  if(document.getElementById("beamifyOptimized").checked){
						   

						   
						   beamifyslopeblocks(CurrentBlueprint.Blueprint);
						   //var starttime=(new Date()).getTime();  
						  

						   beamifyblocksOptimized(CurrentBlueprint.Blueprint);
						  
						   beamifyblocksOptimized3m(CurrentBlueprint.Blueprint);

						   beamifyblocks2m(CurrentBlueprint.Blueprint);
						   
						   
						   
						   //beamifyblocksOptimized2m(CurrentBlueprint.Blueprint);
						   
						   
						   //var endtime=(new Date()).getTime(); 
						   //alert(endtime-starttime);

						  }else 
						  */
						  if(document.getElementById("beamify2").checked){
						   
						   beamifyslopeblocks(CurrentBlueprint.Blueprint);
						   beamifyblocks(CurrentBlueprint.Blueprint);
						   beamifyblocks3m(CurrentBlueprint.Blueprint);
						   beamifyblocks2m(CurrentBlueprint.Blueprint);
						  }					 
						  updateBlockCount(CurrentBlueprint.Blueprint);

					 return true;
					}
					



					

					if (!processData()){
						console.log("unable to process blueprint: "+CurrentFilename);
					}else{						
						zipfile.file(CurrentFilename, JSON.stringify(CurrentBlueprint));
					}



			}
			catch(err){
				throw err;
				console.log(err);
				loadError(err);

			}			
			
		//console.log(selectedFile.name + " : " + selectedFile.size);
 } 


 try{
 
  
  

			zipfile.generateAsync({type:"blob"})
			.then(function (blobdata) {
				download("Modified_Blueprints.zip",blobdata);
			});
  
  


  
  /*
  

  selectedFileName = "Modified_" + selectedFileName;
  processData();

  var outputcontent=JSON.stringify(CurrentBlueprint);
  download(selectedFileName,outputcontent); 
  //download(selectedFileName,JSON.stringify(RotTable)); 
*/
  
 }catch(err){
   console.log(err);
  loadError(err);
 }
}






function slopeBeamToBlockOrientation(blockrotate, mirrored){
 if(mirrored){
  switch (blockrotate) {
   case 0:
    return 1;
   case 1:
    return 2;
   case 2:
    return 3;
   case 3:
    return 0;
   case 4:
    return 16;
   case 5:
    return 17;
   case 6:
    return 19;
   case 7:
    return 18;
   case 8:
    return 18;
   case 9:
    return 16;
   case 10:
    return 17;   
   case 11:
    return 19;   
   case 12:
    return 7;   
   case 13:
    return 4;   
   case 14:
    return 5;   
   case 15:
    return 6;   
   case 16:
    return 5;   
   case 17:
    return 1;   
   case 18:
    return 3;   
   case 19:
    return 7; 
   case 20:
    return 0;    
   case 21:
    return 4;   
   case 22:
    return 6;   
   case 23:
    return 2;      
   default:
    return -1;
  } 
 }else{
 
  switch (blockrotate) {
   case 0:
    return 3;
   case 1:
    return 0;
   case 2:
    return 1;
   case 3:
    return 2;
   case 4:
    return 18;
   case 5:
    return 16;
   case 6:
    return 17;
   case 7:
    return 19;
   case 8:
    return 16;
   case 9:
    return 17;
   case 10:
    return 19;   
   case 11:
    return 18;   
   case 12:
    return 5;   
   case 13:
    return 6;   
   case 14:
    return 7;   
   case 15:
    return 4;   
   case 16:
    return 1;   
   case 17:
    return 5;   
   case 18:
    return 7;   
   case 19:
    return 3; 
   case 20:
    return 4;    
   case 21:
    return 0;   
   case 22:
    return 2;   
   case 23:
    return 6;      
   default:
    return -1;
  }
 }
 return -1;
}

function slopeBlockToBeamOrientation(beamrotate, negative){
 //negative not implemented
 switch (beamrotate) {
  case 0:
  case 8:
   return 1;
  case 2:
  case 10:
   return 22;
  case 4:
  case 12:
   return 20;
  case 6:
  case 14:
   return 13;
  case 1:
  case 9:
   return 16;
  case 3:   
  case 11:
   return 0;   
  case 5:  
  case 13:
   return 12;   
  case 7:  
  case 15:
   return 18;   
  case 16:  
  case 20:
   return 8;   
  case 17:  
  case 22:
   return 9; 
  case 18:   
  case 21:
   return 11;   
  case 19:   
  case 23:
   return 10;      
  default:
   return -1;
 }
 return -1;
}



function quatMirror(quat){
	var resquat = stoa(quat);
	resquat[0] = -resquat[0];
	resquat[3] = -resquat[3];
	return atos(resquat);
}

function flipX(position){
	var pa=stoar(position);
	pa[0]=(-pa[0]);
	var strposition = ""+pa[0]+","+pa[1]+","+pa[2];
	return strposition;
}

function rotationMirror(blockrotate){
	var q=getQuat(blockrotate);
	if(q){
		q[0]=-q[0];
		q[3]=-q[3];
		return getRot(q);
	}else{
		return -1;
	}
}

//rotate block rotation
function blockRotate(blockrotate,dir){
	var q=getQuat(blockrotate);
	if(q){
		var q1=getQuat(dir); 
		return getRot(quatmul(q1,q));
	}else{
		return -1;
	}
}

//rotate block position
function positionRotate(position,dir){
	pa=stoar(position);
	return atos(posTransform(pa,getQuat(dir)));
}

//rotate block quat
function quatRotate(quat,dir){
	return atos(quatmul(getQuat(dir),stoa(quat)));
}

function sameSlopeBlockOrientation(rotate1,rotate2){
	if(rotate1==rotate2){
		return true;
	}
	var r1=Math.min(rotate1,rotate2);
	var r2=Math.max(rotate1,rotate2); 
	if((r1==0&&r2==8)||(r1==1&&r2==9)||(r1==2&&r2==10)||(r1==3&&r2==11)||(r1==4&&r2==12)||(r1==5&&r2==13)||(r1==6&&r2==14)||(r1==7&&r2==15)||(r1==16&&r2==20)||(r1==17&&r2==22)||(r1==18&&r2==21)||(r1==19&&r2==23)){
		return true;
	}else{
		return false;
	}
}


//download file
//text/plain
//application/json
function download(filename, data) {
    var blob = new Blob([data], {type: 'text/plain'});
    if(window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
    }
    else{
        var elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;        
        document.body.appendChild(elem)
        elem.click();        
        document.body.removeChild(elem);
    }
}






//check for numeric
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

//change colors to hex format
function rgb2hex(red, green, blue) {
	var rgb = blue | (green << 8) | (red << 16);
	return '#' + (0x1000000 + rgb).toString(16).slice(1)
}



function roundToTwo(num) {
    return +(Math.round(num + "e+2")  + "e-2");
}




</script>	
		
	</head>
	<body>
	
	

<div data-role="page">
	
	<div data-role="header">
	<a href="#popupMenu" data-rel="popup" class="ui-btn ui-corner-all ui-shadow ui-btn-inline ui-icon-gear ui-btn-icon-left ui-btn-a">Links</a>
		<h1>Blueprint Bulk Modification Tool</h1>
	</div><!-- /header -->
	<div data-role="content">	
	<div data-role="popup" id="popupMenu">
        <ul id="linklist" data-role="listview" data-inset="true" style="min-width:210px;">
        </ul>
	</div>
	<p>Last updated for FTD <span id="version">v1.95864</span></p>
	<br>
	<p>To start, click on the button below and choose a blueprint file, or multiple files</p>
	<p>When changes are applied the modified blueprints will be downloaded as a zip archive</p>
	<br>	
	<p>This tool has been recently added and might contain a number of bugs</p>
	<p>Please report any issues in the forum thread <a href="http://www.fromthedepthsgame.com/forum/showthread.php?tid=19547">here</a></p>
	<div class="hidden"><input type="file" id="blueprintfile" accept=".blueprint" name="blueprintfiles[]" multiple onchange="openFile();"></div>	
	<div class="ui-grid-solo">
		<div class="ui-block-a"><input class="lb" type="button" btarget="#blueprintfile" value="Open Blueprint(s)" disabled>
		</div>
	</div>	
	<div class="ui-grid-a">
		<div class="ui-block-a">
	<div id="blocktoolpanel" data-role="collapsible">
		<h4>Block Modification Tools</h4>

		
<br>
<div class="ui-grid-a">
<div class="ui-block-a"><label class="checkbox" ><input class="bigbox" id="paintrestrict" type="checkbox" data-role="none">Restrict block modifications to blocks colored: </label></div>
<div class="ui-block-b">
<select id="paintallow" class="palette">
<option id="co00" value="0" selected="selected">00</option>
<option id="co01" value="1">01</option>
<option id="co02" value="2">02</option>
<option id="co03" value="3">03</option>
<option id="co04" value="4">04</option>
<option id="co05" value="5">05</option>
<option id="co06" value="6">06</option>
<option id="co07" value="7">07</option>
<option id="co08" value="8">08</option>
<option id="co09" value="9">09</option>
<option id="co10" value="10">10</option>
<option id="co11" value="11">11</option>
<option id="co12" value="12">12</option>
<option id="co13" value="13">13</option>
<option id="co14" value="14">14</option>
<option id="co15" value="15">15</option>
<option id="co16" value="16">16</option>
<option id="co17" value="17">17</option>
<option id="co18" value="18">18</option>
<option id="co19" value="19">19</option>
<option id="co20" value="20">20</option>
<option id="co21" value="21">21</option>
<option id="co22" value="22">22</option>
<option id="co23" value="23">23</option>
<option id="co24" value="24">24</option>
<option id="co25" value="25">25</option>
<option id="co26" value="26">26</option>
<option id="co27" value="27">27</option>
<option id="co28" value="28">Detail</option>
<option id="co29" value="29">Trim</option>
<option id="co30" value="30">Secondary</option>
<option id="co31" value="31">Main</option>
</select>
</div>
</div>
		<hr>
		
<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="wood" type="checkbox" data-role="none">Convert Wood: 
		<select id="woodto" data-role="none"><option value="wood" selected="selected"> to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>		


<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="metal" type="checkbox" data-role="none">Convert Metal: 
		<select id="metalto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal" selected="selected">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="alloy" type="checkbox" data-role="none">Convert Alloy: 
		<select id="alloyto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" selected="selected">to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="glass" type="checkbox" data-role="none">Convert Glass: 
		<select id="glassto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass" selected="selected">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="heavyarmour" type="checkbox" data-role="none">Convert Heavy Armour: 
		<select id="heavyarmourto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour" selected="selected">to Heavy Armour</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="stone" type="checkbox" data-role="none">Convert Stone: 
		<select id="stoneto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone" selected="selected">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>	
		</label>
	</div>
</div>


<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="lead" type="checkbox" data-role="none">Convert Lead: 
		<select id="leadto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead" selected="selected">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>
<hr>
<div class="ui-grid-a">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="paint" type="checkbox" data-role="none">Paint:
		<select id="painttarget" data-role="none"><option value="all" selected="selected"> all blocks</option> <option value="wood"> Wood </option> <option value="metal"> Metal </option><option value="alloy"> Alloy </option><option value="glass"> Glass </option><option value="heavyarmour"> Heavy Armour </option><option value="stone"> Stone </option><option value="lead"> Lead </option><option value="paintstruct"> All of the above </option><option value="paintothers"> None of the above</option></select>
		</label>
	</div>
	<div class="ui-block-b">
<select id="tocolor" class="palette">
	<option id="pal00" value="0" selected="selected">00</option>
	<option id="pal01" value="1">01</option>
	<option id="pal02" value="2">02</option>
	<option id="pal03" value="3">03</option>
	<option id="pal04" value="4">04</option>
	<option id="pal05" value="5">05</option>
	<option id="pal06" value="6">06</option>
	<option id="pal07" value="7">07</option>
	<option id="pal08" value="8">08</option>
	<option id="pal09" value="9">09</option>
	<option id="pal10" value="10">10</option>
	<option id="pal11" value="11">11</option>
	<option id="pal12" value="12">12</option>
	<option id="pal13" value="13">13</option>
	<option id="pal14" value="14">14</option>
	<option id="pal15" value="15">15</option>
	<option id="pal16" value="16">16</option>
	<option id="pal17" value="17">17</option>
	<option id="pal18" value="18">18</option>
	<option id="pal19" value="19">19</option>
	<option id="pal20" value="20">20</option>
	<option id="pal21" value="21">21</option>
	<option id="pal22" value="22">22</option>
	<option id="pal23" value="23">23</option>
	<option id="pal24" value="24">24</option>
	<option id="pal25" value="25">25</option>
	<option id="pal26" value="26">26</option>
	<option id="pal27" value="27">27</option>
	<option id="pal28" value="28">Detail</option>
	<option id="pal29" value="29">Trim</option>
	<option id="pal30" value="30">Secondary</option>
	<option id="pal31" value="31">Main</option>
	<option id="pal32" value="32">Camo?(1-4)</option>
	<option id="pal33" value="33">Camo?(fleet colors)</option>
 </select>	
	</div>
</div>


<hr>

<div class="ui-grid-a">
<div class="ui-block-a"><label class="checkbox"><input class="bigbox" id="shieldcolor" type="checkbox" data-role="none">Modify all shield color changers </label><div class="subtext"><i>Limits: <br>R, G, B between 0 and 1,<br>Alpha between 0.10 and 10.<br><br>Only affect shields with shield color changers. <br></i></div></div>
<div class="ui-block-b">
<div class="ui-field-contain"><label for="shieldr">R</label><input type="range" name="shieldr" style="background-color:#FF7F7F;" id="shieldr" min="0" max="1" step="0.01" value="1"></div>
<div class="ui-field-contain"><label for="shieldg">G</label><input type="range" name="shieldg" style="background-color:#7FFF7F;" id="shieldg" min="0" max="1" step="0.01" value="1"></div>
<div class="ui-field-contain"><label for="shieldb">B</label><input type="range" name="shieldb" style="background-color:#7F7FFF;" id="shieldb" min="0" max="1" step="0.01" value="1"></div>
<div class="ui-field-contain"><label for="shielda">A</label><input type="range" name="shielda" id="shielda" min="0.1" max="10" step="0.01" value="1"></div>
</div>
</div>


</div>


		

<div id="vehicletoolpanel" data-role="collapsible">
<h4>Vehicle Modification Tools</h4>

<br>

<div class="ui-grid-a">
<div class="ui-block-a">
<label><input id="randomcolor"  type="checkbox" data-mini="true">Randomly paint main vehicle (will overwrite paint settings)</label>
</div>
<div class="ui-block-b">
<label><input id="clearhull" type="checkbox" data-mini="true">Delete all blocks except Wood/Alloy/Metal/Glass/HA/Stone/Lead.</label>
</div>
</div>


<div class="ui-grid-a">
<div class="ui-block-a">
<label><input id="becomeVehicle" type="checkbox" data-mini="true">Turn blueprint into a Vehicle (Invalid blocks will be deleted!)</label>
</div>
<div class="ui-block-b">
<label><input id="becomeStructure" type="checkbox" data-mini="true">Turn blueprint into a Structure (Invalid blocks will be deleted!)</label>
</div>
</div>

<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="replaceold" type="checkbox" data-mini="true">Replace old armor blocks (1m and 2m left,right,and up slopes)</label>
</div>
</div>

<hr>


<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="rotateVehicle" type="checkbox" data-role="none">Rotate vehicle: </label>
</div>
<div class="ui-block-b">
<select id="rotatedir" data-mini="true" >
	<option value="1" selected="selected">Turn Right</option>
	<option value="3" >Turn Left</option>
	<option value="10" >Nose Up</option>
	<option value="4" >Nose Down</option>
	<option value="16" >Roll Right</option>
	<option value="18" >Roll Left</option>	
</select>
</div>
</div>
<hr>



<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="debeamify" type="checkbox" data-mini="true">DeBeamify. Turns Wood/Alloy/Metal/Glass/HA/Stone/Lead beams and diagonal slopes into 1m blocks and slopes.</label>
</div>
</div>
<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="beamify2" type="checkbox" data-mini="true">Beamify. Turns Wood/Alloy/Metal/Glass/HA/Stone/Lead 1m blocks and slopes into beams and diagonal slopes.</label>
</div>
</div>

<!--
<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="beamifyOptimized" type="checkbox" data-mini="true">Beamify using an optimization algorithm. Slower but will fit in more 4m beams. It can take up to a few minutes for large unbeamed vehicles.</label>
</div>
</div-->
<hr>

<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="mirrorLateral" type="checkbox" data-mini="true">Mirror vehicle laterally (flip left and right sides)</label>
</div>
</div>
<hr>



<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="cutinhalf" type="checkbox" data-role="none">Cut the blueprint in half! Only left side remains!</label>
</div>
<div class="ui-block-b" >
<div class="ui-field-contain"><label for="centershift">Cut position</label><input  data-mini="true" type="range" min="-100" max="100" name="centershift" id="centershift"  step="1" value="0"></div>
</div>
</div>
<hr>

<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="jointmirror" type="checkbox" data-role="none">Attach a mirrored copy of the vehicle on the right!</label>
</div>
<div class="ui-block-b">
<label><input  id="evenclone2" type="checkbox" data-mini="true">Even Width?</label>
</div>
</div>
<hr>

<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="cutandmirror" type="checkbox" data-role="none">Replace the right side with a mirrored copy of the left!</label>
</div>
<div class="ui-block-b">
<label><input id="evenclone1" type="checkbox" data-mini="true">Even Width?</label>
<div class="ui-field-contain"><label for="cloneshift">Flip position:</label><input data-mini="true" type="range" min="-100" max="100" name="cloneshift" id="cloneshift"  step="1" value="0"></div>
</div>
</div>

<hr>


<div class="ui-grid-a">
<div class="ui-block-a">
<label  class="checkbox"><input class="bigbox" id="widen" type="checkbox" data-role="none">Widen the vehicle by splitting it apart!</label>
</div>
<div class="ui-block-b">
<div class="ui-field-contain"><label for="widendistance">Distance:</label><input data-mini="true" type="range" min="-100" max="100" name="widendistance" id="widendistance"  step="1" value="1"></div>
<div class="ui-field-contain"><label for="widenshift">Split position:</label><input data-mini="true" type="range" min="-100" max="100" name="widenshift" id="widenshift"  step="1" value="0"></div>
</div>
</div>

<!--<input id="removeoverlap" type="checkbox">Remove Overlapped blocks<br>-->


</div>	

<input type="button" class="dl" value="Apply Modifications & Download zip" onclick="downloadBlueprint();" disabled>	


</div><!--end of left block-->
		
		
		<div class="ui-block-b">
	<div id="blueprintpanel" data-role="collapsible" >
		<h4>Blueprint(s)</h4>
		<table id="table1"  class="table1 tablesorter">
		  <thead>

		  <tr>
			  <th colspan="2">Filename</th>			  
			</tr>
		  </thead>
		  <tbody>

		  </tbody>
		</table>

	</div>
	
		
		</div>
	</div>


	<p></p>
	<p>Copyright &copy; 2016 Zyonix Gaming</p>	
	</div>
</div>


<input type="file" id="files" name="files[]" multiple />
<output id="list"></output>

<script>
  function handleFileSelect(evt) {
    var files = evt.target.files; // FileList object

    // files is a FileList of File objects. List some properties.
    var output = [];
    for (var i = 0, f; f = files[i]; i++) {
      output.push('<li><strong>', escape(f.name), '</strong> (', f.type || 'n/a', ') - ',
                  f.size, ' bytes, last modified: ',
                  f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a',
                  '</li>');
    }
    document.getElementById('list').innerHTML = '<ul>' + output.join('') + '</ul>';
  }

  document.getElementById('files').addEventListener('change', handleFileSelect, false);
</script>

<script>
loadLinks();
$("#version").text(ftdversion);
$(".lb").prop('disabled',false);
$(".lb").parent().removeClass('ui-state-disabled');		

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77242087-2', 'auto');
  ga('send', 'pageview');
</script>
		
	</body>
</html>