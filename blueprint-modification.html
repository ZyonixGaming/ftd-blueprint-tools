<!DOCTYPE html> 
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1"> 
	<title>FTD Blueprint Modification Tool</title>
	<link rel='shortcut icon' href='favicon.ico' type='image/x-icon'/ >
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/css/theme.blue.min.css">


<style>

.biglabel
{
 padding-left:8px;
 color: #000070;
 font-weight: bold;
 font-size: 18pt;
}

.sublabel
{
 padding-left:8px;
}

#input {
    width: 80%;
} 

#blueprintinfo_panel{
 display:none;
}

#modification_panel{
 display:none;
}

label{
 font-size:14pt;
 padding-left:8px;
 font-weight: bold;
 color: #000070;
}

table, th, td {
   border: none;
   padding: 2px 8px 2px 8px;
}
.small {
 width: 35pt;
}

#count_table tr:nth-child(even){background: #E0E0FF}
#count_table tr:nth-child(odd) {background: #F0F0F0}




#filecontent {
 display:none;
}
input[type='file'] {
  color: transparent;
}


.hidden{
	display:none;
}
.ui-header {
background: #D0D0FF !important;
}

.ui-collapsible-content {
    padding: 0px;
}

.tablesorter-blue{
	margin:0 0;
	text-align: center;
}

#HCB_comment_box{
	margin: 0 0;
	padding: 0.8em;
}

tbody tr:nth-child(even) td:nth-child(odd){background: #E0E0F0}
tbody tr:nth-child(odd) td:nth-child(even){background: #FFFFFF}
tbody tr:nth-child(even) td:nth-child(even){background: #F0F0FF}
tbody tr:nth-child(odd) td:nth-child(odd){background: #F0F0F0}


</style>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/js/jquery.tablesorter.min.js"></script>
	<script src="itemtable.js"></script>
	<script src="links.js"></script>
	
</head>
<body>

<div data-role="page">
	
	<div data-role="header">
	<a href="#popupMenu" data-rel="popup" class="ui-btn ui-corner-all ui-shadow ui-btn-inline ui-icon-gear ui-btn-icon-left ui-btn-a">Links</a>
		<h1>Blueprint Modification</h1>
	</div><!-- /header -->
	<div data-role="content">	
	<div data-role="popup" id="popupMenu">
        <ul id="linklist" data-role="listview" data-inset="true" style="min-width:210px;">
        </ul>
	</div>
	<p>Last updated for FTD v1.9514 and v1.1952</p>
	<p>To start, click on the button below and choose a blueprint file.</p>



<br>
<input type="file" id="blueprintfile" accept=".blueprint" onchange="openFile();">
<br><br>
<div id="blueprintinfo_panel"><a name="vi"></a>
 <hr> 
 <span id="label_filename" class="biglabel"></span>
 <hr>
 <a href="#top"> top </a> | <a href="#vi"> info </a> | <a href="#bm"> block tools </a> | <a href="#vm"> vehicle tools </a> | <a href="#dl"> download </a><br>
 <br> 
 <label>Block Count:</label>
 <br>
 <span id="blockcount"></span>
  <br>
 <label>Statistics:</label>
 <br> 
 <span id="stats1"></span>
 <i>*These numbers are based on saved values in the blueprint, and might not be accurate especially after block modification.</i><br><br>
</div>
<div id="modification_panel">
<hr>
<span class="biglabel"><a name="bm"></a>Block Modifications</span><br>
<span class="sublabel">Make changes to specific blocks. You can restrict the changes to blocks painted a certain color </span><br><hr>
<a href="#top"> top </a> | <a href="#vi"> info </a> | <a href="#bm"> block tools </a> | <a href="#vm"> vehicle tools </a> | <a href="#dl"> download </a><br>
<br>

<label><input id="wood" type="checkbox" class="convert" openx="#cwood">Convert Wood: </label>
<div id="cwood" data-role="collapsible"><select id="woodto"><option value="wood" selected="selected"> to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select></div>
<label><input id="alloy" type="checkbox" class="convert" openx="#calloy">Convert Alloy: </label>
<div id="calloy" data-role="collapsible"><select id="alloyto"><option value="wood" > to Wood</option><option value="alloy" selected="selected">to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select></div>
<label><input id="metal" type="checkbox" class="convert" openx="#cmetal">Convert Metal: </label>
<div id="cmetal" data-role="collapsible"><select id="metalto"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal" selected="selected">to Metal</option> <option value="glass">to Glass</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select></div>
<label><input id="glass" type="checkbox" class="convert" openx="#cglass">Convert Glass: </label>
<div id="cglass" data-role="collapsible"><select id="glassto"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass" selected="selected">to Glass</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select></div>
<label><input id="stone" type="checkbox" class="convert" openx="#cstone">Convert Stone: </label>
<div id="cstone" data-role="collapsible"><select id="stoneto"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option>  <option value="stone" selected="selected">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select></div>
<label><input id="lead" type="checkbox" class="convert" openx="#clead">Convert Lead: </label>
<div id="clead" data-role="collapsible"><select id="leadto"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="stone">to Stone</option> <option value="lead" selected="selected">to Lead</option><option value="0" >delete!</option></select></div>
<br>
<input id="shieldcolor" type="checkbox">*Modify all shield color changers - R:<input class ="small" type="number" min="0" max="1.0" size="1" width="30" step="0.01" value="1.0" id="shieldr"> G:<input class ="small" type="number" min="0" max="1.0" size="1" width="30" step="0.01" value="1.0" id="shieldg"> B:<input class ="small" type="number" min="0" max="1.0" size="1" width="30" step="0.01" value="1.0" id="shieldb"> Alpha:<input class ="small" type="number" min="0" max="10.0" size="1" width="30" step="0.01" value="1.0" id="shielda"><br>
<i>* Only affect shields with shield color changers. Limits: R, G, B between 0 and 1, Alpha between 0.10 and 10.</i><br>
<br>
<input id="paint" type="checkbox">Paint main vehicle <select id="painttarget"><option value="all" selected="selected"> all blocks</option> <option value="wood"> Wood </option> <option value="metal"> Metal </option><option value="alloy"> Alloy </option><option value="glass"> Glass </option><option value="stone"> Stone </option><option value="lead"> Lead </option><option value="paintstruct"> Wood/Metal/Alloy/Glass/Stone/Lead </option><option value="paintothers"> Not Wood/Metal/Alloy/Glass/Stone/Lead </option></select>
 to
 <select id="tocolor">
	<option id="pal00" value="0" selected="selected">00</option>
	<option id="pal01" value="1">01</option>
	<option id="pal02" value="2">02</option>
	<option id="pal03" value="3">03</option>
	<option id="pal04" value="4">04</option>
	<option id="pal05" value="5">05</option>
	<option id="pal06" value="6">06</option>
	<option id="pal07" value="7">07</option>
	<option id="pal08" value="8">08</option>
	<option id="pal09" value="9">09</option>
	<option id="pal10" value="10">10</option>
	<option id="pal11" value="11">11</option>
	<option id="pal12" value="12">12</option>
	<option id="pal13" value="13">13</option>
	<option id="pal14" value="14">14</option>
	<option id="pal15" value="15">15</option>
	<option id="pal16" value="16">16</option>
	<option id="pal17" value="17">17</option>
	<option id="pal18" value="18">18</option>
	<option id="pal19" value="19">19</option>
	<option id="pal20" value="20">20</option>
	<option id="pal21" value="21">21</option>
	<option id="pal22" value="22">22</option>
	<option id="pal23" value="23">23</option>
	<option id="pal24" value="24">24</option>
	<option id="pal25" value="25">25</option>
	<option id="pal26" value="26">26</option>
	<option id="pal27" value="27">27</option>
	<option id="pal28" value="28">Detail</option>
	<option id="pal29" value="29">Trim</option>
	<option id="pal30" value="30">Secondary</option>
	<option id="pal31" value="31">Main</option>
 </select><br>
<br>
<input id="paintrestrict" type="checkbox">Restrict block modifications to blocks colored: <select id="paintallow">
<option id="co00" value="0" selected="selected">00</option>
<option id="co01" value="1">01</option>
<option id="co02" value="2">02</option>
<option id="co03" value="3">03</option>
<option id="co04" value="4">04</option>
<option id="co05" value="5">05</option>
<option id="co06" value="6">06</option>
<option id="co07" value="7">07</option>
<option id="co08" value="8">08</option>
<option id="co09" value="9">09</option>
<option id="co10" value="10">10</option>
<option id="co11" value="11">11</option>
<option id="co12" value="12">12</option>
<option id="co13" value="13">13</option>
<option id="co14" value="14">14</option>
<option id="co15" value="15">15</option>
<option id="co16" value="16">16</option>
<option id="co17" value="17">17</option>
<option id="co18" value="18">18</option>
<option id="co19" value="19">19</option>
<option id="co20" value="20">20</option>
<option id="co21" value="21">21</option>
<option id="co22" value="22">22</option>
<option id="co23" value="23">23</option>
<option id="co24" value="24">24</option>
<option id="co25" value="25">25</option>
<option id="co26" value="26">26</option>
<option id="co27" value="27">27</option>
<option id="co28" value="28">Detail</option>
<option id="co29" value="29">Trim</option>
<option id="co30" value="30">Secondary</option>
<option id="co31" value="31">Main</option>
</select><br>
<br>
<hr>
<span class="biglabel"><a name="vm"></a>Vehicle Modification Tools</span><br>
<span class="sublabel">Changes are applied to the whole vehicle.</span><br><hr>
<a href="#top"> top </a> | <a href="#vi"> info </a> | <a href="#bm"> block tools </a> | <a href="#vm"> vehicle tools </a> | <a href="#dl"> download </a><br>
<br>

<input id="highlightAI" type="checkbox">Highlight AI, ACB, PID blocks on main vehicle (will overwrite paint settings)<br>
<input id="randomcolor"  type="checkbox">Randomize colors on main vehicle (will overwrite paint settings)<br>
<br>
<input id="clearhull" type="checkbox">Delete all blocks except Wood/Alloy/Metal/Glass/Stone/Lead.<br>
<input id="cutinhalf" type="checkbox">Cut the blueprint in half! Only left side remains! &nbsp; Split position: <input class ="small" type="number" size="1" width="20" step="1" value="0" id="centershift"><br>
<input id="cutandmirror" type="checkbox">Replace the right side with a mirrored copy of the left! &nbsp; Split position: <input class ="small" type="number" size="1" width="20" step="1" value="0" id="cloneshift"> &nbsp; Even width? <input id="evenclone1" type="checkbox"><br>
<input id="jointmirror" type="checkbox">Attach a mirrored copy of the vehicle on the right! &nbsp; Even width? <input id="evenclone2" type="checkbox"><br>
<input id="widen" type="checkbox">Split the vehicle apart! &nbsp; Distance: <input class ="small" type="number" size="1" width="20" step="1" value="1" id="widendistance"> &nbsp; Split position: <input class ="small" type="number" size="1" width="20" step="1" value="0" id="widenshift"><br>
<!--<input id="removeoverlap" type="checkbox">Remove Overlapped blocks<br>-->
<input id="replaceold" type="checkbox">Replace old armor blocks! (e.g. 1m and 2m left,right,and up slopes)<br>
<br>
<input id="becomeVehicle" type="checkbox">Turn blueprint into a vehicle (Invalid blocks on a vehicle will be deleted!)<br>
<input id="becomeStructure" type="checkbox">Turn blueprint into a Structure (Invalid blocks on a structure will be deleted!)<br>
<br>
<input id="rotateVehicle" type="checkbox">Rotate vehicle: <select id="rotatedir">
	<option value="1" selected="selected">Turn Right</option>
	<option value="3" >Turn Left</option>
	<option value="10" >Nose Up</option>
	<option value="4" >Nose Down</option>
	<option value="16" >Roll Right</option>
	<option value="18" >Roll Left</option>	
</select><br>
<input id="mirrorLateral" type="checkbox">Mirror vehicle laterally (flip left and right sides)<br>
<br>
<input id="debeamify" type="checkbox">DeBeamify. Turns Wood/Alloy/Metal/Glass/Stone/Lead 4m beams and diagonal slopes into 1m blocks and slopes.<br>
<input id="beamify2" type="checkbox">Beamify. Turns Wood/Alloy/Metal/Glass/Stone/Lead 1m blocks and slopes into 4m beams and diagonal slopes.<br>
<input id="beamifyOptimized" type="checkbox">Beamify using an optimization algorithm. Slower but will fit in more beams. It can take up to a few minutes for large unbeamed vehicles.

<br>
<br>
<a name="dl"></a><input type="button" value="Apply Modifications & Download" onclick="downloadBlueprint();"><br>
<div id="filecontent">
<a href="#filetext" onClick="togglefiletext();"><i>Blueprint not downloading?</i></a>
<div id="filetext" name="filetext">
<br>
Copy and paste the following into a new .blueprint file!<br>
<textarea id="filetextbox" wrap="hard" cols="45" rows="30" readonly></textarea>
</div>
</div>
<br>
</div>
<div id="debug"></div>
<br><br>
	</div><!-- content -->
</div><!-- page -->
<script>

$(document).ready(function(){
	    $('.convert').click(function() {
			if(($(this).is(':checked'))){			
				$($(this).attr("openx")).collapsible("expand");
			}else{
				$($(this).attr("openx")).collapsible("collapse");
			}
        
    });
});


//main lookup table for block data

var QuatTable = {0:"0,0,0,1",1:"0,0.707106781186547,0,0.707106781186547",2:"0,1,0,0",3:"0,0.707106781186547,0,-0.707106781186547",4:"0.707106781186547,0,0,0.707106781186547",5:"0.5,0.5,-0.5,0.5",6:"0,-0.707106781186547,0.707106781186547,0",7:"-0.5,0.5,-0.5,-0.5",8:"0,-0.707106781186547,-0.707106781186547,0",9:"0.5,0.5,0.5,-0.5",10:"-0.707106781186547,0,0,0.707106781186547",11:"-0.5,0.5,0.5,0.5",12:"0,0,-1,0",13:"-0.707106781186547,0,-0.707106781186547,0",14:"1,0,0,0",15:"0.707106781186547,0,-0.707106781186547,0",16:"0,0,-0.707106781186547,0.707106781186547",17:"0.707106781186547,0.707106781186547,0,0",18:"0,0,0.707106781186547,0.707106781186547",19:"-0.707106781186547,0.707106781186547,0,0",20:"0.5,0.5,0.5,0.5",21:"0.5,-0.5,-0.5,0.5",22:"-0.5,0.5,-0.5,0.5",23:"-0.5,-0.5,0.5,0.5",}
var RotTable = {"0,0,0,1":0,"0,1,0,1":1,"0,1,0,0":2,"0,1,0,-1":3,"1,0,0,1":4,"1,1,-1,1":5,"0,1,-1,0":6,"1,-1,1,1":7,"0,1,1,0":8,"1,1,1,-1":9,"1,0,0,-1":10,"1,-1,-1,-1":11,"0,0,1,0":12,"1,0,1,0":13,"1,0,0,0":14,"1,0,-1,0":15,"0,0,1,-1":16,"1,1,0,0":17,"0,0,1,1":18,"1,-1,0,0":19,"1,1,1,1":20,"1,-1,-1,1":21,"1,-1,1,-1":22,"1,1,-1,-1":23}

var BeamAxisRot = [1,8,0];
var BeamAxisPriority = [3,2,1];

//stores information for switching blocks from one material to another
var shapedBlocks = {"wood":{"blockIds":[357,365,448,447,366,367,428,424,426,427,443,425,444,418,419,416,417,422,423,445,420,421,446],"blockGuid":{"9a0ae372-beb4-4009-b14e-36ed0715af73":0,"05475442-0e52-4e0b-9fbb-2715f0e54f97":1,"d077c2a4-4578-4965-9318-c14bb7ac1bd6":2,"2ee817c1-f2a3-407a-847d-b97ffb844e45":3,"bdafa446-f615-49cb-94f3-d7652dde6cec":4,"b88679fb-0325-4c85-942f-ad9c6ed6545b":5,"3296c67d-6ace-44dd-8e86-335b9a90ad80":6,"c545a97c-6ac6-4181-a704-28031244aeb1":7,"17575457-18fa-43e0-a8cb-1331efc1c77e":8,"90ca403c-ddb5-4a55-ac6f-2ca2c970d6ad":9,"ba05b02a-f2b2-4c5e-ba73-00a519535763":10,"6cc4ec54-404c-4989-9f85-9b59824faf96":11,"fe628646-64da-462c-ac5c-1d4f976a129a":12,"9c0d97cf-0c99-4565-a931-b1c5bdf8fc1b":13,"c7b07df3-6afe-4616-9dd4-64f7687e98e9":14,"f878fa09-cb47-4e1c-8f1e-df2544a6882a":15,"12bfb5a0-772e-4d14-bb1a-00077211f70b":16,"1ae7e9fe-c0c4-4bb4-a0d6-28e21789a66c":17,"dee106ea-3e91-4b03-92ef-33038c5681a0":18,"ae98ddb2-901d-402b-8ab0-149b778acdb8":19,"6448ddc8-a3df-465f-b819-52f1cf347983":20,"92159a6b-a1b6-4f8b-9c08-503f2cbbd572":21,"e2ea58d4-ee32-432b-8086-29bf5675e5f7":22}},"metal":{"blockIds":[359,383,432,431,384,385,430,412,414,415,433,413,434,406,407,404,405,410,411,435,408,409,436],"blockGuid":{"ab699540-efc8-4592-bc97-204f6a874b3a":0,"a7f5d8de-4882-4111-9d01-436493e5b2d8":1,"e5d065f6-907b-450d-b998-213cdc54eec1":2,"0d554a9d-7d06-48b3-8aea-ffaeaa30380a":3,"5548037e-8428-43f8-bcb6-d730dbcd0a79":4,"8477bbec-974c-45bf-a1ce-49a48d5b5307":5,"db9ed060-d556-435b-945c-19c923e233d3":6,"de50f4f6-3d7e-4d6b-ae34-e6a34b24b104":7,"442f3ea3-c7cd-4759-84ee-a0d2fac5a711":8,"b9d21957-633f-4926-9562-4cfab38badee":9,"ac09f902-8921-4a58-aad5-c679706697f6":10,"2ddec223-13c2-4bf9-ba05-66338c51bd45":11,"5f07c608-acf2-4cc5-97d0-1a0a96acb9e3":12,"2f5f91c0-bebf-4de2-bf70-8d9bc1816997":13,"f6f120ee-fbc3-49f8-a2a3-a49e8674b8c8":14,"6f820954-63e4-4bc9-a299-8266e712d838":15,"686e9438-d86e-4504-b9f6-7029b264924e":16,"bcaf33a4-98c3-41d7-b416-438670e97d53":17,"40659614-1b34-497a-b745-78497e4b2025":18,"52a61c5e-07be-4bb9-9649-d3375c66e97e":19,"ee18a848-1319-4ff9-b5e5-3f3710635dbf":20,"369eefd9-0c39-412e-a294-d0bb2251c509":21,"d48733e2-f003-4643-86a2-cb350fd0dc04":22}},"alloy":{"blockIds":[360,374,438,437,375,376,429,400,402,403,439,401,440,394,395,392,393,398,399,441,396,397,442],"blockGuid":{"3cc75979-18ac-46c4-9a5b-25b327d99410":0,"9411e401-27da-4546-b805-3334f200f055":1,"b5d46bb7-d49e-42f6-817b-323fbf6d62b0":2,"9af822b3-80d9-46bd-9ce0-e6e5c2e61da4":3,"911fe222-f9b2-4892-9cd6-8b154d55b2aa":4,"c6176cb5-0a32-4d68-a749-8ee33b2230c1":5,"2a3905ff-2030-421d-a2bf-90fba71c1c5e":6,"62f61c31-a453-44ce-87a2-b5ce142fb052":7,"95a626e6-f1b8-491a-aa31-8de5a2beb513":8,"51b37dbf-2beb-425b-a817-89434838c857":9,"ba5c8d03-9093-47a9-a8cd-b721ceeee1dd":10,"967f98c3-d708-4602-9c71-0f34562cdfca":11,"afb33fc2-3071-408a-b312-da22478c0a14":12,"f2df1943-1ebf-47c6-9b81-ad613b7c5d5b":13,"272f0dea-8aac-4ca9-98e6-79897e7df0f9":14,"902446c4-ff32-4118-83ac-1f4bf89c56d1":15,"29c40e04-59fb-45dc-a80b-31ee1c4f82ac":16,"a4b0d100-c480-4697-b606-489d80a6d376":17,"90c9965a-1dcc-4786-a2d2-6299fed7260f":18,"a6cfd078-bc39-4ad8-a47f-49097913a27b":19,"ad3e7665-cf63-4135-835f-2f743c69bb36":20,"27692d7a-c05f-4ac4-ac98-f25e359faebc":21,"2b1b3011-0b81-472e-aa42-26383f453268":22}},"glass":{"blockIds":[451,473,456,455,452,453,454,462,461,467,471,468,472,459,465,460,466,457,463,469,458,464,470],"blockGuid":{"2d519ca8-1f12-4a8e-9340-aa6648b5e799":0,"395179c1-37a0-4250-851b-5bc19fd601b6":1,"0c64d302-c6df-42eb-a0ff-7c90f867ba4b":2,"35abb89b-33b8-4cb4-b3d0-ee132247de8d":3,"174b5b41-b70e-485d-b00a-a61cc9826b2c":4,"69feebc3-e241-4dff-a000-736def80c851":5,"c4ef6072-822a-4fa5-b618-e7fc0508c499":6,"729b7ea3-59d5-4182-9177-684da6fbe0a9":7,"e42929f1-ccd0-4fff-8413-6cb94cf08405":8,"bb0337d9-69f7-48f1-9c12-2de83ceff42d":9,"04993e98-6b77-46d3-ad80-5278550e9b65":10,"5e73653e-519c-4f13-9f69-1d80c19151d8":11,"7434948c-1b56-4dd0-bb0c-a3d291653f09":12,"d3a729d9-c25f-419c-ba7e-63cd2cac1a4d":13,"09957acb-9916-41ea-8799-66b0359ccb31":14,"87103032-b0e5-47c4-a632-ba33da2cbe1b":15,"585d7b93-955d-4099-b9f5-2ea41797f419":16,"0375d846-a203-4813-a330-0d8fd1e6586e":17,"3f349a8a-e5a1-4f43-9cc4-cea2f0f5b623":18,"48360916-a894-4bd8-b8b5-4595bb7ccf2e":19,"787524d3-1b60-44d8-bef2-d42156c55446":20,"d9952f54-1e40-4e5e-87af-b1011ca18b83":21,"37999ce4-4189-4d46-bd77-4b7b5ec4be62":22}},"stone":{"blockIds":[358,450],"blockGuid":{"710ee212-563b-42f8-acd1-57515479524d":0,"c7a19161-b361-4074-8c51-2398a0a70d1b":1}},"lead":{"blockIds":[362,449],"blockGuid":{"e71e6f97-fbe8-4bf5-9645-d15179ba0c17":0,"f5d2db25-114e-473a-8313-96831ccd011e":1}}}

//to replace old blocks
var oldBlocks = {"23a5c7f7-43bd-4329-8411-f5ab019125e7":{"Guid":"911fe222-f9b2-4892-9cd6-8b154d55b2aa","Rot":12},"35300339-2491-495c-a178-42c1121915bc":{"Guid":"c6176cb5-0a32-4d68-a749-8ee33b2230c1","Rot":12},"d2f5d5f0-9e7d-4c22-839f-0d9c04c34736":{"Guid":"5548037e-8428-43f8-bcb6-d730dbcd0a79","Rot":12},"71902772-b8a8-4663-a309-f9abb46ef0c7":{"Guid":"8477bbec-974c-45bf-a1ce-49a48d5b5307","Rot":12},"00d4381b-501d-4d6a-be06-fc89e0c6c6b8":{"Guid":"bdafa446-f615-49cb-94f3-d7652dde6cec","Rot":12},"70be6ef4-15b0-4dbb-bf7b-1f536c554659":{"Guid":"b88679fb-0325-4c85-942f-ad9c6ed6545b","Rot":12},"c28f4f27-55f0-4dcb-8fa0-125e560f09e0":{"Guid":"911fe222-f9b2-4892-9cd6-8b154d55b2aa","Rot":18},"fb83e6db-7c65-4bef-be39-f4762d7d2d66":{"Guid":"c6176cb5-0a32-4d68-a749-8ee33b2230c1","Rot":18},"7639e07d-9913-4b4a-ba6b-0804ee956d7a":{"Guid":"5548037e-8428-43f8-bcb6-d730dbcd0a79","Rot":18},"764b7977-dbe5-4ee7-929d-c6ad8b944b15":{"Guid":"8477bbec-974c-45bf-a1ce-49a48d5b5307","Rot":18},"ea8f9703-91bf-4406-8563-75215816556c":{"Guid":"bdafa446-f615-49cb-94f3-d7652dde6cec","Rot":18},"2ad766bd-3d33-471b-be53-5d6708553a46":{"Guid":"b88679fb-0325-4c85-942f-ad9c6ed6545b","Rot":18},"a1048d4d-3037-4970-84ba-9b5517ae4b4b":{"Guid":"911fe222-f9b2-4892-9cd6-8b154d55b2aa","Rot":16},"e71e02e9-5680-47bd-a5d9-053918b9a6db":{"Guid":"c6176cb5-0a32-4d68-a749-8ee33b2230c1","Rot":16},"fe51f44a-f400-41f3-8c05-b45aadbcc797":{"Guid":"5548037e-8428-43f8-bcb6-d730dbcd0a79","Rot":16},"82a57761-2027-4f63-b27b-ffd2b1eed419":{"Guid":"8477bbec-974c-45bf-a1ce-49a48d5b5307","Rot":16},"b00e9689-722d-4995-902b-0ef1b1f05780":{"Guid":"bdafa446-f615-49cb-94f3-d7652dde6cec","Rot":16},"c2da1fed-694a-4d3f-b565-953d1e36aa91":{"Guid":"b88679fb-0325-4c85-942f-ad9c6ed6545b","Rot":16}}

//maps block ID of block to beam
var blockToBeam = {}

//maps block ID of beam to block
var beamToBlock = {}

var slopeBlockToBeam = {}
var slopeBeamToBlock = {}
var slopeBeamToBlockM = {}

//maintains a list of blockID:newBlockID to facilitate switching blocks via convertblocks() function
var conversionIndex = {}

var replaceOldIndex = {}

//maintains a list of blockID to keep via clearhull() function
var keepIndex = {}

//maintains a list of blockID to determine color changes via colorblocks() function
var blockColorIndex = {}

//blockID:blockname
var nameID = {}

//blockID:blockcount
var countID = {}

//blockname:blockcount
var blockCountData = {}

//store stats
var totalstats = {}

var selectedFile
var selectedFileName
var ItemDic
var CurrentBlueprint

var selectedcolor

var allowedcolor = -1;

var blocksBeamed = 0;

var blocksDebeamed = 0;

//rotation*vector*rotation_conjugate
//alert(JSON.stringify(RotTable));
//alert(atos(posTransform([1,2,3],[0.5,0.5,-0.5,0.5])));
//inverse x and inverse w to flip along yz plane

//run once to populate RotTable from QuatTable - not needed with static table
function initRotTable(){
	for(rot in QuatTable){
		var quat=getquatformatted(getQuat(rot));
		var quatstr=atos(quat);
		RotTable[quatstr]=rot;
	}
}//not needed now with static table



//pos as [x,y,z] quat as[x,y,z,w]
// transforms co-ordinate pos by the quaternion quat
function posTransform(pos,quat){
	var p = [pos[0],pos[1],pos[2],0];
	var transpos = quatmul(quat,quatmul(p,quatconj(quat)));
	return [Math.round(transpos[0]),Math.round(transpos[1]),Math.round(transpos[2])]
}

//combining 2 quat transforms e.g. q1 then q2 = applying q2*q1 or quatmul(q2,q1);


function atos(a){
	var s="";
	if(a){
		s=""+a[0];
	}
	for (var i=1;i<a.length;i++){
		s=s + "," + a[i];
	}
	return s;
}

function stoa(s){
	var temp=s.split(",");
	return [parseFloat(temp[0]),parseFloat(temp[1]),parseFloat(temp[2]),parseFloat(temp[3])];
}

function stoar(s){
	var temp=s.split(",");
	return [Math.round(parseFloat(temp[0])),Math.round(parseFloat(temp[1])),Math.round(parseFloat(temp[2]))];
}

function getQuat(rotation){
	return JSON.parse("[" + QuatTable[rotation] + "]");
}

function getRot(quat){
	var quatstr=atos(getquatformatted(quat));
	return RotTable[quatstr];
}

//quat as array
function getquatformatted(quat){
	var q=[quat[0],quat[1],quat[2],quat[3]];
	var r = Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]);
	q[0]=Math.round(q[0]*r);
	q[1]=Math.round(q[1]*r);
	q[2]=Math.round(q[2]*r);
	q[3]=Math.round(q[3]*r);
	for(var i=0;i<4;i++){
		if(q[i]>0){
			break;
		}else if(q[i]<0){
			q=quatneg(q);
			break;
		}
	}
	return q;
}

//quat as array
function getquatnormalized(quat){
	var q=[quat[0],quat[1],quat[2],quat[3]];
	var r = Math.sqrt(Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]));
	q[0]=q[0]/r;
	q[1]=q[1]/r;
	q[2]=q[2]/r;
	q[3]=q[3]/r;
	return q;
}

//quat in x, y, z, w
function quatneg(q){
 return[-q[0],-q[1],-q[2],-q[3]];
}
//quat in x, y, z, w
function quatconj(q){
 return[-q[0],-q[1],-q[2],q[3]];
}

//quat in x, y, z, w
function quatmul(q,r){
 return [q[3] * r[0] + q[0] * r[3] + q[1] * r[2] - q[2] * r[1],
     q[3] * r[1] - q[0] * r[2] + q[1] * r[3] + q[2] * r[0],
     q[3] * r[2] + q[0] * r[1] - q[1] * r[0] + q[2] * r[3],
     q[3] * r[3] - q[0] * r[0] - q[1] * r[1] - q[2] * r[2]];
}


function loadError(message){
 if(message){	
  throw message;
  alert(message);
 }else{
  alert("failure");
 } 
}

//opens file and parse file to CurrentBlueprint object
function openFile() {
 var selectedFile = document.getElementById('blueprintfile').files[0];
 if (selectedFile){
  var reader = new FileReader();
  reader.onload = function(evt) {
   try{    
    document.getElementById('blueprintinfo_panel').style.display="none";
    document.getElementById('modification_panel').style.display="none";
    document.getElementById("filecontent").style.display="none";

    document.getElementById('label_filename').innerHTML = "";
    document.getElementById('blockcount').innerHTML = "";    
    if(evt){
     CurrentBlueprint = JSON.parse(evt.target.result);    
     selectedFileName = selectedFile.name;
     if (!processData()){
      throw "unable to process blueprint"
     }
     
    }else{
     throw "unable to load blueprint"
    }
   }
   catch(err){
    loadError(err);
    } 
  };
  reader.readAsText(selectedFile);
 }else{
  //no file selected;
 }
 document.getElementById('blueprintfile').value="";
}


//reads and display CurrentBlueprint object
function processData(){
 document.getElementById('label_filename').innerHTML = selectedFileName;
    nameID = {}
    countID = {}
 blockCountData = {}
 document.getElementById('blockcount').innerHTML = "";
 document.getElementById('stats1').innerHTML = ""; 
 ItemDic =  CurrentBlueprint.ItemDictionary;
 
 
 var a1;
 var a2;
 var b1;
 var b2;
 var c1;
 var c2;
 var d1;
 var d2;
 var e1;
 var e2;
 var f1;
 var f2;
 
 //for sloped blocks
 var aa1=-1;
 var aa2=-1;
 var aa3=-1;
 var ab1=-1;
 var ab2=-1;
 var ab3=-1;
 var ac1=-1;
 var ac2=-1;
 var ac3=-1;
 var ad1=-1;
 var ad2=-1;
 var ad3=-1;
 
 
 blockToBeam={};
 beamToBlock={};
 
 slopeBlockToBeam={};
 slopeBeamToBlock={};
 slopeBeamToBlockM={};
  
 
 for(var key in ItemDic) {
  var keyint = parseInt(key);
  val = ItemDic[keyint];
  if(ItemTable[val]){
   nameID[keyint]=(ItemTable[val]).Name;
   ItemTable[val].BlockId=keyint;
  }else{
   nameID[keyint]="unnamed";
  }
  countID[keyint]=0;
  if (val=="9a0ae372-beb4-4009-b14e-36ed0715af73"){
   a1=keyint;//woodblock
  }else if(val=="05475442-0e52-4e0b-9fbb-2715f0e54f97"){
   a2=keyint;//woodbeam
  }else if(val=="ab699540-efc8-4592-bc97-204f6a874b3a"){
   b1=keyint;//metalblock
  }else if(val=="a7f5d8de-4882-4111-9d01-436493e5b2d8"){
   b2=keyint;//metalbeam
  }else if(val=="3cc75979-18ac-46c4-9a5b-25b327d99410"){
   c1=keyint;//alloyblock
  }else if(val=="9411e401-27da-4546-b805-3334f200f055"){
   c2=keyint;//alloybeam
  }else if(val=="2d519ca8-1f12-4a8e-9340-aa6648b5e799"){
   d1=keyint;//glassblock
  }else if(val=="395179c1-37a0-4250-851b-5bc19fd601b6"){
   d2=keyint;//glassbeam
  }else if(val=="e71e6f97-fbe8-4bf5-9645-d15179ba0c17"){
   e1=keyint;//leadblock
  }else if(val=="f5d2db25-114e-473a-8313-96831ccd011e"){
   e2=keyint;//leadbeam
  }else if(val=="710ee212-563b-42f8-acd1-57515479524d"){
   f1=keyint;//stoneblock
  }else if(val=="c7a19161-b361-4074-8c51-2398a0a70d1b"){
   f2=keyint;//stonebeam
  }else if(val=="bdafa446-f615-49cb-94f3-d7652dde6cec"){
   aa1=keyint;//wood
  }else if(val=="2ee817c1-f2a3-407a-847d-b97ffb844e45"){
   aa2=keyint;//wood
  }else if(val=="d077c2a4-4578-4965-9318-c14bb7ac1bd6"){
   aa3=keyint;//wood
  }else if(val== "5548037e-8428-43f8-bcb6-d730dbcd0a79"){
   ab1=keyint;//metal
  }else if(val== "0d554a9d-7d06-48b3-8aea-ffaeaa30380a"){
   ab2=keyint;//metal
  }else if(val== "e5d065f6-907b-450d-b998-213cdc54eec1"){
   ab3=keyint;//metal
  }else if(val=="911fe222-f9b2-4892-9cd6-8b154d55b2aa"){
   ac1=keyint;//alloy
  }else if(val=="9af822b3-80d9-46bd-9ce0-e6e5c2e61da4"){
   ac2=keyint;//alloy
  }else if(val=="b5d46bb7-d49e-42f6-817b-323fbf6d62b0"){
   ac3=keyint;//alloy
  }else if(val=="174b5b41-b70e-485d-b00a-a61cc9826b2c"){
   ad1=keyint;//glass
  }else if(val=="35abb89b-33b8-4cb4-b3d0-ee132247de8d"){
   ad2=keyint;//glass
  }else if(val=="0c64d302-c6df-42eb-a0ff-7c90f867ba4b"){
   ad3=keyint;//glass
  }

  
 
  for(var mat in shapedBlocks){
   var tempindex = shapedBlocks[mat].blockGuid; 
   var matID = tempindex[val];
    if(matID!==undefined){     
     shapedBlocks[mat].blockIds[matID] = keyint;
    }
  }
 }
 
 blockToBeam[a1]=a2;
 blockToBeam[b1]=b2;
 blockToBeam[c1]=c2;
 blockToBeam[d1]=d2;
 beamToBlock[a2]=a1;
 beamToBlock[b2]=b1;
 beamToBlock[c2]=c1;
 beamToBlock[d2]=d1; 
 if(e1&&e2){
  blockToBeam[e1]=e2;
  beamToBlock[e2]=e1; 

 }
 if(f1&&f2){
  blockToBeam[f1]=f2;
  beamToBlock[f2]=f1; 
 }
 
 slopeBlockToBeam[aa1]=aa2;
 slopeBlockToBeam[ab1]=ab2;
 slopeBlockToBeam[ac1]=ac2;
 slopeBlockToBeam[ad1]=ad2;
 slopeBeamToBlock[aa2]=aa1;
 slopeBeamToBlockM[aa3]=aa1;
 slopeBeamToBlock[ab2]=ab1;
 slopeBeamToBlockM[ab3]=ab1;
 slopeBeamToBlock[ac2]=ac1;
 slopeBeamToBlockM[ac3]=ac1;
 slopeBeamToBlock[ad2]=ad1;
 slopeBeamToBlockM[ad3]=ad1;

 totalstats = {
  "Block Count":0,
  "Natural Cost":0,
  "Metal Cost":0,
  "Oil Cost":0,
  "Scrap Cost":0,
  "Crystal Cost":0,
  "RP Cost":0,
  "Volume":0,
  "Max Power*":0,
  "Max Battery Capacity*":0,
  "Max Ammo Capacity*":0,
  "Max Fuel Capacity*":0,
  "Max Natural Storage*":0,
  "Max Metal Storage*":0,
  "Max Oil Storage*":0,
  "Max Scrap Storage*":0,
  "Max Crystal Storage*":0,
  "Blueprint Modified*":false,
 } 
 countblocks(CurrentBlueprint.Blueprint);
 totalstats["Volume"]=roundToTwo(totalstats["Volume"]);
 getpalette(CurrentBlueprint.Blueprint);

 var outputstring = "<table id='count_table' cellspacing='0' cellpadding='0'>";
 var totalcount = 0;
 for(var blockID in countID) {
  if(countID[blockID] >0) {
   blockCountData[nameID[blockID]] =  countID[blockID];
   totalcount+=countID[blockID];
  }
 }
 totalstats["Block Count"] = totalcount;
 
 keysSorted = Object.keys(blockCountData).sort(function(b,a){return blockCountData[a]-blockCountData[b]})
 for (var bName in keysSorted){ 
  outputstring +=  "<tr><td>" + keysSorted[bName]  + "</td><td>&nbsp;</td><td><b>" + blockCountData[keysSorted[bName]] + "</b></td></tr>";
  
 }
 outputstring += "</table>";
 document.getElementById('blockcount').innerHTML = outputstring;

 var statisticsString = "<table id='count_table' cellspacing='0' cellpadding='0'>";
 for (var stats in totalstats){ 
  statisticsString +=  "<tr><td>" + stats  + "</td><td>&nbsp;</td><td><b>" + totalstats[stats] + "</b></td></tr>";  
 }
 statisticsString += "</table>"; 
 
 document.getElementById('stats1').innerHTML = statisticsString;

 
 document.getElementById('blueprintinfo_panel').style.display="block";
 document.getElementById('modification_panel').style.display="block";
 return true;
}

//loads color palette
function getpalette(blocks){
 var palettedata = blocks.COL;
 for(var palID = 0; palID < palettedata.length; palID++){
  palStr = "" + palID;
  if (palStr.length<2){
   palStr = "0" + palStr;
  }
  var colorString = palettedata[palID];
  var colorArray = colorString.split(',');
  
  var tempr = (colorArray[0] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var tempg = (colorArray[1] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var tempb = (colorArray[2] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  
  var rtempr = ((1-colorArray[0]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var rtempg = ((1-colorArray[1]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var rtempb = ((1-colorArray[2]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  
  
  
  document.getElementById("pal" + palStr).style.backgroundColor = rgb2hex(tempr,tempg,tempb);  
  document.getElementById("pal" + palStr).style.color = rgb2hex(rtempr,rtempg,rtempb);  
  document.getElementById("co" + palStr).style.backgroundColor = rgb2hex(tempr,tempg,tempb);  
  document.getElementById("co" + palStr).style.color = rgb2hex(rtempr,rtempg,rtempb);  
 }
}

//counts blocks and accumulate vehicle data
function countblocks(blocks){
 var SClist=blocks.SCs;
 for(var scID = 0; scID < SClist.length; scID++){
  countblocks(SClist[scID]);
 }
 
 totalstats["Max Power*"] += Math.max(0,blocks.CSI[7]);
 totalstats["Max Battery Capacity*"] += Math.max(0,blocks.CSI[49]);
 totalstats["Max Ammo Capacity*"] += Math.max(0,blocks.CSI[38]);
 totalstats["Max Fuel Capacity*"] += Math.max(0,blocks.CSI[40]);
 totalstats["Max Natural Storage*"] += Math.max(0,blocks.CSI[23]);
 totalstats["Max Metal Storage*"] += Math.max(0,blocks.CSI[24]);
 totalstats["Max Oil Storage*"] += Math.max(0,blocks.CSI[25]);
 totalstats["Max Scrap Storage*"] += Math.max(0,blocks.CSI[26]);
 totalstats["Max Crystal Storage*"] += Math.max(0,blocks.CSI[27]);
 
 if(blocks.designChanged){
  totalstats["Blueprint Modified*"] = true;
 } 
 var blocklist=blocks.BlockIds;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  countID[blocklist[blockIndex]] +=1;
  var currentBlock = getBlock(blocklist[blockIndex]);
 if(currentBlock){
   totalstats["Natural Cost"]+=currentBlock.Natural;
   totalstats["Metal Cost"]+=currentBlock.Metal;
   totalstats["Oil Cost"]+=currentBlock.Oil;
   totalstats["Scrap Cost"]+=currentBlock.Scrap;
   totalstats["Crystal Cost"]+=currentBlock.Crystal;
   totalstats["RP Cost"]+=currentBlock.SparesCost;
   totalstats["Volume"]+=currentBlock.Volume;
 }
 }
}

//convert blocks between materials. also changes shield color.
function convertblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  convertblocks(SClist[scID]);
 }
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
	  blocklist[blockIndex] = getconverted(blocklist[blockIndex]);
	  if(document.getElementById("shieldcolor").checked){
	   if (nameID[blocklist[blockIndex]]=="Shield Color Changer"){
		blocks.BP1[blockIndex] = "" + document.getElementById("shieldr").value + "," +  document.getElementById("shieldg").value + "," + document.getElementById("shieldb").value + "," + document.getElementById("shielda").value;
	   }
	  }
	}
 }
 cleanBlueprint(blocks);
}


function mirrorVehicle(blocks){
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		var curSC=SClist[scID];
		curSC.LocalPosition=flipX(curSC.LocalPosition);
		curSC.LocalRotation=quatMirror(curSC.LocalRotation);
		mirrorVehicle(curSC);
	}
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

		blocklist[blockIndex]=mirrordata.blockID;
		positionList[blockIndex]=mirrordata.position;
		rotationList[blockIndex]=mirrordata.rotation;
	}
}

function rotateBlueprint(blocks,dir){
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		var curSC=SClist[scID];
		curSC.LocalPosition=positionRotate(curSC.LocalPosition,dir);
		curSC.LocalRotation=quatRotate(curSC.LocalRotation,dir);  
	}
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		positionList[blockIndex]=positionRotate(positionList[blockIndex],dir);
		rotationList[blockIndex]=blockRotate(rotationList[blockIndex],dir);
	}
}

//builds index of file to keep via the clearhull() function
function buildkeepIndex(){
 keepIndex = {};
 for(var mat in shapedBlocks){
  var blockcount =  shapedBlocks[mat].blockIds.length;
  for(var i=0;i<blockcount;i++){
   keepIndex[shapedBlocks[mat].blockIds[i]] = true;
  }
 }
}

//delete everything except structural blocks on the main vehicle
function clearhull(blocks){
 blocks.SCs = [];
 blocks.BlockStringData = [];
 blocks.BlockStringDataIds = [];
 blocks.BEI = [];
 var blocklist=blocks.BlockIds;
 var blrlist=blocks.BLR;
 var blplist=blocks.BLP;
 var bp1list=blocks.BP1;
 var bp2list=blocks.BP2;
 var bcilist=blocks.BCI; 
 var blocknew=[];
 var blrnew=[];
 var blpnew=[];
 var bp1new=[];
 var bp2new=[];
 var bcinew=[];
 var currentIndex = 0;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  if(keepIndex[blocklist[blockIndex]]){
   blocknew[currentIndex]=blocklist[blockIndex];
   blrnew[currentIndex]=blrlist[blockIndex];
   blpnew[currentIndex]=blplist[blockIndex];
   bp1new[currentIndex]=bp1list[blockIndex];
   bp2new[currentIndex]=bp2list[blockIndex];   
   bcinew[currentIndex]=bcilist[blockIndex];   
   currentIndex +=1;
  }
 } 
 blocks.BlockIds=blocknew;
 blocks.BLR=blrnew;
 blocks.BLP=blpnew;
 blocks.BP1=bp1new;
 blocks.BP2=bp2new;
 blocks.BCI=bcinew;
}

//randomly color blocks
function randomcolorblocks(blocks){
 var SClist=blocks.SCs;
 //blocks.designChanged = true;
 if(blocks.COL){
   for(var i=0;i<28;i++){
    var colorseed = Math.floor((Math.random() * 15));
    var othercolor = 0.0;
    if (Math.random()<0.5){
     othercolor = 1.0;
    }
    if (colorseed>8){
     blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + Math.random()  +",0.99";
    }
    else if (colorseed>6){
     blocks.COL[i]= "" +othercolor + "," + Math.random()  + "," + Math.random()  +",0.99";
    }
    else if (colorseed>4){
     blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + Math.random()  +",0.99";
    }
    else if (colorseed>2){
     blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + othercolor  +",0.99";
    }
    else if (colorseed>1){
     blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + othercolor  +",0.99";
    }   
    else if (colorseed>0){
     blocks.COL[i]= "" + othercolor + "," + Math.random()  + "," + othercolor  +",0.99";
    }else{
     blocks.COL[i]= "" + othercolor + "," + othercolor  + "," + Math.random()  +",0.99";
    }
    
   } 
 }
 for(var scID = 0; scID < SClist.length; scID++){

   randomcolorblocks(SClist[scID]);
  
 }
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < colorlist.length; blockIndex++){
   colorlist[blockIndex] = Math.floor((Math.random() * 28));
 }
}

//paint vehicles black and certain blocks in brighter colors
function highlightBlocks(blocks){
/*
  
  "AI Mainframe"
  "(CARD) Aerial AI"
  "(CARD) Naval AI"
  "(CARD) sailing"
  "PID"
  "Wireless Reciever"
  "Wireless Transmitter"
  "Local Weapon Controller"
  
  "PID (General Purpose)"
  "Automated Control Block"
  
  "(CARD) Propulsion Balancing"
  
  "LUA Box"  
  
*/
 var SClist=blocks.SCs;
 //blocks.designChanged = true;
 if(blocks.COL){
   blocks.COL[0]="0,0,0,0";
   blocks.COL[1]="0,0,0,0.66"; //black
   blocks.COL[2]="1,0,0,0.99"; //red
   blocks.COL[3]="1,0.5,0,0.99"; //orange
   blocks.COL[4]="1,1,0,0.99"; //yellow
   blocks.COL[5]="0,1,0,0.99"; //green
   blocks.COL[6]="0,0,1,0.99"; //blue
   blocks.COL[7]="0.7,0,0.7,0.99"; //purple
   blocks.COL[8]="1,0.5,1,0.99"; //pink	
 }
 for(var scID = 0; scID < SClist.length; scID++){

   highlightBlocks(SClist[scID]);
  
 }
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var blockname = nameID[blocklist[blockIndex]];
  
  if ((blockname=="AI Mainframe")||(blockname=="(CARD) Aerial AI")||(blockname=="(CARD) Naval AI")||(blockname=="(CARD) sailing")||(blockname=="PID")||(blockname=="Wireless Reciever")||(blockname=="Wireless Transmitter")||(blockname=="Local Weapon Controller")){
   colorlist[blockIndex] = 2;
  }
  else if ((blockname=="PID (General Purpose)")||(blockname=="Automated Control Block")){
   colorlist[blockIndex] = 3;
  }
  else if ((blockname=="(CARD) Propulsion Balancing")){
   colorlist[blockIndex] = 6;
  }  
  else if ((blockname=="LUA Box")){
   colorlist[blockIndex] = 8;
  }  
  else{
   colorlist[blockIndex] = 1;
  }  
 }
}

//paint blocks
function colorblocks(blocks){
 var SClist=blocks.SCs;
 //blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  if(!(SClist[scID].COL)){
   colorblocks(SClist[scID]);
  }
 }
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
	  var newcolor = getNewColor(blocklist[blockIndex]);
	  if (newcolor>=0){
	   colorlist[blockIndex] = newcolor;
	  }
	}
 }
}


//turns beam into blocks
function debeamifyblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  debeamifyblocks(SClist[scID]);
 } 
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR; 
 newBlockIndex=blocklist.length;
 blockcount=blocklist.length;
 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  if(ItemDic[currentBlock]&&beamToBlock[currentBlock]){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;
    var targetBlock =beamToBlock[currentBlock];
    var directionArray = getDirectionArray(rotationList[blockIndex]);
    if(directionArray){
     blocksDebeamed+=1;
     blocklist[blockIndex]=targetBlock;
     for(var i=1;i<4;i++){
      blocklist[newBlockIndex]=targetBlock;
      rotationList[newBlockIndex]=0;
      colorlist[newBlockIndex]=colorlist[blockIndex];
      blocks.BP1[newBlockIndex]="0,0,0,0";
      blocks.BP2[newBlockIndex]="0,0,0,0";
      positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
      newBlockIndex+=1;
     }
    }

  }
 }
 
}


function debeamifyslopeblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  debeamifyslopeblocks(SClist[scID]);
 } 
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR; 
 newBlockIndex=blocklist.length;
 blockcount=blocklist.length;
 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  var currentRotation = rotationList[blockIndex];
  if(ItemDic[currentBlock]&&(slopeBeamToBlock[currentBlock]||slopeBeamToBlockM[currentBlock])){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;
    var targetBlock = 0;
    var targetRotation = 0;
    if(slopeBeamToBlock[currentBlock]){
     targetBlock = slopeBeamToBlock[currentBlock];
     targetRotation = slopeBeamToBlockOrientation(currentRotation,false);
    }else if (slopeBeamToBlockM[currentBlock]){
     targetBlock = slopeBeamToBlockM[currentBlock];
     targetRotation = slopeBeamToBlockOrientation(currentRotation,true);
    }

    var directionArray = getDirectionArray(rotationList[blockIndex]);
    if(directionArray){
     blocksDebeamed+=1;
     blocklist[blockIndex]=targetBlock;
     rotationList[blockIndex]=targetRotation;
     for(var i=1;i<4;i++){
      blocklist[newBlockIndex]=targetBlock;
      rotationList[newBlockIndex]=targetRotation;
      colorlist[newBlockIndex]=colorlist[blockIndex];
      blocks.BP1[newBlockIndex]="0,0,0,0";
      blocks.BP2[newBlockIndex]="0,0,0,0";
      positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
      newBlockIndex+=1;
     }
    }

  }
 }
 
}


//get array of to represent block rotation
function getDirectionArray(rotation){
 if(rotation==0||rotation==16||rotation==12||rotation==18){
  return [0,0,1];
 }else if(rotation==2||rotation==17||rotation==14||rotation==19){
  return [0,0,-1];
 }else if(rotation==8||rotation==9||rotation==10||rotation==11){
  return [0,1,0];
 }else if(rotation==4||rotation==5||rotation==6||rotation==7){
  return [0,-1,0];
 }else if(rotation==1||rotation==20||rotation==13||rotation==22){
  return [1,0,0];
 }else if(rotation==3||rotation==21||rotation==15||rotation==23){
  return [-1,0,0];
 }else{
  return false;
 }
}


function beamifyaxisSloped(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 if(ItemDic[currentBlock]){
  if(slopeBlockToBeam[currentBlock]){
   
   var currentColor = colorlist[tempBlockIndex];
   var currentPosition = positionList[tempBlockIndex];
   var currentRotation = rotationList[tempBlockIndex];
   
   var posArray = JSON.parse("["+currentPosition+"]");
   posArray[0] = Math.round(posArray[0]);
   posArray[1] = Math.round(posArray[1]);
   posArray[2] = Math.round(posArray[2]);
   var result = true;
   
   
   result = true;
   for(i=1;i<4;i++){
    var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
    if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
     
    }else{
     result = false;
    }
   }
   if(result){
    blocksBeamed+=1;
    for(i=1;i<4;i++){
     var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
     blocklist[blockPositionData[tempPosition]]=-1;
    }
    blocklist[tempBlockIndex]=slopeBlockToBeam[currentBlock];
    rotationList[tempBlockIndex]=rotation;     
   }
   
   
  }
 }

}
//turn this blocks and adjacent 3 1x1x1 blocks in a particular direction into 1x1x4 beams
function beamifyaxis(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 if(ItemDic[currentBlock]){
  if(blockToBeam[currentBlock]){
   
   var currentColor = colorlist[tempBlockIndex];
   var currentPosition = positionList[tempBlockIndex];
   
   var posArray = JSON.parse("["+currentPosition+"]");
   posArray[0] = Math.round(posArray[0]);
   posArray[1] = Math.round(posArray[1]);
   posArray[2] = Math.round(posArray[2]);
   var result = true;
   
   
   result = true;
   for(i=1;i<4;i++){
    var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
    if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
     
    }else{
     result = false;
    }
   }
   if(result){
    blocksBeamed+=1;
    for(i=1;i<4;i++){
     var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
     blocklist[blockPositionData[tempPosition]]=-1;
    }
    blocklist[tempBlockIndex]=blockToBeam[currentBlock];
    rotationList[tempBlockIndex]=rotation;     
   }
   
   
  }
 }

}

function getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData){
 
 var queue1=[blockIndex];
 var queue1index=1; 
 var queue1process=0;
 while(queue1process<queue1index){
  var tempBlockIndex = queue1[queue1process];
  var currentBlock = blocklist[tempBlockIndex];
  var currentColor = colorlist[tempBlockIndex];
  var currentPosition = positionList[tempBlockIndex];
  var posArray = JSON.parse("["+currentPosition+"]");
  posArray[0] = Math.round(posArray[0]);
  posArray[1] = Math.round(posArray[1]);
  posArray[2] = Math.round(posArray[2]);
  var tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]);
  if(blockPositionData[tempPosition]){
   var tempblock = {}
   tempblock.blockIndex=tempBlockIndex;
   tempblock.score=0;
   localPositionData[tempPosition]=tempblock;
   delete blockPositionData[tempPosition]; 
   
   tempPosition = "" + (posArray[0]+1)+","+(posArray[1])+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }
   
   tempPosition = "" + (posArray[0]-1)+","+(posArray[1])+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1]+1)+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1]-1)+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]+1);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]-1);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }   
   
   
  }
 
 
  queue1process++;
 }

}

//get an array containing 1x1x1 blocks in a direction.
function getLookbackArray(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData){
 var tempindex=0;
 var tempList=[];
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 var currentColor = colorlist[tempBlockIndex];
 var currentPosition = positionList[tempBlockIndex];
 var posArray = JSON.parse("["+currentPosition+"]");
 posArray[0] = Math.round(posArray[0]);
 posArray[1] = Math.round(posArray[1]);
 posArray[2] = Math.round(posArray[2]); 
 
 
 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
 
 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
  tempList[tempindex]=blockPositionData[tempPosition];
  
  tempindex+=1;
  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
  
 }
 return tempList;
}

function getLookbackArraySloped(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList){
 var tempindex=0;
 var tempList=[];
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 var currentColor = colorlist[tempBlockIndex];
 var currentPosition = positionList[tempBlockIndex];
 var currentRotation = rotationList[tempBlockIndex];
 var posArray = JSON.parse("["+currentPosition+"]");
 posArray[0] = Math.round(posArray[0]);
 posArray[1] = Math.round(posArray[1]);
 posArray[2] = Math.round(posArray[2]); 
 
 
 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
 
 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
  tempList[tempindex]=blockPositionData[tempPosition];
  
  tempindex+=1;
  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
  
 }
 return tempList;
}




function becomeStructure(blocks,subcon){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  if(!(SClist[scID].COL)){
   //no palette=turret or spinblock
   becomeStructure(SClist[scID],true);
  } 
  
 }
 var start=0;
 if(subcon){
  start=1;
 }
 var deletecount=0;
 var blocklist=blocks.BlockIds;
 for(var blockIndex = start; blockIndex < blocklist.length; blockIndex++){
  var currentBlockInfo = getBlock(blocklist[blockIndex]);
  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnStructure)){
   deletecount+=1;
   blocklist[blockIndex]=-1;
  }

 }
 
cleanBlueprint(blocks);
}


function becomeVehicle(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  becomeVehicle(SClist[scID]);
 }
 var deletecount=0;
 var blocklist=blocks.BlockIds;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlockInfo = getBlock(blocklist[blockIndex]);
  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnVehicle)){
   deletecount+=1;
   blocklist[blockIndex]=-1;
  }

 }
 cleanBlueprint(blocks);
 
}


function cutInHalfSC(blocks,midx){
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var scRotation = "["+blocks.LocalRotation+"]";
	var scPosition = "["+blocks.LocalPosition+"]";
	var scp = JSON.parse(scPosition);
	var q = JSON.parse(scRotation);
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var tpaq = [tpa[0],tpa[1],tpa[2],0];
		var transpos = quatmul(q,quatmul(tpaq,quatconj(q)));
		var finalx = scp[0]+transpos[0];
		finalx=Math.round(finalx);
		if(finalx>midx){
			blocklist[blockIndex]=-1;
		}
	}
	cleanBlueprint(blocks);
}

function cutInHalf(blocks,xshift){
	blocks.designChanged = true;
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var midx=0;
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
	}
	midx=((minx+maxx)/2)+xshift;

	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		if (curx>midx){
			blocklist[blockIndex]=-1;
		}
	}

	for(var scID = 0; scID < SClist.length; scID++){
		if(!(SClist[scID].COL)){
			var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
			var tpa = JSON.parse(currentPosition);
			var curx = Math.round(tpa[0]);
			if(curx>midx){
				SClist[scID].ItemNumber=-1;
			}else{
				cutInHalfSC(SClist[scID],midx);
			}
		}else{
			SClist[scID].ItemNumber=-1;
		}
	}
	cleanBlueprint(blocks);
}




//need to modify when we can check for parts sticking out
function widenVehicle(blocks,xdist,xshift){
	blocks.designChanged = true;
	var blockPositionData={};
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var miny=0;
	var maxy=0;
	var minz=0;
	var maxz=0;
	var midx=0;
	var leftx=0;
	var rightx=0;
	var bestrs;
	var bestls;
	var bestrp;
	var bestlp;	
	var xmove=Math.round(parseFloat(xdist));
	var maxmirrorx=0;
	var rightconnected=false;
	var leftconnected=false;	
	var fillerblock=(shapedBlocks["wood"]).blockIds[0];
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList=blocks.BLR;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var colorlist=blocks.BCI;
	var beilist=blocks.BEI;	
	var blockcount=blocklist.length; //needed cause variableblocklist :D
	var beiIndex=0;
	var currentIndex = blockcount; //index to add new blocks
	var currentBeiIndex = beilist.length;; //index to add new blocks
	var currentSCIndex=SClist.length;
	var SCcount=SClist.length;
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		blockPositionData[atos(tpa)]=blockIndex;
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
		miny=Math.min(tpa[1],miny);
		maxy=Math.max(tpa[1],maxy);
		minz=Math.min(tpa[2],minz);
		maxz=Math.max(tpa[2],maxz);
	}
	var midy=Math.round((miny+maxy)/2);
	var midz=Math.round((minz+maxz)/2);	
	midx=((minx+maxx)/2)+parseFloat(xshift);
	midx=Math.round(midx-0.2);
	leftx=midx;
	rightx=leftx+1;	
	
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var tpa = stoar(positionList[blockIndex]);
		var curx = tpa[0];
		if (curx>midx){
			positionList[blockIndex]=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
			if((tpa[0]==rightx)&&(!leftconnected)&&(!rightconnected)){
				leftblock=atos([leftx,tpa[1],tpa[2]]);
				if(blockPositionData[leftblock]!==undefined&&blockPositionData[leftblock]>=0){
					midy=tpa[1];
					midz=tpa[2];
					leftconnected=true;
					rightconnected=true;
				}
			}
			if((tpa[0]==rightx)&&(!rightconnected)){
				if(!bestrp){
					bestrp=atos(tpa);
					bestrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
				}else{
					var currentrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
					if(currentrs<bestrs){
						bestrp=atos(tpa);
						bestrs=currentrs;
					}
				}
				
			}
		
		}else{
			if((tpa[0]==leftx)&&(!leftconnected)){
				if(!bestlp){
					bestlp=atos(tpa);
					bestls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
				}else{
					var currentls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
					if(currentls<bestls){
						bestlp=atos(tpa);
						bestls=currentls;					
					}
				}
			}
		}
	}
	//add filllerblock

	for (var i=rightx;i<(rightx+xmove);i++){
		blocks.BlockIds[currentIndex]=fillerblock;
		blocks.BLP[currentIndex]=atos([i,midy,midz]);
		blocks.BLR[currentIndex]=0;
		blocks.BP1[currentIndex]="0,0,0,0";
		blocks.BP2[currentIndex]="0,0,0,0";
		blocks.BCI[currentIndex]=0;
		currentIndex++;
	}
	
	//connect left
	if((bestlp)&&(!leftconnected)){
		var bestla=stoar(bestlp);
		var starty=Math.min(bestla[1],midy+1);
		var endy=Math.max(bestla[1],midy-1);		
		var startz=Math.min(bestla[2],midz+1);
		var endz=Math.max(bestla[2],midz-1);
		
		for(var y=starty;y<=endy;y++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+1,y,midz]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		for(var z=startz;z<=endz;z++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+1,bestla[1],z]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		leftconnected=true;
	}
	//connect right
	if((bestrp)&&(!rightconnected)){
		var bestra=stoar(bestrp);
		var starty=Math.min(bestra[1],midy+1);
		var endy=Math.max(bestra[1],midy-1);		
		var startz=Math.min(bestra[2],midz+1);
		var endz=Math.max(bestra[2],midz-1);
		
		for(var y=starty;y<=endy;y++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+xmove,y,midz]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		for(var z=startz;z<=endz;z++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+xmove,bestra[1],z]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		rightconnected=true;
	}
	if((!leftconnected)||(!rightconnected)){
		alert("Left and right sides might not be connected properly");
	}


	for(var scID = 0; scID < SCcount; scID++){
		var sctype=getType(SClist[scID].ItemNumber);
		var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
		var tpa = stoar((SClist[scID]).LocalPosition);
		var curx = tpa[0];
		if(curx>midx){			
			(SClist[scID]).LocalPosition=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
			//check if turret disconnected
			if((sctype==2)&&(tpa[0]==rightx)){
				var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
				if(Math.round(newpos[0])==-1){
					alert("A turret or spin block might be disconnected after after the process.");
				}
			}
		}else{
			if((sctype==2)&&(tpa[0]==leftx)){
				var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
				if(Math.round(newpos[0])==1){
					alert("A turret or spin block might be disconnected after after the process.");
				}			
			}
			
		}
	}
	cleanBlueprint(blocks);		
}



//need to modify when we can check for parts sticking out
function cutAndMirror(blocks,xshift,even){
	blocks.designChanged = true;
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var midx=0;
	var xmove=0;
	var maxmirrorx=0;
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList=blocks.BLR;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var colorlist=blocks.BCI;
	var beilist=blocks.BEI;	
	var blockcount=blocklist.length; //needed cause variableblocklist :D
	var beiIndex=0;
	var currentIndex = blockcount; //index to add new blocks
	var currentBeiIndex = beilist.length;; //index to add new blocks
	var currentSCIndex=SClist.length;
	var SCcount=SClist.length;
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
	}
	
	midx=((minx+maxx)/2)+xshift;
	midx=Math.round(midx-0.2);
	
	if(even){
		maxmirrorx=midx;
		xmove=(midx*2)+1;
	}else{
		maxmirrorx=midx-1;
		xmove=midx*2;
	}
	
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var tpa = stoar(positionList[blockIndex]);
		var curx = tpa[0];
		if (curx>midx){
			blocklist[blockIndex]=-1;
		}else if (curx<=maxmirrorx){
			var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

			blocks.BlockIds[currentIndex]=mirrordata.blockID;
			var newposition=stoar(mirrordata.position);
			newposition[0]=newposition[0]+xmove;
			blocks.BLP[currentIndex]=atos(newposition);
			blocks.BLR[currentIndex]=mirrordata.rotation;
			blocks.BP1[currentIndex]=bp1list[blockIndex];
			blocks.BP2[currentIndex]=bp2list[blockIndex];
			blocks.BCI[currentIndex]=colorlist[blockIndex];
			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				blocks.BEI[currentBeiIndex]=currentIndex;
				var beiIncrement = beilist[beiIndex+1]+2;
				for(var i=1;i<beiIncrement;i++){
					blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
				}
				beiIndex+=beiIncrement;
				currentBeiIndex+=beiIncrement;
			}else if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){				
				var beiIncrement = beilist[beiIndex+1]+2;
				beiIndex+=beiIncrement;
			}		
			//blocklist[blockIndex]=-1;			
			currentIndex+=1;
		}
				
	}

	for(var scID = 0; scID < SCcount; scID++){
		if(!(SClist[scID].COL)){
			var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
			var tpa = stoar((SClist[scID]).LocalPosition);
			var curx = tpa[0];
			if(curx>midx){
				SClist[scID].ItemNumber=-1;
			}else if (curx<=maxmirrorx){
				tpa[0]=xmove-tpa[0];
				blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
				blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
				blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
				mirrorVehicle(blocks.SCs[currentSCIndex]);
				currentSCIndex++;			
			}			
		}else{
			SClist[scID].ItemNumber=-1;
		}
	}
	cleanBlueprint(blocks);		
}


//need to modify when we can check for parts sticking out
function jointMirror(blocks,even){
	blocks.designChanged = true;
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var xmove=0;
	var maxmirrorx=0;
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList=blocks.BLR;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var colorlist=blocks.BCI;
	var beilist=blocks.BEI;	
	var blockcount=blocklist.length; //needed cause variableblocklist :D
	var beiIndex=0;
	var currentIndex = blockcount; //index to add new blocks
	var currentBeiIndex = beilist.length;; //index to add new blocks
	var currentSCIndex=SClist.length;
	var SCcount=SClist.length;
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
	}
	
	
	
	if(even){
		maxmirrorx=maxx;
		xmove=(maxx*2)+1;
	}else{
		maxmirrorx=maxx-1;
		xmove=maxx*2;
	}


	
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var tpa = stoar(positionList[blockIndex]);
		var curx = tpa[0];
		if (curx<=maxmirrorx){
			var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

			blocks.BlockIds[currentIndex]=mirrordata.blockID;
			var newposition=stoar(mirrordata.position);
			newposition[0]=newposition[0]+xmove;
			blocks.BLP[currentIndex]=atos(newposition);
			blocks.BLR[currentIndex]=mirrordata.rotation;
			blocks.BP1[currentIndex]=bp1list[blockIndex];
			blocks.BP2[currentIndex]=bp2list[blockIndex];
			blocks.BCI[currentIndex]=colorlist[blockIndex];
			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				blocks.BEI[currentBeiIndex]=currentIndex;
				var beiIncrement = beilist[beiIndex+1]+2;
				for(var i=1;i<beiIncrement;i++){
					blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
				}
				beiIndex+=beiIncrement;
				currentBeiIndex+=beiIncrement;
			}else if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){				
				var beiIncrement = beilist[beiIndex+1]+2;
				beiIndex+=beiIncrement;
			}		
			//blocklist[blockIndex]=-1;			
			currentIndex+=1;
		}
				
	}

	for(var scID = 0; scID < SCcount; scID++){
		if(!(SClist[scID].COL)){
			var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
			var tpa = stoar((SClist[scID]).LocalPosition);
			var curx = tpa[0];
			if (curx<=maxmirrorx){
				tpa[0]=xmove-tpa[0];
				blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
				blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
				blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
				mirrorVehicle(blocks.SCs[currentSCIndex]);
				currentSCIndex++;			
			}			
		}else{
			SClist[scID].ItemNumber=-1;
		}
	}
	cleanBlueprint(blocks);		
}




//turn blocks into beams
function beamifyblocks2(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  beamifyblocks2(SClist[scID]);
 }
 var blockPositionData = {};
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  if(ItemDic[currentBlock]){
   if(blockToBeam[currentBlock]){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;    
    //var currentPosition = ""+Math.round(tpa[0])+","+Math.round(tpa[1])+","+Math.round(tpa[2]);
    //targetBlock =blockToBeam[currentBlock];    
    blockPositionData[currentPosition]=blockIndex;    
   }
  }
 }
 
 //z=axis
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex];
  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxis(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
   }

  }

 }//z=axis 
 

 //y=axis
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex];
  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxis(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
   }

  }
 }//y=axis 
 
 
 //x=axis
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex];
  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxis(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
   }

  }
 }//x=axis  

	cleanBlueprint(blocks);
}



function getAxis(axis,neg){
	var tempaxis=[0,0,0];
	if(neg){
		tempaxis[axis]=-1;
	}else{
		tempaxis[axis]=1;
	}
	return tempaxis;
}


//optimize
function beamifyblocksOptimized(blocks){	
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		beamifyblocksOptimized(SClist[scID]);
	}
	var blockPositionData = {};
	var blocklist=blocks.BlockIds;
	var colorlist=blocks.BCI;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		if(ItemDic[currentBlock]){
			if(blockToBeam[currentBlock]){				
				var tpa = stoar(positionList[blockIndex]);
				var currentPosition = atos(tpa);
				blockPositionData[currentPosition]=blockIndex;    
			}
		}
	}

	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock=blocklist[blockIndex];
		if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
			var localPositionData = {};
			getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
			while(true){
				for(position in localPositionData){
					if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
						delete localPositionData[position];
					}else{
						localPositionData[position].score=0;
					}
				}
				//scoring start
				var localScore=0;
				var beamAxis=0;
				for(position in localPositionData){
					var blockscore=false;
					var currentData=localPositionData[position];
					var lpa = stoar(position);
					var templength;
					var tempdir;
					//scoring for each axis x,y,z
					for (var axis=0;axis<3;axis++){
						templength=1;
						for(var neg=0;neg<2;neg++){
							tempdir=getAxis(axis,neg);
							for(var tempindex=1;tempindex<4;tempindex++){
								var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
								if(localPositionData[tempLocalPosition]!==undefined){
									templength+=1;      
								}else{
									break;
								}
							}
						}
						if (templength>=4){
							
							blockscore=true;
							beamAxis+=1;
							localPositionData[position].score+=(templength-1);
						}
					}
					//score local block
					if(blockscore){
						
						currentData.score+=1;
						localScore+=1;
					}
				}
				
				//proceed if there are beamable blocks
				if (localScore>0){					

					//beamAxis is number of axis that is beamable 

					var scoreTable=[];
					var scoreIndex=0;
					var dedup={};

					//permutate possible beams and scores, then sort
					var minscore=200;
					var scorecap=11;
					for(position in localPositionData){
						var currentData=localPositionData[position];
						var lpa = stoar(position);
						var tempdir1;
						var tempdir2;
						
						for (var axis=0;axis<3;axis++){
						
							dedup={};
							tempdir1=getAxis(axis,true);
							tempdir2=getAxis(axis,false);
							for(tempindex=0;tempindex<4;tempindex++){
								var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
								if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=4)){
									if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-12))){										
										dedup[tempLocalPosition]=true;
										continue;
									}
									var llpa = stoar(tempLocalPosition);
									if(!dedup[tempLocalPosition]){
										var templength=1;
										for(var temptempindex=1;temptempindex<4;temptempindex++){											
											temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
											if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=4)){
												templength+=1;
											}else{
												break;
											}
										}
										if(templength==4){
											
											dedup[tempLocalPosition]=true;
											var scoreBlock=[];
											for(var temptempindex=0;temptempindex<4;temptempindex++){
												temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
												scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
											}
											scoreBlock[4]=BeamAxisRot[axis]; //rotation
											scoreBlock[5]=BeamAxisPriority[axis]; //priority
											scoreBlock[6]=llpa[axis]; //priority2

											var tempscore=scoreBlock[0].score+scoreBlock[1].score+scoreBlock[2].score+scoreBlock[3].score;
											if((tempscore>=16)&&(tempscore<=minscore)){
												minscore=tempscore;
												scoreTable[scoreIndex] = scoreBlock;
												scoreIndex++;
											}
										}
									}
								}else{
									break;
								}
							}							

						}
				  
					}

					//sort
					var bestscore=199;
					while(scoreTable.length>0){
						scoreTable.sort(function(a, b){
							res=(a[0].score+a[1].score+a[2].score+a[3].score)-(b[0].score+b[1].score+b[2].score+b[3].score);
							if(res==0){
								var resa=(a[5]-b[5]);
								if(resa==0){
									return a[6]-b[6];
								}else{
									return resa;
								}
							}else{
								return res;
							}
						});

						currentScoreBlock=scoreTable[0];
						if((currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score)>bestscore){
							break;
						}else{
							bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score;
							currentScoreBlock[0].score=200;
							currentScoreBlock[1].score=200;
							currentScoreBlock[2].score=200;
							currentScoreBlock[3].score=200;
							blocksBeamed+=1;

							blocklist[currentScoreBlock[1].blockIndex]=-1;
							blocklist[currentScoreBlock[2].blockIndex]=-1;
							blocklist[currentScoreBlock[3].blockIndex]=-1;

							blocklist[currentScoreBlock[0].blockIndex]=blockToBeam[currentBlock];
							rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
						}
					}
				}
				else{
					//exit loop if no beamable blocks
					break;
				}
			}//end while
		   //scoring end
		}
	}
	cleanBlueprint(blocks);
}


function removeOverlap(blocks){
	var blockPosData = {};
	var blocklist=blocks.BlockIds;
	var colorlist=blocks.BCI;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){		
		var currentBlock = blocklist[blockIndex];
		var blockData = getBlock(currentBlock);
		var tempBlock={};
		var currentPosition = stoar(positionList[blockIndex]);
		tempBlock.blockId=currentBlock;
		tempBlock.blockIndex=blockIndex;
		tempBlock.pos=positionList[blockIndex];
		tempBlock.rot=rotationList[blockIndex];
		tempBlock.bci=colorlist[blockIndex];
		tempBlock.overlap=false;
		if(blockData){
			
			for (var x=blockData.negx;x<=blockData.posx;x++){
				for (var y=blockData.negy;y<=blockData.posy;y++){
					for (var z=blockData.negz;z<=blockData.posz;z++){
						var q=getQuat(rotationList[blockIndex]);
						var temppos=posTransform([x,y,z],q);
						currentPosition
						var strPos=atos([temppos[0]+currentPosition[0],temppos[1]+currentPosition[1],temppos[2]+currentPosition[2]]);
						if (blockPosData[strPos]){
							//overlap
							//maybe can consider performing beam to block here
							tempBlock.overlap=true;
							blocklist[blockIndex]=-1;
						}else{
							blockPosData[strPos]=tempBlock;
							//no overlap
						}
					}
				}
			}
		}else{
			//block not found?
		}
	
	}
	var tempBlockIndex=blocklist.length;
	for(position in blockPosData){
		var tempBlock=blockPosData[position];
		if(tempBlock.overlap){
			if(beamToBlock[tempBlock.blockId]){
				var newBlockId=beamToBlock[tempBlock.blockId];
				blocklist[tempBlockIndex]=newBlockId;
				rotationList[tempBlockIndex]=0;
				colorlist[tempBlockIndex]=tempBlock.bci;
				blocks.BP1[tempBlockIndex]="0,0,0,0";
				blocks.BP2[tempBlockIndex]="0,0,0,0";
				positionList[tempBlockIndex]= position;
				tempBlockIndex+=1;				
			}else if(slopeBeamToBlock[tempBlock.blockId]){
				var newBlockId=slopeBeamToBlock[tempBlock.blockId];
				blocklist[tempBlockIndex]=newBlockId;
				var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],false);
				rotationList[tempBlockIndex]=targetRotation;
				colorlist[tempBlockIndex]=tempBlock.bci;
				blocks.BP1[tempBlockIndex]="0,0,0,0";
				blocks.BP2[tempBlockIndex]="0,0,0,0";
				positionList[tempBlockIndex]= position;
				tempBlockIndex+=1;			
			}else if(slopeBeamToBlockM[tempBlock.blockId]){
				var newBlockId=slopeBeamToBlockM[tempBlock.blockId];
				blocklist[tempBlockIndex]=newBlockId;
				var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],true);
				rotationList[tempBlockIndex]=targetRotation;
				colorlist[tempBlockIndex]=tempBlock.bci;
				blocks.BP1[tempBlockIndex]="0,0,0,0";
				blocks.BP2[tempBlockIndex]="0,0,0,0";
				positionList[tempBlockIndex]= position;
				tempBlockIndex+=1;			
			}

		}
		
	}	
	cleanBlueprint(blocks);
}


function beamifyslopeblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  beamifyslopeblocks(SClist[scID]);
 }
 var blockPositionData = {};
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  if(ItemDic[currentBlock]){
   if(slopeBlockToBeam[currentBlock]){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;       
    blockPositionData[currentPosition]=blockIndex;    
   }
  }
 }
 


 
 

 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex]; 
  var currentRotation=rotationList[blockIndex];


  var dirx=0;
  var diry=0;
  var dirz=0;

  switch (currentRotation) {
   case 0:
   case 2:
   case 4:
   case 6:
   case 8:
   case 10:
   case 12:
   case 14:
    dirx=1;
    diry=0;
    dirz=0;
    break;
   case 16:
   case 17:
   case 18:
   case 19:
   case 20:
   case 21:
   case 22:
   case 23:
    dirx=0;
    diry=1;
    dirz=0;
    break;   
   case 1:
   case 3:
   case 5:
   case 7:
   case 9:
   case 11:
   case 13:
   case 15:
    dirx=0;
    diry=0;
    dirz=1;
    break;
   default:
  } 
 

  if(ItemDic[currentBlock]&&slopeBlockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArraySloped((-dirx),(-diry),(-dirz),blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList);   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxisSloped(dirx,diry,dirz,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,slopeBlockToBeamOrientation(currentRotation,false));
   }

  }

 }
 
	cleanBlueprint(blocks);
}


//returns different block ID if blocks needs to be converted
function getconverted(bID){
 if (conversionIndex[bID]){
  return conversionIndex[bID];  
 }
 else return(bID);
}

//accepts natural,metal,oil,scrap,crystal, returns RP value
function calculateRP(r1,r2,r3,r4,r5){
 return r1+r2*2+r3*3+r4*4+r5*10;
}

//applies selected options and trigger file download
function downloadBlueprint(){
 try{
 
  if(document.getElementById("paintrestrict").checked){
	allowedcolor=document.getElementById("paintallow").value;
  }else{
	allowedcolor=-1;
  }
  if(document.getElementById("replaceold").checked){
   buildReplaceOldIndex();
   replaceOld(CurrentBlueprint.Blueprint);
  }
  if(document.getElementById("clearhull").checked){
   buildkeepIndex();
   clearhull(CurrentBlueprint.Blueprint);
  }
  if(document.getElementById("cutinhalf").checked){
   var xshift=parseInt(document.getElementById("centershift").value);
   cutInHalf(CurrentBlueprint.Blueprint,xshift);
  } 
  if(document.getElementById("cutandmirror").checked){
   var xshift=parseInt(document.getElementById("cloneshift").value);
   var even=document.getElementById("evenclone1").checked;
   cutAndMirror(CurrentBlueprint.Blueprint,xshift,even);
   removeOverlap(CurrentBlueprint.Blueprint);
  } 
  if(document.getElementById("jointmirror").checked){
   var even=document.getElementById("evenclone2").checked;
   jointMirror(CurrentBlueprint.Blueprint,even);
   removeOverlap(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("widen").checked){
	var xdist=parseInt(document.getElementById("widendistance").value);
	var xshift=parseInt(document.getElementById("widenshift").value);
	widenVehicle(CurrentBlueprint.Blueprint,xdist,xshift);
	removeOverlap(CurrentBlueprint.Blueprint);
  }
  
/*  
  if(document.getElementById("removeoverlap").checked){
   removeOverlap(CurrentBlueprint.Blueprint);
  } 
 */

  

  if (!isNumeric(document.getElementById("shieldr").value)){document.getElementById("shieldr").value=1.0;}
  if (!isNumeric(document.getElementById("shieldg").value)){document.getElementById("shieldg").value=1.0;}
  if (!isNumeric(document.getElementById("shieldb").value)){document.getElementById("shieldb").value=1.0;}
  if (!isNumeric(document.getElementById("shielda").value)){document.getElementById("shielda").value=1.0;}
  document.getElementById("shieldr").value=Math.min(1.0,document.getElementById("shieldr").value);
  document.getElementById("shieldg").value=Math.min(1.0,document.getElementById("shieldg").value);
  document.getElementById("shieldb").value=Math.min(1.0,document.getElementById("shieldb").value);
  document.getElementById("shielda").value=Math.min(10.0,document.getElementById("shielda").value);
  document.getElementById("shieldr").value=Math.max(0.0,document.getElementById("shieldr").value);
  document.getElementById("shieldg").value=Math.max(0.0,document.getElementById("shieldg").value);
  document.getElementById("shieldb").value=Math.max(0.0,document.getElementById("shieldb").value);
  document.getElementById("shielda").value=Math.max(0.10,document.getElementById("shielda").value);


  buildconversionIndex();
  buildblockColorIndex();
  convertblocks(CurrentBlueprint.Blueprint);  
  if(document.getElementById("highlightAI").checked){

   highlightBlocks(CurrentBlueprint.Blueprint);
  }else if(document.getElementById("randomcolor").checked){

   randomcolorblocks(CurrentBlueprint.Blueprint);
  }
  else if(document.getElementById("paint").checked){
   colorblocks(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("becomeStructure").checked){
   CurrentBlueprint.Blueprint.ItemNumber=ItemTable["cb5bfa64-c3fd-435c-b0da-3891a86b20d2"].BlockId;
   becomeStructure(CurrentBlueprint.Blueprint,false);
  }else if(document.getElementById("becomeVehicle").checked){
   CurrentBlueprint.Blueprint.ItemNumber=ItemTable["e63040c9-0027-4fd3-be30-67fe3e950140"].BlockId;
   becomeVehicle(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("rotateVehicle").checked){
   rotateBlueprint(CurrentBlueprint.Blueprint,document.getElementById("rotatedir").value);
  }   
  
  if(document.getElementById("mirrorLateral").checked){
   mirrorVehicle(CurrentBlueprint.Blueprint);
  }
  
  
  if(document.getElementById("debeamify").checked){
   blocksDebeamed = 0;  
   debeamifyblocks(CurrentBlueprint.Blueprint);
   debeamifyslopeblocks(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("beamifyOptimized").checked){
   blocksBeamed = 0;

   beamifyslopeblocks(CurrentBlueprint.Blueprint);
   //var starttime=(new Date()).getTime();   
   beamifyblocksOptimized(CurrentBlueprint.Blueprint);
   //var endtime=(new Date()).getTime(); 
   //alert(endtime-starttime);

  }else if(document.getElementById("beamify2").checked){
   blocksBeamed = 0;
   beamifyblocks2(CurrentBlueprint.Blueprint);
   beamifyslopeblocks(CurrentBlueprint.Blueprint);
  }

  selectedFileName = "Modified_" + selectedFileName;
  processData();
  document.getElementById("filecontent").style.display="block";
  document.getElementById("filetext").style.display="none";
  document.getElementById("filetextbox").value=JSON.stringify(CurrentBlueprint);
  download(selectedFileName,JSON.stringify(CurrentBlueprint)); 
  //download(selectedFileName,JSON.stringify(RotTable)); 

  
 }catch(err){
  loadError(err);
 }
}

function togglefiletext(){
 if(document.getElementById("filetext").style.display=="none"){
  document.getElementById("filetext").style.display="block";
  document.getElementById("filetextbox").select();
 }else{
  document.getElementById("filetext").style.display="none";
 }
}

function buildReplaceOldIndex(){
	replaceOldIndex = {};
	for(var key in ItemDic){
		var keyint = parseInt(key);
		var val = ItemDic[keyint];
		if(oldBlocks[val]){
			var tempblock={};
			tempblock.BlockId=ItemTable[oldBlocks[val].Guid].BlockId;
			tempblock.Rot=oldBlocks[val].Rot;
			replaceOldIndex[keyint]=tempblock;
		}
	}
}

function replaceOld(blocks){
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		replaceOld(SClist[scID]);
	}
	var blocklist=blocks.BlockIds;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		if(replaceOldIndex[blocklist[blockIndex]]){
			var replaceData = replaceOldIndex[blocklist[blockIndex]];
			var newRotation = blockRotate(replaceData.Rot,rotationList[blockIndex]);
			var newBlock = replaceData.BlockId;				
			blocklist[blockIndex] = newBlock;
			rotationList[blockIndex] = newRotation;
		}
	}
}

/*

  if(ItemTable[val]){
 for(var mat in shapedBlocks){
  if(document.getElementById(mat).checked){
   newmat=document.getElementById(mat+"to").value;
	if (newmat!=mat){
    var blockcount = shapedBlocks[mat].blockIds.length;
    for(var i=0;i<blockcount;i++){
	   if(newmat==0){
		conversionIndex[shapedBlocks[mat].blockIds[i]]=-1;
	   }else if ((i<shapedBlocks[newmat].blockIds.length)&&(shapedBlocks[newmat].blockIds[i]>=0)){
      conversionIndex[shapedBlocks[mat].blockIds[i]] = shapedBlocks[newmat].blockIds[i];
     }
    }
   }
  }  
 }
}
*/
//builds a lookup table of blockIDs to convert from:to
function buildconversionIndex(){
 conversionIndex = {};
 for(var mat in shapedBlocks){
  if(document.getElementById(mat).checked){
   newmat=document.getElementById(mat+"to").value;
	if (newmat!=mat){
    var blockcount = shapedBlocks[mat].blockIds.length;
    for(var i=0;i<blockcount;i++){
	   if(newmat==0){
		conversionIndex[shapedBlocks[mat].blockIds[i]]=-1;
	   }else if ((i<shapedBlocks[newmat].blockIds.length)&&(shapedBlocks[newmat].blockIds[i]>=0)){
      conversionIndex[shapedBlocks[mat].blockIds[i]] = shapedBlocks[newmat].blockIds[i];
     }
    }
   }
  }  
 }
}

//get color to paint blocks depending on selected option
function getNewColor(bID){
 if(document.getElementById("paint").checked){
  if(document.getElementById("painttarget").value=="all"){
   return selectedcolor;      
  }
  else if(document.getElementById("painttarget").value=="paintothers"){
   if(blockColorIndex[bID]!==undefined){
    return -1;
   }else{
    return selectedcolor;
   }
  }else{
   if(blockColorIndex[bID]!==undefined){
    return blockColorIndex[bID];
   }else{
    return -1;
   }
  }

 }
 else{
  return -1;
 }
}


//builds lookup table to help determine which blocks to color
function buildblockColorIndex(){
/*
painttarget:
all
wood
metal
alloy
glass
stone
lead
paintstruct
paintothers
*/
 blockColorIndex = {};
 
 if(document.getElementById("paint").checked){
  selectedcolor=document.getElementById("tocolor").value;
  
  if((document.getElementById("painttarget").value=="wood")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["wood"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["wood"].blockIds[i]] = selectedcolor;
   }
  }
  
  if((document.getElementById("painttarget").value=="metal")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["metal"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["metal"].blockIds[i]] = selectedcolor;
   }
  }  

  if((document.getElementById("painttarget").value=="alloy")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["alloy"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["alloy"].blockIds[i]] = selectedcolor;
   }
  } 

  if((document.getElementById("painttarget").value=="glass")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["glass"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["glass"].blockIds[i]] = selectedcolor;
   }
  }
  if((document.getElementById("painttarget").value=="stone")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["stone"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["stone"].blockIds[i]] = selectedcolor;
   }
  }
  if((document.getElementById("painttarget").value=="lead")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["lead"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["lead"].blockIds[i]] = selectedcolor;
   }
  }
 }
}


function slopeBeamToBlockOrientation(blockrotate, mirrored){
 if(mirrored){
  switch (blockrotate) {
   case 0:
    return 1;
   case 1:
    return 2;
   case 2:
    return 3;
   case 3:
    return 0;
   case 4:
    return 16;
   case 5:
    return 17;
   case 6:
    return 19;
   case 7:
    return 18;
   case 8:
    return 18;
   case 9:
    return 16;
   case 10:
    return 17;   
   case 11:
    return 19;   
   case 12:
    return 7;   
   case 13:
    return 4;   
   case 14:
    return 5;   
   case 15:
    return 6;   
   case 16:
    return 5;   
   case 17:
    return 1;   
   case 18:
    return 3;   
   case 19:
    return 7; 
   case 20:
    return 0;    
   case 21:
    return 4;   
   case 22:
    return 6;   
   case 23:
    return 2;      
   default:
    return -1;
  } 
 }else{
 
  switch (blockrotate) {
   case 0:
    return 3;
   case 1:
    return 0;
   case 2:
    return 1;
   case 3:
    return 2;
   case 4:
    return 18;
   case 5:
    return 16;
   case 6:
    return 17;
   case 7:
    return 19;
   case 8:
    return 16;
   case 9:
    return 17;
   case 10:
    return 19;   
   case 11:
    return 18;   
   case 12:
    return 5;   
   case 13:
    return 6;   
   case 14:
    return 7;   
   case 15:
    return 4;   
   case 16:
    return 1;   
   case 17:
    return 5;   
   case 18:
    return 7;   
   case 19:
    return 3; 
   case 20:
    return 4;    
   case 21:
    return 0;   
   case 22:
    return 2;   
   case 23:
    return 6;      
   default:
    return -1;
  }
 }
 return -1;
}

function slopeBlockToBeamOrientation(beamrotate, negative){
 //negative not implemented
 switch (beamrotate) {
  case 0:
  case 8:
   return 1;
  case 2:
  case 10:
   return 22;
  case 4:
  case 12:
   return 20;
  case 6:
  case 14:
   return 13;
  case 1:
  case 9:
   return 16;
  case 3:   
  case 11:
   return 0;   
  case 5:  
  case 13:
   return 12;   
  case 7:  
  case 15:
   return 18;   
  case 16:  
  case 20:
   return 8;   
  case 17:  
  case 22:
   return 9; 
  case 18:   
  case 21:
   return 11;   
  case 19:   
  case 23:
   return 10;      
  default:
   return -1;
 }
 return -1;
}

function quatMirror(quat){
	var resquat = stoa(quat);
	resquat[0] = -resquat[0];
	resquat[3] = -resquat[3];
	return atos(resquat);
}

function getMirrorData(blockID,position,rotation){
	var newRotation = rotationMirror(rotation);
	var newBlock = blockID;
	var pa=stoar(position);
	pa[0]=(-pa[0]);


	if((ItemDic[blockID])&&(getBlock(blockID))){
		var curBlock = getBlock(blockID);
		var xdiff=Math.round(curBlock.XDiff);

		if(curBlock.MirrorBlock){
			var tempBlock=ItemTable[curBlock.MirrorBlock];
			if(tempBlock.BlockId>=0){
				newBlock=tempBlock.BlockId;
				xdiff=Math.round((xdiff+tempBlock.XDiff)/2);	
				
			}
			
		}
		if(xdiff!=0){
			var q=getQuat(newRotation);
			var positionshift=posTransform([-xdiff,0,0],q);
			pa[0]+=positionshift[0];
			pa[1]+=positionshift[1];
			pa[2]+=positionshift[2];
		} 
	}
	pa[0]=Math.round(parseFloat(pa[0]));
	pa[1]=Math.round(parseFloat(pa[1]));
	pa[2]=Math.round(parseFloat(pa[2]));

	var strposition = atos(pa);

	var mirrordata={}
	mirrordata.blockID=newBlock;
	mirrordata.position=strposition;
	mirrordata.rotation=newRotation;
	return mirrordata;
}

function flipX(position){
	var pa=stoar(position);
	pa[0]=(-pa[0]);
	var strposition = ""+pa[0]+","+pa[1]+","+pa[2];
	return strposition;
}

function rotationMirror(blockrotate){
	var q=getQuat(blockrotate);
	if(q){
		q[0]=-q[0];
		q[3]=-q[3];
		return getRot(q);
	}else{
		return -1;
	}
}

//rotate block rotation
function blockRotate(blockrotate,dir){
	var q=getQuat(blockrotate);
	if(q){
		var q1=getQuat(dir); 
		return getRot(quatmul(q1,q));
	}else{
		return -1;
	}
}

//rotate block position
function positionRotate(position,dir){
	pa=stoar(position);
	return atos(posTransform(pa,getQuat(dir)));
}

//rotate block quat
function quatRotate(quat,dir){
	return atos(quatmul(getQuat(dir),stoa(quat)));
}

function sameSlopeBlockOrientation(rotate1,rotate2){
	if(rotate1==rotate2){
		return true;
	}
	var r1=Math.min(rotate1,rotate2);
	var r2=Math.max(rotate1,rotate2); 
	if((r1==0&&r2==8)||(r1==1&&r2==9)||(r1==2&&r2==10)||(r1==3&&r2==11)||(r1==4&&r2==12)||(r1==5&&r2==13)||(r1==6&&r2==14)||(r1==7&&r2==15)||(r1==16&&r2==20)||(r1==17&&r2==22)||(r1==18&&r2==21)||(r1==19&&r2==23)){
		return true;
	}else{
		return false;
	}
}


//download file
//text/plain
//application/json
function download(filename, data) {
    var blob = new Blob([data], {type: 'text/plain'});
    if(window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
    }
    else{
        var elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;        
        document.body.appendChild(elem)
        elem.click();        
        document.body.removeChild(elem);
    }
}

//check for numeric
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

//change colors to hex format
function rgb2hex(red, green, blue) {
	var rgb = blue | (green << 8) | (red << 16);
	return '#' + (0x1000000 + rgb).toString(16).slice(1)
}

//getblockdata
function getBlock(bid){
	return ItemTable[ItemDic[bid]];
}

function roundToTwo(num) {
    return +(Math.round(num + "e+2")  + "e-2");
}

function cleanBlueprint(blocks){
	var SClist=blocks.SCs;
	var blocklist=blocks.BlockIds;
	var blrlist=blocks.BLR;
	var blplist=blocks.BLP;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var bcilist=blocks.BCI; 
	var beilist=blocks.BEI;
	var blocknew=[];
	var blrnew=[];
	var blpnew=[];
	var bp1new=[];
	var bp2new=[];
	var bcinew=[];
	var beinew=[];
	var scnew=[];
	var newbeiindex=0;
	var currentIndex = 0;
	var beiIndex = 0;
	var newscindex=0;

	for(var scID = 0; scID < SClist.length; scID++){
		if(SClist[scID].ItemNumber>0){
			scnew[newscindex]=SClist[scID];
			newscindex++;
		}
	}

	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		if(blocklist[blockIndex]>=0){
			blocknew[currentIndex]=blocklist[blockIndex];
			blrnew[currentIndex]=blrlist[blockIndex];
			blpnew[currentIndex]=blplist[blockIndex];
			bp1new[currentIndex]=bp1list[blockIndex];
			bp2new[currentIndex]=bp2list[blockIndex];   
			bcinew[currentIndex]=bcilist[blockIndex];   

			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				beilist[beiIndex]=currentIndex;
				var beiIncrement = beilist[beiIndex+1]+2;
				for(var i=0;i<beiIncrement;i++){
					beinew[newbeiindex+i]=beilist[beiIndex+i];
				}
				beiIndex+=beiIncrement;
				newbeiindex+=beiIncrement;
			}
			currentIndex +=1;
		}else{
			//need to remove stringid references if block is removed
			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				var beiIncrement = beilist[beiIndex+1]+2;
				beiIndex+=beiIncrement;
			}
		}
		if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){
		var beiIncrement = beilist[beiIndex+1]+2;
		beiIndex+=beiIncrement;
		}
	}
	
	blocks.BlockIds=blocknew;
	blocks.BLR=blrnew;
	blocks.BLP=blpnew;
	blocks.BP1=bp1new;
	blocks.BP2=bp2new;
	blocks.BCI=bcinew;
	blocks.BEI=beinew;
	blocks.SCs=scnew;
}

function getType(blockid){
	var curBlock = getBlock(blockid);
	if(curBlock){
		return curBlock.ItemType;
	}else{
		return -1;
	}
}

function loadLinks(){
	$('#linklist').empty();
	for(var i=0;i<LinkList.length;i++){
		$('#linklist').append(LinkList[i]);
	}
	
}

</script>

<script>
loadLinks();

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77242087-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
