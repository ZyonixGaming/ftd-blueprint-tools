<!DOCTYPE html>
<html lang="en">
<head>
	<title>FTD Blueprint Modification Tool</title>
	<meta charset="utf-8">
	<link rel='shortcut icon' href='ico/favicon.ico' type='image/x-icon'>
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/css/theme.blue.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/2.1.3/toastr.min.css">
	<style>
		hr{
			width:90%;
		}
		.subtext{
			margin:4px;
		}
		.hidden{
			display:none;
		}
		.ui-header {
			background: #D0D0FF !important;
		}
		.ui-collapsible-content {
			margin-left:4px !important;
			margin-right:4px !important;
			padding: 0px;
		}
		.ui-collapsible-heading{
			margin-left:4px;
			margin-right:4px;
		}
		.ui-listview{
			margin: 0px !important;
		}
		.tablesorter-blue{
			margin:0 0;
			text-align: center;
		}
		#disqus_thread{
			margin: 0 0;
			padding: 0.8em;
		}
		#container{
			background-color:#8CCFFF;
		}
		.bigbox{
			width:22px;
			height:22px;
			vertical-align:middle;
		}
		.checkbox{
			margin: 0px;
			font-weight:bold !important;
			padding-top:12px;
			padding-left:8px;
			align:right;
			vertical-align:middle;
			display:inline;
		}
		.bold{
			font-weight:bold;		
		}		
		.ui-slider-track.ui-mini {
			margin-left:58px;
		}
		.box{
			border: 2px solid black;
		}
		.palettebutton, .cobutton, .ptbutton{
			width:24pt!important;
			height:24pt!important;
		}
			.sp-preview-inner{
			text-shadow: 1px 1px 2px white;
		}
		#popupallowedcolorbutton, #popuppaintcolorbutton, .camobutton, #deletebutton{
			z-index:1;
			padding-top:8pt!important;
			width:64pt!important;
			height:28pt!important;
			margin-top:8pt!important;
		}
		
		.deletebutton{
			background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAcCAIAAABeRy4FAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTCtCgrAAAACZUlEQVRYR9VWK1QCQRTlgMFgMBgIBKLBYDAQCCQOgUMiGAhGg9FgIxAIRAMNAoFAIBCIRIPBYCAQDAYDwWAgEJ6X92YWHcZlmV0Q7pkwO/Pm7dx75xej2GEX8/vgiq6dnqrK2Rnd39N4THuItzd6eKBkUk2Vi67NZtRuUzbrdVAuR53Oov3fgTl0u1QoLOd2dUXNptR1kwdoDwfgg7TDmbs7en1VvTuG/2S4cYWAQEjDBC8gk1lYtBtDAv6du3TEX7Bq8PKieiMH1A3uP8esIyCYz6nXs6zCry8VEBKQFgJDZi8/5IcJ/oZzpB4QEMY5cHJCt7f0/Kx6HQB1obHbGchDNiQgCG+Im+QGeKAe74b3d6pWKZVSSY6P6eaGnp5UrxWwC6bBOhkCM2HpZKJ6NwJnCEdAAEMGAyoW6ehIZbu4oMdH+vxUAQDMgUUwyvsjDISNGOsMzqPTRQKrIa2WRXLspfDghJESEIghpRLF4yo5Cur5PPX7oSQ3wJm3QAB7AMJDfsmcSKgKWq6vaTRSYeHBaaMjgBWPdY/VLwmxH7ArYAUkHw6pXF7ukPNzajRoOlUDncHZoiAAUSuVpeTpNNVqi/1g4OOD6vXF7CUM8WAFbs7gPCEIQEII6U0IAgecEAhjLf0kDGKgtyl4uBOBSGbgzN8DD9yEQORrQBBwBa6C44MR2NIu/AmfM+AvcKQvAZEckkgMRIr2HLTCOIVxLeJytBrCATYCchNtW3J/iCGXl2oCYohxD3LXbwIOj7Ntw/r4k5cIt2gCa19j/wvrW5Ar+lvKPkjuD8MQk8ABFvP7wEos9g0wx0tPcAGSdAAAAABJRU5ErkJggg==');
			background-size: 100% 100%;
		}
		#popupallowedcolor, #popuppaintcolor{
			max-width:356px;
		}
		#popupallowedcolorbutton-overlay, #popuppaintcolorbutton-overlay, #camo-big-overlay{
			padding-top:4pt!important;
		}
		.camo-small-overlay1{
			width:16pt!important;
			left:0!important;
		}
		.camo-small-overlay2{
			width:16pt!important;
			left:16pt!important;
		}
		.camo-small-overlay3{
			width:16pt!important;
			left:32pt!important;
		}
		.camo-small-overlay4{
			width:16pt!important;
			left:48pt!important;
		}
		.small-font{
			font-size:small;
		}
		tbody tr:nth-child(even) td:nth-child(odd){
			background: #E0E0F0
		}
		tbody tr:nth-child(odd) td:nth-child(even){
			background: #FFFFFF
		}
		tbody tr:nth-child(even) td:nth-child(even){
			background: #F0F0FF
		}
		tbody tr:nth-child(odd) td:nth-child(odd){
			background: #F0F0F0
		}
		.fullscreen{
			position: absolute;
			top: 12pt;
			left: 5%;
			width: 90%;
			z-index:10;
		}
		.fullscreen-overlay{
			position: absolute;
			top: 0;
			left: 0;
			width: 100%; height: 100%;
			z-index:4;
			display: none;
			background-color:rgba(10,10,10,0.4);
		}
		
		#expand{
			position: absolute;
			top:11px;
			  right: 12px;   /* must be equal to parent's right padding */
			  width:22px;
			  height:22px;
			display:none;
			z-index:9;

		}
		
		#expand:after{
			  position: absolute;
		}
		
		.mod-ac{
			display:none;
		}
		
		
	</style>
	<script src="js/links.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/js/jquery.tablesorter.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/js/widgets/widget-filter.min.js"></script>	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r80/three.min.js"></script>
	<script src="https://cdn.rawgit.com/ZyonixGaming/ftd-blueprint-tools/gh-pages/js/OrbitControls.js"></script>	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.1/pako_inflate.min.js"></script>	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.2/jszip.min.js"></script>		
	<script src="js/itemtable-AC.js"></script>
	<script src="js/preview3d.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.4.2/localforage.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/2.1.3/toastr.min.js">	</script>
	
	<script src="js/mcblockmapping.js"></script>
	<script src="js/sampleblueprint.js"></script>

<script>
//main scripts

localforage.config();
var QuatTable = {
  0:"0,0,0,1",1:"0,0.707106781186547,0,0.707106781186547",2:"0,1,0,0",3:"0,0.707106781186547,0,-0.707106781186547",4:"0.707106781186547,0,0,0.707106781186547",5:"0.5,0.5,-0.5,0.5",6:"0,-0.707106781186547,0.707106781186547,0",7:"-0.5,0.5,-0.5,-0.5",8:"0,-0.707106781186547,-0.707106781186547,0",9:"0.5,0.5,0.5,-0.5",10:"-0.707106781186547,0,0,0.707106781186547",11:"-0.5,0.5,0.5,0.5",12:"0,0,-1,0",13:"-0.707106781186547,0,-0.707106781186547,0",14:"1,0,0,0",15:"0.707106781186547,0,-0.707106781186547,0",16:"0,0,-0.707106781186547,0.707106781186547",17:"0.707106781186547,0.707106781186547,0,0",18:"0,0,0.707106781186547,0.707106781186547",19:"-0.707106781186547,0.707106781186547,0,0",20:"0.5,0.5,0.5,0.5",21:"0.5,-0.5,-0.5,0.5",22:"-0.5,0.5,-0.5,0.5",23:"-0.5,-0.5,0.5,0.5",}
var RotTable = {
  "0,0,0,1":0,"0,1,0,1":1,"0,1,0,0":2,"0,1,0,-1":3,"1,0,0,1":4,"1,1,-1,1":5,"0,1,-1,0":6,"1,-1,1,1":7,"0,1,1,0":8,"1,1,1,-1":9,"1,0,0,-1":10,"1,-1,-1,-1":11,"0,0,1,0":12,"1,0,1,0":13,"1,0,0,0":14,"1,0,-1,0":15,"0,0,1,-1":16,"1,1,0,0":17,"0,0,1,1":18,"1,-1,0,0":19,"1,1,1,1":20,"1,-1,-1,1":21,"1,-1,1,-1":22,"1,1,-1,-1":23}
var BeamAxisRot = [1,8,0];
var BeamAxisPriority = [3,2,1];



//maps block ID of block to beam

//maps block ID of beam to block
var maxc=[0,0,0,0];
var minc=[0,0,0,0];
var blockRenderData = {
}
var blockRenderIndex = 0;



//blockID:blockname
var nameID = {
}
//blockID:blockcount
var countID = {
}
var colorID = {
}
//blockname:blockcount
/*
var blockCountData = {
}
*/
//store stats
var totalstats = {
}

var blockFilterTable = {}

var singleFile=true;
var selectedFile
var ItemDic
//var CurrentBlueprint

var runningCount=0;
var runningTimeOut=120;

var currentBlueprints;
var currentFilenames;
var fileIndex = 0;	
var selectedIndex = 0;
var newPalette=[];

var selectedcolor
var allowedcolor = -1;
var tempallowedcolor = 0;
var temppaintcolor = 0;
var blocksBeamed = 0;
var blocksDebeamed = 0;
var colorTable=[];
var colorTableInverse=[];

$( document ).on("pageshow", function() {
  $("#version").text(ftdversion);
  $("#mod-ac-version").text(" + "+modacversion);
  (function(i,s,o,g,r,a,m){
	i['GoogleAnalyticsObject']=r;
	i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)}
	  ,i[r].l=1*new Date();
	a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];
	a.async=1;
	a.src=g;
	m.parentNode.insertBefore(a,m)
  }
  )(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-77242087-2', 'auto');
  ga('send', 'pageview');
  $(".lb").prop('disabled',false);
  $(".lb").parent().removeClass('ui-state-disabled');
  ga('send', 'event', 'bpmod', 'pageload');
  
 
  
  
});//pageshow
				
				
$( document ).on( "pageinit", function() {

  toastr.options.positionClass ="toast-bottom-left";
  $( ".lb" ).click(function() {
	$($(this).attr("btarget")).click();
  }
				  );
  $(function() {
	// simple reflow widget (table with 1 header row)
	$("#table1").tablesorter({
	  theme: 'blue',
	  widgets: ['reflow','filter'],
	  widgetOptions : {
		// class name added to make it responsive (class name within media query)
		reflow_className    : 'ui-table-reflow',
		// header attribute containing modified header name
		reflow_headerAttrib : 'data-name',
		// data attribute added to each tbody cell
		// it contains the header cell text, visible upon reflow
		reflow_dataAttrib   : 'data-title',
		filter_defaultFilter: {
		  0 : '~{query}' }
		,
		// include column filters
		filter_columnFilters: true,
		filter_placeholder: {
		  search : 'Search...' },		  
	  },	
	  selectorHeaders: "thead th",
	  sortList: [[1,1],[0,0]]
	});
		
  });
  
  /*
    $('#table1').bind('filterEnd', function(event, config){
		console.log($('#table1.hasFilters tbody tr:visible').length);
		
		$('#table1.hasFilters tbody tr:visible').each(function(){
			console.log($(this).attr("blockid"));
			console.log(ItemDic[$(this).attr("blockid")]);
		
		});
		
		
  });
  */
  
 
  
  $(function() {
	// simple reflow widget (table with 1 header row)
	$("#table2").tablesorter({
	  theme: 'blue',
	  widgets: ['reflow'],
	  widgetOptions : {
		// class name added to make it responsive (class name within media query)
		reflow_className    : 'ui-table-reflow',
		// header attribute containing modified header name
		reflow_headerAttrib : 'data-name',
		// data attribute added to each tbody cell
		// it contains the header cell text, visible upon reflow
		reflow_dataAttrib   : 'data-title',
	  },	
	  selectorHeaders: "thead th"
	});
  });
 

	$(function() {
	// simple reflow widget (table with 1 header row)
		$("#table3").tablesorter({
			theme: 'blue',
			widgets: ['reflow'],
			widgetOptions : {
			  // class name added to make it responsive (class name within media query)
			  reflow_className    : 'ui-table-reflow',
			  // header attribute containing modified header name
			  reflow_headerAttrib : 'data-name',
			  // data attribute added to each tbody cell
			  // it contains the header cell text, visible upon reflow
			  reflow_dataAttrib   : 'data-title',
			},	
			selectorHeaders: "thead th",
			headers:{
				'.nosort':{
					sorter:false
				}
			}
		});
	}); 
   
   
   
  //alert("Warning:\r\nThe interface is currently quite terrible and is being worked on.\r\nFor a simpler and easier to use interface, go to the 'Modification Tool with basic interface' page from the links provided (top left corner)");
  //palettetool
  $('.palettebutton').addClass("sp-preview");
  $('.palettebutton').each(function() {
	var index=$(".palettebutton").index( this );
	var palStr = "" + index;
	if (palStr.length<2){
	  palStr = "0" + palStr;
	}
	//$(this).text(index);
	var indextext=index;
	if(index==28){
	  indextext="Dt"
	}
	else if(index==29){
	  indextext="Tr"
	}
	else if(index==30){
	  indextext="Sc"
	}
	else if(index==31){
	  indextext="Mn"
	}
	$(this).append("<div id=\"pal-overlay-"+index+"\" class=\"sp-preview-inner color-overlay-"+index+"\">"+indextext+"</div>");
	//$( ".pal-overlay-"+index).css('background-color', 'red');
	$("#pal"+palStr).addClass("sp-preview");
	$("#co"+palStr).addClass("sp-preview");
	//document.getElementById("pal" + palStr).style.backgroundColor = colorTable[palID];
	//document.getElementById("pal" + palStr).style.color = colorTableInverse[palID];
	//document.getElementById("co" + palStr).style.backgroundColor = colorTable[palID];
	//document.getElementById("co" + palStr).style.color = colorTableInverse[palID];
	$(this).spectrum({
	  showInput: true,
	  showAlpha: true,
	  preferredFormat: "rgb",
	  showInitial: true,
	  color: $( "#pal-overlay-"+index).css("background-color"),
	  change: function(color) {
		$( ".color-overlay-"+index).css('background-color', color);
		//console.log(color);
		if(tempallowedcolor==index){
		  $( "#popupallowedcolorbutton-overlay" ).css("background-color",$('#co-overlay-'+index).css("background-color"));
		}
		if(temppaintcolor==index){
		  $( "#popuppaintcolorbutton-overlay" ).css("background-color",$('#pt-overlay-'+index).css("background-color"));
		}
		if(colorTable2[index]){
		  colorTable2[index].colorS=color.toRgbString();
		  var temprgba=color.toRgb();
		  var tempr= +(temprgba.r/255).toFixed(2);
		  var tempg= +(temprgba.g/255).toFixed(2);
		  var tempb= +(temprgba.b/255).toFixed(2);
		  var tempa= +temprgba.a.toFixed(2);
		  colorTable2[index].colorN=[tempr,tempg,tempb,tempa];
		  //console.log(colorTable2[index].colorN);
		  colorTable2[index].changed=true;
		}
		else{
		  var temprgba=color.toRgb();
		  var tempr= +(temprgba.r/255).toFixed(2);
		  var tempg= +(temprgba.g/255).toFixed(2);
		  var tempb= +(temprgba.b/255).toFixed(2);
		  var tempa= +temprgba.a.toFixed(2);
		  //console.log(colorTable2[index].colorN);
		  var temprgba=color.toRgb();
		  colorTable2[index]={
			colorA: [0,0,0,0],
			colorN: [tempr,tempg,tempb,tempa],
			colorS: color.toRgbString(),
			changed:true
		  }
		}
	  }
	  ,
	  beforeShow: function(color) {
		$(this).spectrum("set", $( "#pal-overlay-"+index).css("background-color"));
	  }
	}
					);
  }
						  );
  $('.cobutton').addClass("sp-preview");
  $('.cobutton').each(function() {
	var index=$(".cobutton").index( this );
	//$(this).text(index);
	var indextext=index;
	if(index==28){
	  indextext="Dt"
	}
	else if(index==29){
	  indextext="Tr"
	}
	else if(index==30){
	  indextext="Sc"
	}
	else if(index==31){
	  indextext="Mn"
	}
	$(this).append("<div id=\"co-overlay-"+index+"\" class=\"sp-preview-inner color-overlay-"+index+"\">"+indextext+"</div>");
	//$( ".pal-overlay-"+index).css('background-color', 'red');
	$(this).click(function(a){
	  $( "#popupallowedcolorbutton-overlay" ).html(indextext);
	  $( "#popupallowedcolorbutton-overlay" ).css("background-color",$('#co-overlay-'+index).css("background-color"));
	  tempallowedcolor=index;
	  $( "#popupallowedcolor" ).popup( "close" );
	});
  });
  
  $( "#popupallowedcolorbutton" ).addClass("sp-preview");
  $( "#popupallowedcolorbutton" ).append("<div id=\"popupallowedcolorbutton-overlay\" class=\"sp-preview-inner\">"+0+"</div>");
  $( "#popupallowedcolorbutton" ).click(function(a){
	$( "#popupallowedcolor" ).popup( "open",{x:32,positionTo:"#popupallowedcolorbutton"});
  });
  $('.ptbutton').addClass("sp-preview");
  $('.ptbutton').each(function() {
	var index=$(".ptbutton").index( this );
	//$(this).text(index);
	var indextext=index;
	if(index==28){
	  indextext="Dt"
	}
	else if(index==29){
	  indextext="Tr"
	}
	else if(index==30){
	  indextext="Sc"
	}
	else if(index==31){
	  indextext="Mn"
	}
	$(this).append("<div id=\"pt-overlay-"+index+"\" class=\"sp-preview-inner color-overlay-"+index+"\">"+indextext+"</div>");
	//$( ".pal-overlay-"+index).css('background-color', 'red');
	$(this).click(function(a){
	  $( "#popuppaintcolorbutton-overlay" ).html(indextext);
	  $( "#popuppaintcolorbutton-overlay" ).css("background-color",$('#pt-overlay-'+index).css("background-color"));
	  temppaintcolor=index;
	  $( "#popuppaintcolor" ).popup( "close" );
	}
				 );
  }
					 );
  $( "#popuppaintcolorbutton" ).addClass("sp-preview");
  $( "#popuppaintcolorbutton" ).append("<div id=\"popuppaintcolorbutton-overlay\" class=\"sp-preview-inner\">"+0+"</div>");
  $( "#popuppaintcolorbutton" ).click(function(a){
	$( "#popuppaintcolor" ).popup( "open",{
	  y:32,positionTo:"#popuppaintcolorbutton"}
								 ) ;
  }
									 );
  $('.camobutton').each(function() {
	var index=$(".camobutton").index( this );
	//$(this).text(index);
	$(this).click(function(a){
	  $( "#popuppaintcolorbutton-overlay" ).css("background-color","rgba(0,0,0,0)");
	  $( "#popuppaintcolorbutton-overlay" ).html($(this).html());
	  temppaintcolor=index+32;
	  $( "#popuppaintcolor" ).popup( "close" );
	}
				 );
  }
					   );
					   				   

	$('#deletebutton').click(function(a){
	  $( "#popuppaintcolorbutton-overlay" ).css("background-color","rgba(0,0,0,0)");
	  $( "#popuppaintcolorbutton-overlay" ).html($(this).html());
	  temppaintcolor=34;
	  $( "#popuppaintcolor" ).popup( "close" );
	});  
					   
  $('#palettelist').change(function(a){
	if($(this).val()){
	  loadPalette($(this).val());
	}
  });

  loadPalettes();
}); //pageinit

//not needed now with static table
//pos as [x,y,z] quat as[x,y,z,w]
// transforms co-ordinate pos by the quaternion quat
function posTransform(pos,quat){
  var p = [pos[0],pos[1],pos[2],0];
  var transpos = quatmul(quat,quatmul(p,quatconj(quat)));
  return [Math.round(transpos[0]),Math.round(transpos[1]),Math.round(transpos[2])]
}
function posTransformNR(pos,quat){
  var p = [pos[0],pos[1],pos[2],0];
  var transpos = quatmul(quat,quatmul(p,quatconj(quat)));
  return [(transpos[0]),(transpos[1]),(transpos[2])]
}
//combining 2 quat transforms e.g. q1 then q2 = applying q2*q1 or quatmul(q2,q1);
function atos(a){
  var s="";
  if(a){
	s=""+a[0];
  }
  for (var i=1;i<a.length;i++){
	s=s + "," + a[i];
  }
  return s;
}
function stoa(s){
  try{
	var temp=s.split(",");
	return [parseFloat(temp[0]),parseFloat(temp[1]),parseFloat(temp[2]),parseFloat(temp[3])];
  }
  catch(e){
	//console.log("s="+s);
	return [0,0,0,0];
  }
}
function stoa3(s){
  var temp=s.split(",");
  return [parseFloat(temp[0]),parseFloat(temp[1]),parseFloat(temp[2])];
}
function stoar(s){
  var temp=s.split(",");
  return [Math.round(parseFloat(temp[0])),Math.round(parseFloat(temp[1])),Math.round(parseFloat(temp[2]))];
}
function getQuat(rotation){
  return JSON.parse("[" + QuatTable[rotation] + "]");
}
function getRot(quat){
  var quatstr=atos(getquatformatted(quat));
  return RotTable[quatstr];
}
//quat as array
function getquatformatted(quat){
  var q=[quat[0],quat[1],quat[2],quat[3]];
  var r = Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]);
  q[0]=Math.round(q[0]*r);
  q[1]=Math.round(q[1]*r);
  q[2]=Math.round(q[2]*r);
  q[3]=Math.round(q[3]*r);
  for(var i=0;i<4;i++){
	if(q[i]>0){
	  break;
	}
	else if(q[i]<0){
	  q=quatneg(q);
	  break;
	}
  }
  return q;
}
//quat as array
function getquatnormalized(quat){
  var q=[quat[0],quat[1],quat[2],quat[3]];
  var r = Math.sqrt(Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]));
  q[0]=q[0]/r;
  q[1]=q[1]/r;
  q[2]=q[2]/r;
  q[3]=q[3]/r;
  return q;
}
//quat in x, y, z, w
function quatneg(q){
  return[-q[0],-q[1],-q[2],-q[3]];
}
//quat in x, y, z, w
function quatconj(q){
  return[-q[0],-q[1],-q[2],q[3]];
}
//quat in x, y, z, w
function quatmul(q,r){
  return [q[3] * r[0] + q[0] * r[3] + q[1] * r[2] - q[2] * r[1],
		  q[3] * r[1] - q[0] * r[2] + q[1] * r[3] + q[2] * r[0],
		  q[3] * r[2] + q[0] * r[1] - q[1] * r[0] + q[2] * r[3],
		  q[3] * r[3] - q[0] * r[0] - q[1] * r[1] - q[2] * r[2]];
}
function loadLinks(){
  $('#linklist').empty();
  for(var i=0;i<LinkList.length;i++){
	$('#linklist').append(LinkList[i]);
  }
}
function loadError(message){
  if(message){
	alert(message);
  }
  else{
	alert("failure");
  }
}

function openFile(source) {

  var selectedFiles = document.getElementById(source).files;
  if (selectedFiles==undefined||selectedFiles.length==undefined||selectedFiles.length<=0){
	return;
  }
	$.mobile.loading("show", {
		text: "Loading...",
		textVisible: true,
		textonly: true,
	});
  

  var selectedFile;
  var outputstring = "";
  currentBlueprints=[];
  currentFilenames=[];  
  fileIndex = 0;
  runningCount = selectedFiles.length;
  ga('send', 'event', 'bpmod', 'openfile', source,runningCount);
  runningTimeOut = 150*runningCount;  
  $("#table3 tbody").empty();
  for(var fi=0;fi<selectedFiles.length;fi++){
	selectedFile=selectedFiles[fi];
	if (selectedFile){		
		var reader = new FileReader();
		reader.fileName = selectedFile.name;
		reader.selectIndex = fi;
		if(reader.fileName.substr(reader.fileName.lastIndexOf('.')+1).toLowerCase()=="schematic"){
			reader.onload = function(evt) {
				if(evt){
					currentFilenames[fileIndex]=this.fileName+".blueprint";

					var currentData=[];					
					var readresult=new Uint8Array(evt.target.result);
					currentData = pako.inflate(readresult);

					if(!(currentData[0]==10&&currentData[1]==0&&currentData[2]==9)){
						console.log("wrong file format!");
						runningCount -=1;
					}else{
					
						currentBlueprints[fileIndex]=processMC(currentData,this.fileName);
						
						
						if(fileIndex==0){
							singleFile=true;
							outputstring +=  "<tr><td class='bplist bold'>" + this.fileName  + "</b></td></tr>";
							$("#renderpanel").collapsible("collapse");
							selectedIndex=fileIndex;					
							processData(selectedIndex);
						}else{
							singleFile=false;
							outputstring +=  "<tr><td class='bplist'>" + this.fileName  + "</td></tr>";
						}
						fileIndex++;						
					}					

				}
				runningCount -=1;
			}
			reader.readAsArrayBuffer(selectedFile);		
		}
		else{
			reader.onload = function(evt) {
				if(evt){
					currentFilenames[fileIndex]=this.fileName;
					currentBlueprints[fileIndex]=JSON.parse(evt.target.result);
					
					
								
					//if(this.selectIndex==0){
					if(fileIndex==0){
						singleFile=true;
						outputstring +=  "<tr><td class='bplist bold'>" + this.fileName  + "</b></td></tr>";
						$("#renderpanel").collapsible("collapse");
						selectedIndex=fileIndex;					
						processData(selectedIndex);
					}else{
						singleFile=false;
						outputstring +=  "<tr><td class='bplist'>" + this.fileName  + "</td></tr>";
					}
					fileIndex++;
					
				}
				runningCount -=1;
			}
			reader.readAsText(selectedFile);		
		
		}		
	}
  }
  document.getElementById(source).value="";
  
	function waitRunning() {
		
		if((runningCount>0)&&(runningTimeOut>0)) {
			console.log("loading blueprints...");
			runningTimeOut-=1;
			setTimeout(waitRunning, 50);
			return;
		}else{
			console.log("blueprints loaded.");
			if(runningCount>runningTimeOut){
				console.log("Time Out during processing.");
			}
			if(fileIndex>0){
			
				$("#table3 tbody").append(outputstring); 

				$("#table3").trigger("update");
				
				$(".bplist").each(function(){
					$(this).click(function(){
						$(".bplist").removeClass('bold');
						selectedIndex=$(".bplist").index($(this));
						processData(selectedIndex);
						$(this).addClass('bold');
					});
				});
				
				$("#blueprintpanel").collapsible("expand");
				if(singleFile){				
					$('.singleonly').show();
					$('.multionly').hide();
				}else{
					$('.singleonly').hide();
					$('.multionly').show();				
				}
				
				$(".dl").prop('disabled',false);
				$(".dl").parent().removeClass('ui-state-disabled');	
			}
			$.mobile.loading( "hide" );	
			
		}
	}
	waitRunning();
		
	
	return true;  

};



function processData(fi){
 //console.log("fi "+fi);
  var CurrentBlueprint=currentBlueprints[fi];
  var selectedFileName=currentFilenames[fi];
  nameID = {
  }
  countID = {
  }
  /*
  blockCountData = {
  }
  */
  ItemDic =  CurrentBlueprint.ItemDictionary;
  $("#table1 tbody").empty();
  $("#table2 tbody").empty();
  //document.getElementById("container").innerHTML="";
  document.getElementById("filecontent").style.display="none";
  alreadyrender=false;
  $(".mod-ac").hide();
  for(var key in ItemDic) {
	var keyint = parseInt(key);
	var val = ItemDic[keyint];
	if(val=="96ae1b17-7b4f-4878-aae5-7f3aa378ae29"){	
	   $(".mod-ac").show();
	}
	if(ItemTable[val]){
	  nameID[keyint]=(ItemTable[val]).Name;
	  ItemTable[val].BlockId=keyint;
	  colorID[keyint]=(ItemTable[val]).lodcol;
	}
	else{
	  nameID[keyint]=val;
	  colorID[keyint]=[80,80,80,1];
	}
	countID[keyint]=0;
	


	for(var mat in shapedBlocks){
	  var tempindex = shapedBlocks[mat].blockGuid;
	  var matID = tempindex[val];
	  if(matID!==undefined){
		shapedBlocks[mat].blockIds[matID] = keyint;
	  }
	}
  }

  totalstats = {
	"Block Count":0,
	"Material Cost":0,
	"Volume":0,
	"Max Power*":0,
	"Max Battery Capacity*":0,
	"Max Ammo Capacity*":0,
	"Max Fuel Capacity*":0, 
	"Game Version*":"unknown",
	"Blueprint Modified*":false,
  }
  countblocks(CurrentBlueprint.Blueprint);
  totalstats["Volume"]=roundToTwo(totalstats["Volume"]);
  getpalette(CurrentBlueprint.Blueprint);
  getpalette2(CurrentBlueprint.Blueprint);
  var outputstring = "";
  var totalcount = 0;
  for(var blockID in countID) {
	if(countID[blockID] >0) {
	  //blockCountData[nameID[blockID]] =  countID[blockID];
	  totalcount+=countID[blockID];
	  outputstring +=  "<tr blockid='"+blockID+"'><td>" + nameID[blockID]  + "</td><td><b>" + countID[blockID] + "</b></td></tr>";
	}
  }
  totalstats["Block Count"] = totalcount;
  /*
  keysSorted = Object.keys(blockCountData).sort(function(b,a){
	return blockCountData[a]-blockCountData[b]
  });
	
  for (var bName in keysSorted){
	outputstring +=  "<tr><td>" + keysSorted[bName]  + "</td><td><b>" + blockCountData[keysSorted[bName]] + "</b></td></tr>";
  }
  */
  $("#table1 tbody").append(outputstring);
  $("#table1").trigger("update");
  $("#blockcountpanel").collapsible("expand");
  var statisticsString = "";
  for (var stats in totalstats){
	statisticsString +=  "<tr><td>" + stats  + "</td><td><b>" + totalstats[stats] + "</b></td></tr>";
  }
  $("#table2 tbody").append(statisticsString);
  $("#table2").trigger("update");
  $("#blockstatpanel").collapsible("expand");
  $(".b1name").html(selectedFileName);
  $("#palettename").val("");
  $( "#renderpanel" ).collapsible({
	expand: function( event, ui ) {
	  if(!alreadyrender){
		//$("#container").width($("#renderpanel").innerWidth());
		$.mobile.loading("show", {
		  text: "Processing...",
		  textVisible: true,
		  textonly: true,
		}
						);
		setTimeout(function(){
		  alreadyrender=true;
		  init();
		  ga('send', 'event', 'bpmod', 'render', 'new');
		  $.mobile.loading("hide");
		}
				   , 200);
	  }else{
		onWindowResize();
	  }


	},
	collapse: function(event,ui){
		 $("#renderpanel").removeClass("fullscreen");
		 $(".fullscreen-overlay").hide();
		 $("#expand").show();
		 //console.log("oops");
	}
  });
  
  if(!($("#renderpanel").collapsible( "option", "collapsed"))){
	if(!alreadyrender){
	  //$("#container").width($("#renderpanel").innerWidth());
	  setTimeout(function(){
		alreadyrender=true;
		ga('send', 'event', 'bpmod', 'render', 'reload');
		init();
	  }
				 , 200);
	}
  }
  
  
		$("#renderpanel").removeClass("fullscreen");
		 $(".fullscreen-overlay").hide();
		 $("#expand").show();
  
	  $(".fullscreen-overlay").click(function(){
		 $("#renderpanel").removeClass("fullscreen");
		 $(".fullscreen-overlay").hide();
		 $("#expand").show();
		 if(alreadyrender){
			onWindowResize();
		 }		 
	  });

	  
	  $("#expand").click(function(event){
		  event.stopPropagation()
		  $(".fullscreen-overlay").show();
		  $("#renderpanel").addClass("fullscreen");	  
		  $("#expand").hide();
		  $("#renderpanel").collapsible("expand");
		  //console.log("expand");
		  
	  });  
  
  
  
  //$(".dl").prop('disabled',false);
  //$(".dl").parent().removeClass('ui-state-disabled');
  return true;
}
//convert blocks between materials. also changes shield color.


//get array of to represent block rotation
function getDirectionArray(rotation){
  if(rotation==0||rotation==16||rotation==12||rotation==18){
	return [0,0,1];
  }
  else if(rotation==2||rotation==17||rotation==14||rotation==19){
	return [0,0,-1];
  }
  else if(rotation==8||rotation==9||rotation==10||rotation==11){
	return [0,1,0];
  }
  else if(rotation==4||rotation==5||rotation==6||rotation==7){
	return [0,-1,0];
  }
  else if(rotation==1||rotation==20||rotation==13||rotation==22){
	return [1,0,0];
  }
  else if(rotation==3||rotation==21||rotation==15||rotation==23){
	return [-1,0,0];
  }
  else{
	return false;
  }
}

function getAxis(axis,neg){
  var tempaxis=[0,0,0];
  if(neg){
	tempaxis[axis]=-1;
  }
  else{
	tempaxis[axis]=1;
  }
  return tempaxis;
}
//optimize


function processMC(currentData,filename){
	var vp=(JSON.parse(JSON.stringify(sampleBlueprint)));
	var bp=vp.Blueprint;
	bp.Name=(filename.split("."))[0];
	bp.BlockIds=[];
	bp.BLR=[];
	bp.BCI=[];
	bp.BP1=[];
	bp.BP2=[];
	bp.BLP=[];
	//CurrentBlueprint.Blueprint
	var arrayindex=3;
	var blockindex=0;
	var dataindex=0;
	var bpblockindex=0;
	var width=0;
	var height=0;
	var length=0;
	var block=false;
	var data=false;
	//Width
	//Height
	//Length
	//Blocks
	//Data
	while(arrayindex<currentData.length){
		if(!width&&isString(arrayindex,"Width",currentData)){
			width=(currentData[arrayindex+5]*256)+currentData[arrayindex+6];
			arrayindex+=6;
			//alert("width="+width);
		}else if(!height&&isString(arrayindex,"Height",currentData)){
			height=(currentData[arrayindex+6]*256)+currentData[arrayindex+7];
			arrayindex+=7;
			//alert("height="+height);
		}else if(!length&&isString(arrayindex,"Length",currentData)){
			length=(currentData[arrayindex+6]*256)+currentData[arrayindex+7];
			arrayindex+=7;
			//alert("length="+length);
		}else if(!block&&isString(arrayindex,"Blocks",currentData)){
			block=[];
			var blockstart=arrayindex+10;
			var blocklength=(currentData[arrayindex+6]*256*256*256)+(currentData[arrayindex+7]*256*256)+(currentData[arrayindex+8]*256)+(currentData[arrayindex+9]);
			var blockend=blockstart+blocklength;
			block=currentData.slice(blockstart,blockend);
			//alert("blocklength = " + block.length);
			arrayindex=blockend;
		}else if(!data&&isString(arrayindex,"Data",currentData)){
			if(currentData[arrayindex-1]!=4){
				arrayindex++;
				continue;
			}
			data=[];
			var datastart=arrayindex+8;
			var datalength=(currentData[arrayindex+4]*256*256*256)+(currentData[arrayindex+5]*256*256)+(currentData[arrayindex+6]*256)+(currentData[arrayindex+7]);
			var dataend=datastart+datalength;
			data=currentData.slice(datastart,dataend);
			//alert("datalength = "+ data.length);
			arrayindex=dataend;
		}
		if(width&&height&&length&&block&&data){
			break;
		}
	
		arrayindex++;
	}
	if(((width*height*length)!=data.length)||((width*height*length)!=block.length)){
		//alert("possible mismatch!");
	}
	
	for (var y=0;y<height;y++){
		for(var z=0;z<length;z++){
			for(var x=0;x<width;x++){
				var tempindex=(y*length*width)+(z*width)+x;				
				if(block[tempindex]){
					var mcblock=block[tempindex];
					var mcblockdata=0;
					if(data[tempindex]){
						mcblockdata=data[tempindex];
					}
					//default to metal,0
					
					//var ftdblock=369;//metal
					var ftdblock=-1;//default to nothing
					var ftdcolor=0;
					var ftdrotate=0;
					if(mcConvertTable[mcblock]){
						if(mcConvertTable[mcblock][mcblockdata]){
							ftdblock=mcConvertTable[mcblock][mcblockdata][0];
							ftdcolor=mcConvertTable[mcblock][mcblockdata][1];
							ftdrotate=mcConvertTable[mcblock][mcblockdata][2];
						}else if(mcConvertTable[mcblock][0]){
							ftdblock=mcConvertTable[mcblock][0][0];
							ftdcolor=mcConvertTable[mcblock][0][1];
							ftdrotate=mcConvertTable[mcblock][0][2];						
						}else{
							//donothing
						}
					}
					
					if(ftdblock>=0){
						//might need to process data better to set block type and color and maybe even orientation
						bp.BlockIds[bpblockindex]=ftdblock; //metal block. might need to make more dynamic in future.
						bp.BLR[bpblockindex]=ftdrotate;
						bp.BCI[bpblockindex]=ftdcolor; //color. Might need to change depending on blockID in future;
						bp.BP1[bpblockindex]="0,0,0,0";
						bp.BP2[bpblockindex]="0,0,0,0";
						bp.BLP[bpblockindex]=atos([-x,y,z]);//might need to change in future to centralize it;
						bpblockindex+=1;					
					
					}


				}
			
			}
		
		
		}
	
	}
	//download("test.txt",JSON.stringify(vp));
	return vp; 
};



function updateBluePrint(fi){


	var GuidToID= {}
	var localShapedBlocks

	//maps block ID of block to beam
	var blockToBeam = {}
	var blockToBeam2m = {}
	var blockToBeam3m = {}

	//maps block ID of beam to block
	var beamToBlock = {}
	var beamToBlock2m = {}
	var beamToBlock3m = {}


	var slopeBlockToBeam = {}
	var slopeBeamToBlock = {}
	var slopeBeamToBlockM = {}

	//maintains a list of blockID:newBlockID to facilitate switching blocks via convertblocks() function
	var conversionIndex = {}

	//maintains a list of blockID to keep via clearhull() function
	var keepIndex = {}

	//maintains a list of blockID to determine color changes via colorblocks() function
	var blockColorIndex = {}
	var replaceOldIndex = {}

	//blockID:blockname
	var nameID = {} //change shield color changer

	var ItemDic

	var selectedcolor

	var allowedcolor = -1;

	var CurrentBlueprint=currentBlueprints[fi];
	var CurrentFilename=currentFilenames[fi];
	
	function localProcessData(){
	 //getblockdata

		


	 nameID = {} //change how shield blocks are detected
		
	 
	 ItemDic =  CurrentBlueprint.ItemDictionary;
	 

	 var a1;
	 var a2;
	 var b1;
	 var b2;
	 var c1;
	 var c2;
	 var d1;
	 var d2;
	 var e1;
	 var e2;
	 var f1;
	 var f2;
	 var g1;
	 var g2;
	 
	 var a2m;
	 var a3m;
	 var b2m;
	 var b3m;
	 var c2m;
	 var c3m;
	 var d2m;
	 var d3m;
	 var g2m;
	 var g3m;
	 
	 //for sloped blocks
	 var aa1=-1;
	 var aa2=-1;
	 var aa3=-1;
	 var ab1=-1;
	 var ab2=-1;
	 var ab3=-1;
	 var ac1=-1;
	 var ac2=-1;
	 var ac3=-1;
	 var ad1=-1;
	 var ad2=-1;
	 var ad3=-1;
	 var ae1=-1;
	 var ae2=-1;
	 var ae3=-1;
	 
	 var kca1,kca2,kcas1,kcas2,kcas3;
	 
	 
	 blockToBeam={};
	 beamToBlock={};
	 blockToBeam2m={};
	 blockToBeam3m={};
	 beamToBlock2m={};
	 beamToBlock3m={};


	 
	 slopeBlockToBeam={};
	 slopeBeamToBlock={};
	 slopeBeamToBlockM={};
	  
	 
	 for(var key in ItemDic) {
	  var keyint = parseInt(key);
	  var val = ItemDic[keyint];
	  if(ItemTable[val]){
	   nameID[keyint]=(ItemTable[val]).Name;
	   //ItemTable[val].BlockId=keyint;
	   GuidToID[val]=keyint;					   
	  }else{
	   nameID[keyint]=val;
	  }
	  
	  if (val=="9a0ae372-beb4-4009-b14e-36ed0715af73"){
	   a1=keyint;//woodblock
	  }else if(val=="05475442-0e52-4e0b-9fbb-2715f0e54f97"){
	   a2=keyint;//woodbeam
	  }else if(val=="ab699540-efc8-4592-bc97-204f6a874b3a"){
	   b1=keyint;//metalblock
	  }else if(val=="a7f5d8de-4882-4111-9d01-436493e5b2d8"){
	   b2=keyint;//metalbeam
	  }else if(val=="3cc75979-18ac-46c4-9a5b-25b327d99410"){
	   c1=keyint;//alloyblock
	  }else if(val=="9411e401-27da-4546-b805-3334f200f055"){
	   c2=keyint;//alloybeam
	  }else if(val=="2d519ca8-1f12-4a8e-9340-aa6648b5e799"){
	   d1=keyint;//glassblock
	  }else if(val=="395179c1-37a0-4250-851b-5bc19fd601b6"){
	   d2=keyint;//glassbeam
	  }else if(val=="e71e6f97-fbe8-4bf5-9645-d15179ba0c17"){
	   e1=keyint;//leadblock
	  }else if(val=="f5d2db25-114e-473a-8313-96831ccd011e"){
	   e2=keyint;//leadbeam
	  }else if(val=="710ee212-563b-42f8-acd1-57515479524d"){
	   f1=keyint;//stoneblock
	  }else if(val=="c7a19161-b361-4074-8c51-2398a0a70d1b"){
	   f2=keyint;//stonebeam
	  }else if(val=="0c03433e-8947-4e7d-9dec-793526fe06d1"){
	   g1=keyint;//heavyarmour block
	  }else if(val=="867cea4e-6ea4-4fe2-a4a1-b6230308f8f1"){
	   g2=keyint;//heavyarmour beam
	  }else if(val=="bdafa446-f615-49cb-94f3-d7652dde6cec"){
	   aa1=keyint;//wood
	  }else if(val=="2ee817c1-f2a3-407a-847d-b97ffb844e45"){
	   aa2=keyint;//wood
	  }else if(val=="d077c2a4-4578-4965-9318-c14bb7ac1bd6"){
	   aa3=keyint;//wood
	  }else if(val== "5548037e-8428-43f8-bcb6-d730dbcd0a79"){
	   ab1=keyint;//metal
	  }else if(val== "0d554a9d-7d06-48b3-8aea-ffaeaa30380a"){
	   ab2=keyint;//metal
	  }else if(val== "e5d065f6-907b-450d-b998-213cdc54eec1"){
	   ab3=keyint;//metal
	  }else if(val=="911fe222-f9b2-4892-9cd6-8b154d55b2aa"){
	   ac1=keyint;//alloy
	  }else if(val=="9af822b3-80d9-46bd-9ce0-e6e5c2e61da4"){
	   ac2=keyint;//alloy
	  }else if(val=="b5d46bb7-d49e-42f6-817b-323fbf6d62b0"){
	   ac3=keyint;//alloy
	  }else if(val=="174b5b41-b70e-485d-b00a-a61cc9826b2c"){
	   ad1=keyint;//glass
	  }else if(val=="35abb89b-33b8-4cb4-b3d0-ee132247de8d"){
	   ad2=keyint;//glass
	  }else if(val=="0c64d302-c6df-42eb-a0ff-7c90f867ba4b"){
	   ad3=keyint;//glass
	  }else if(val=="78b81c0a-44df-4c24-b2a5-5d273737da60"){
	   ae1=keyint;//heavyarmour
	  }else if(val=="6e5c9f1d-160b-49b1-9b74-606d2f695c7e"){
	   ae2=keyint;//heavyarmour
	  }else if(val=="c61c1c19-cc53-49a2-b207-9de6b9ce328a"){
	   ae3=keyint;//heavyarmour
	  }else if(val=="de36c624-8c78-4b52-8d86-431cec16a306"){
	   a2m=keyint;//woodbeam
	  }else if(val=="39553630-8281-40e4-96fb-b01c1f3537e6"){
	   a3m=keyint;//woodbeam
	  }else if(val=="2a22f176-01c2-42f2-a7d2-2c7054504aa9"){
	   b2m=keyint;//metalbeam
	  }else if(val=="46f54639-5f91-4731-93eb-e5c0a7460538"){
	   b3m=keyint;//metalbeam
	  }else if(val=="8f9dbf41-6c2d-4e7b-855d-b2432c6942a2"){
	   c2m=keyint;//alloybeam
	  }else if(val=="649f2aec-6f59-4157-ac01-0122ce2e6dad"){
	   c3m=keyint;//alloybeam
	  }else if(val=="aa355fd9-295c-43f3-9f11-7a781a9808b0"){
	   d2m=keyint;//glassbeam
	  }else if(val=="049b9d0c-1cb3-4511-be7f-9fad6e0a607e"){
	   d3m=keyint;//glassbeam
	  }else if(val=="242e07fa-399f-4caa-bfc2-1b77bd2bd538"){
	   g2m=keyint;//heavyarmour beam
	  }else if(val=="49714981-369a-4158-aff6-e562ee5f98d5"){
	   g3m=keyint;//heavyarmour beam
	  }else if(val=="96ae1b17-7b4f-4878-aae5-7f3aa378ae29"){
	   kca1=keyint;//after cat kca block
	  }else if(val=="8a521c5d-ed3e-4013-b973-add51d8abf81"){
	   kca2=keyint;//after cat kca beam 4m
	  }else if(val=="c7c660a6-c9e2-48d5-8947-e73e9474f84f"){
	   kcas1=keyint;//after cat kca slope
	  }else if(val=="6ff9df4c-6daa-4f86-bd19-5ef1125f827f"){
	   kcas2=keyint;//after cat kca slope 4m
	  }else if(val=="63d66024-1a53-4dd8-a0df-8d2b0fbf6566"){
	   kcas3=keyint;//after cat kca slope 4m mirrored
	  }
	  



	  
	 /*
	  for(var mat in shapedBlocks){
	   var tempindex = shapedBlocks[mat].blockGuid; 
	   var matID = tempindex[val];
		if(matID!==undefined){	
		 shapedBlocks[mat].blockIds[matID] = keyint;
		}
	  }
	  */
	  
	 }
	 
	 localShapedBlocks={};
	 
	 for(var mat in shapedBlocks){
		localShapedBlocks[mat]=new Array(shapedBlocks[mat].blockIds.length);
		for(var key in shapedBlocks[mat].blockGuid){
			localShapedBlocks[mat][shapedBlocks[mat].blockGuid[key]]=GuidToID[key];
		}
	}
					 
	 
	 blockToBeam[a1]=a2;
	 beamToBlock[a2]=a1;
	 if(a2m&&a3m){
		blockToBeam2m[a1]=a2m;
		blockToBeam3m[a1]=a3m;
		beamToBlock2m[a2m]=a1;	
		beamToBlock3m[a3m]=a1;	
	 }
	 blockToBeam[b1]=b2;
	 beamToBlock[b2]=b1;
	 if(b2m&&b3m){
		blockToBeam2m[b1]=b2m;
		blockToBeam3m[b1]=b3m;
		beamToBlock2m[b2m]=b1;	
		beamToBlock3m[b3m]=b1;	
	 } 
	 blockToBeam[c1]=c2;
	 beamToBlock[c2]=c1;
	 if(c2m&&c3m){
		blockToBeam2m[c1]=c2m;
		blockToBeam3m[c1]=c3m;
		beamToBlock2m[c2m]=c1;	
		beamToBlock3m[c3m]=c1;	
	 }  
	 blockToBeam[d1]=d2;
	 beamToBlock[d2]=d1; 
	 if(d2m&&d3m){
		blockToBeam2m[d1]=d2m;
		blockToBeam3m[d1]=d3m;
		beamToBlock2m[d2m]=d1;	
		beamToBlock3m[d3m]=d1;	
	 }   

	 if(e1&&e2){
	  blockToBeam[e1]=e2;
	  beamToBlock[e2]=e1; 
	 }
	 if(f1&&f2){
	  blockToBeam[f1]=f2;
	  beamToBlock[f2]=f1; 
	 }
	 if(g1&&g2){
	  blockToBeam[g1]=g2;
	  beamToBlock[g2]=g1;
		 if(g2m&&g3m){
			blockToBeam2m[g1]=g2m;
			blockToBeam3m[g1]=g3m;
			beamToBlock2m[g2m]=g1;	
			beamToBlock3m[g3m]=g1;	
		 }
	 }
	 
	 if(kca1!==undefined&&kca2!==undefined){
		blockToBeam[kca1]=kca2;
		beamToBlock[kca2]=kca1;
	 }
	 
	 if(kcas1!==undefined&&kcas2!==undefined&&kcas3!==undefined){
		slopeBlockToBeam[kcas1]=kcas2;
		slopeBeamToBlock[kcas2]=kcas1;
	    slopeBeamToBlockM[kcas3]=kcas1;
	 }
	 
	 slopeBlockToBeam[aa1]=aa2;
	 slopeBlockToBeam[ab1]=ab2;
	 slopeBlockToBeam[ac1]=ac2;
	 slopeBlockToBeam[ad1]=ad2;
	 slopeBlockToBeam[ae1]=ae2;
	 slopeBeamToBlock[aa2]=aa1;
	 slopeBeamToBlockM[aa3]=aa1;
	 slopeBeamToBlock[ab2]=ab1;
	 slopeBeamToBlockM[ab3]=ab1;
	 slopeBeamToBlock[ac2]=ac1;
	 slopeBeamToBlockM[ac3]=ac1;
	 slopeBeamToBlock[ad2]=ad1;
	 slopeBeamToBlockM[ad3]=ad1;
	 slopeBeamToBlock[ae2]=ae1;
	 slopeBeamToBlockM[ae3]=ae1;
	 

	 return true;
	}	
	
	function cleanBlueprint(blocks){
		//console.log(blocks.Name);
		var SClist=blocks.SCs;
		var blocklist=blocks.BlockIds;
		var blrlist=blocks.BLR;
		var blplist=blocks.BLP;
		var bp1list=blocks.BP1;
		var bp2list=blocks.BP2;
		var bcilist=blocks.BCI; 
		var beilist=blocks.BEI;
		var blocknew=[];
		var blrnew=[];
		var blpnew=[];
		var bp1new=[];
		var bp2new=[];
		var bcinew=[];
		var beinew=[];
		var scnew=[];
		var newbeiindex=0;
		var currentIndex = 0;
		var beiIndex = 0;
		var newscindex=0;

		for(var scID = 0; scID < SClist.length; scID++){
			if(SClist[scID].ItemNumber>0){
				scnew[newscindex]=SClist[scID];
				newscindex++;
			}
		}

		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			if(blocklist[blockIndex]>=0){
				blocknew[currentIndex]=blocklist[blockIndex];
				blrnew[currentIndex]=blrlist[blockIndex];
				blpnew[currentIndex]=blplist[blockIndex];
				bp1new[currentIndex]=bp1list[blockIndex];
				bp2new[currentIndex]=bp2list[blockIndex];   
				bcinew[currentIndex]=bcilist[blockIndex];   

				if((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]==blockIndex)){
					beilist[beiIndex]=currentIndex;
					var beiIncrement = beilist[beiIndex+1]+2;
					for(var i=0;i<beiIncrement;i++){
						beinew[newbeiindex+i]=beilist[beiIndex+i];
					}
					beiIndex+=beiIncrement;
					newbeiindex+=beiIncrement;
				}else if ((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]<blockIndex)){
					//console.log ("hmmm");
				}
				currentIndex +=1;
			}else{
				//need to remove stringid references if block is removed
				if((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]==blockIndex)){
					var beiIncrement = beilist[beiIndex+1]+2;
					beiIndex+=beiIncrement;
				}
			}
			if((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]<blockIndex)){
			var beiIncrement = beilist[beiIndex+1]+2;
			beiIndex+=beiIncrement;
			}
		}
		
		blocks.BlockIds=blocknew;
		blocks.BLR=blrnew;
		blocks.BLP=blpnew;
		blocks.BP1=bp1new;
		blocks.BP2=bp2new;
		blocks.BCI=bcinew;
		blocks.BEI=beinew;
		blocks.SCs=scnew;
	}

	function getType(blockid){
		var curBlock = getBlock(blockid);
		if(curBlock){
			return curBlock.ItemType;
		}else{
			return -1;
		}
	}	

	function getMirrorData(blockID,position,rotation){
		var newRotation = rotationMirror(rotation);
		var newBlock = blockID;
		var pa=stoar(position);
		pa[0]=(-pa[0]);


		if((ItemDic[blockID])&&(getBlock(blockID))){
			var curBlock = getBlock(blockID);
			var xdiff=Math.round(curBlock.XDiff);

			if(curBlock.MirrorBlock){
				var tempBlock=ItemTable[curBlock.MirrorBlock];
				if(GuidToID[curBlock.MirrorBlock]!==undefined){
					//newBlock=tempBlock.BlockId;
					newBlock=GuidToID[curBlock.MirrorBlock];
					xdiff=Math.round((xdiff+tempBlock.XDiff)/2);	
					
				}
				
			}
			if(xdiff!=0){
				var q=getQuat(newRotation);
				var positionshift=posTransform([-xdiff,0,0],q);
				pa[0]+=positionshift[0];
				pa[1]+=positionshift[1];
				pa[2]+=positionshift[2];
			} 
		}
		pa[0]=Math.round(parseFloat(pa[0]));
		pa[1]=Math.round(parseFloat(pa[1]));
		pa[2]=Math.round(parseFloat(pa[2]));

		var strposition = atos(pa);

		var mirrordata={}
		mirrordata.blockID=newBlock;
		mirrordata.position=strposition;
		mirrordata.rotation=newRotation;
		return mirrordata;
	}	

	function getNewColor(bID){
	 if(document.getElementById("paint").checked){
	  if(document.getElementById("painttarget").value=="all"){
	   return selectedcolor;      
	  }
	  else if(document.getElementById("painttarget").value=="paintothers"){
	   if(blockColorIndex[bID]!==undefined){
		return -1;
	   }else{
		return selectedcolor;
	   }
	  }else{
	   if(blockColorIndex[bID]!==undefined){
		return blockColorIndex[bID];
	   }else{
		return -1;
	   }
	  }

	 }
	 else{
	  return -1;
	 }
	}	  
	  
	function buildblockColorIndex(){

	 blockColorIndex = {};
	 
	 if(document.getElementById("paint").checked){
	  selectedcolor=temppaintcolor;
	  
	    if(document.getElementById("painttarget").value=="blockfilter"){
			for(var tempguid in blockFilterTable){
				blockColorIndex[GuidToID[tempguid]]=selectedcolor;
			}
			
			
	    }else{
	  
		  if((document.getElementById("painttarget").value=="wood")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["wood"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["wood"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
	
		   }
		  }
		  
		  if((document.getElementById("painttarget").value=="metal")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["metal"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["metal"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
		   }
		  }  

		  if((document.getElementById("painttarget").value=="alloy")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["alloy"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["alloy"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
		   }
		  } 

		  if((document.getElementById("painttarget").value=="glass")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["glass"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["glass"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
		   }
		  }
		  
		  if((document.getElementById("painttarget").value=="heavyarmour")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["heavyarmour"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["heavyarmour"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
		   }
		  }
		  
		  if((document.getElementById("painttarget").value=="stone")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["stone"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["stone"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
		   }
		  }
		  if((document.getElementById("painttarget").value=="lead")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["lead"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["lead"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
		   }
		  }
		  if((document.getElementById("painttarget").value=="kca")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
		   var blockcount =  localShapedBlocks["kca"].length;
		   for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks["kca"][i];
			if(tempid!==undefined&&tempid>=0){
				blockColorIndex[tempid] = selectedcolor;
			}
		   }
		  }		  
	   }
	 }
	}
	
	function removeOverlap(blocks){
		var blockPosData = {};
		var blocklist=blocks.BlockIds;
		var colorlist=blocks.BCI;
		var positionList=blocks.BLP;
		var rotationList = blocks.BLR;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){		
			var currentBlock = blocklist[blockIndex];
			var blockData = getBlock(currentBlock);
			var tempBlock={};
			var currentPosition = stoar(positionList[blockIndex]);
			tempBlock.blockId=currentBlock;
			tempBlock.blockIndex=blockIndex;
			tempBlock.pos=positionList[blockIndex];
			tempBlock.rot=rotationList[blockIndex];
			tempBlock.bci=colorlist[blockIndex];
			tempBlock.overlap=false;
			if(blockData){
				
				for (var x=blockData.negx;x<=blockData.posx;x++){
					for (var y=blockData.negy;y<=blockData.posy;y++){
						for (var z=blockData.negz;z<=blockData.posz;z++){
							var q=getQuat(rotationList[blockIndex]);
							var temppos=posTransform([x,y,z],q);
							currentPosition
							var strPos=atos([temppos[0]+currentPosition[0],temppos[1]+currentPosition[1],temppos[2]+currentPosition[2]]);
							if (blockPosData[strPos]){
								//overlap
								//maybe can consider performing beam to block here
								tempBlock.overlap=true;
								blocklist[blockIndex]=-1;
							}else{
								blockPosData[strPos]=tempBlock;
								//no overlap
							}
						}
					}
				}
			}else{
				//block not found?
			}
		
		}
		var tempBlockIndex=blocklist.length;
		for(position in blockPosData){
			var tempBlock=blockPosData[position];
			if(tempBlock.overlap){
					var tempbtb=0;
					if(beamToBlock[tempBlock.blockId]){
						tempbtb=beamToBlock[tempBlock.blockId];
					}else if(beamToBlock3m[tempBlock.blockId]){
						tempbtb=beamToBlock3m[tempBlock.blockId];
					}else if(beamToBlock2m[tempBlock.blockId]){
						tempbtb=beamToBlock2m[tempBlock.blockId];
					}
				if(tempbtb){
					var newBlockId=tempbtb;
					blocklist[tempBlockIndex]=newBlockId;
					rotationList[tempBlockIndex]=0;
					colorlist[tempBlockIndex]=tempBlock.bci;
					blocks.BP1[tempBlockIndex]="0,0,0,0";
					blocks.BP2[tempBlockIndex]="0,0,0,0";
					positionList[tempBlockIndex]= position;
					tempBlockIndex+=1;				
				}else if(slopeBeamToBlock[tempBlock.blockId]){
					var newBlockId=slopeBeamToBlock[tempBlock.blockId];
					blocklist[tempBlockIndex]=newBlockId;
					var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],false);
					rotationList[tempBlockIndex]=targetRotation;
					colorlist[tempBlockIndex]=tempBlock.bci;
					blocks.BP1[tempBlockIndex]="0,0,0,0";
					blocks.BP2[tempBlockIndex]="0,0,0,0";
					positionList[tempBlockIndex]= position;
					tempBlockIndex+=1;			
				}else if(slopeBeamToBlockM[tempBlock.blockId]){
					var newBlockId=slopeBeamToBlockM[tempBlock.blockId];
					blocklist[tempBlockIndex]=newBlockId;
					var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],true);
					rotationList[tempBlockIndex]=targetRotation;
					colorlist[tempBlockIndex]=tempBlock.bci;
					blocks.BP1[tempBlockIndex]="0,0,0,0";
					blocks.BP2[tempBlockIndex]="0,0,0,0";
					positionList[tempBlockIndex]= position;
					tempBlockIndex+=1;			
				}

			}
			
		}
		cleanBlueprint(blocks);
	}

	function updateBlockCount(blocks){
		var SClist=blocks.SCs;	
		for(var scID = 0; scID < SClist.length; scID++){
			updateBlockCount(SClist[scID]);
		}
		if(blocks.TotalBlockCount!==undefined){
			blocks.TotalBlockCount=blocks.BlockIds.length;
		}
		if(blocks.BlockCount!==undefined){
			blocks.BlockCount=blocks.BlockIds.length;
		}
		if(blocks.LastAliveBlock!==undefined){
			blocks.LastAliveBlock=blocks.BlockIds.length;
		}	
		if(blocks.IndexOfFirstBlockNeedingFullRepairCost!==undefined){
			blocks.IndexOfFirstBlockNeedingFullRepairCost=1000000;
		}	
	}

	function getconverted(bID){
	 if (conversionIndex[bID]){
	  return conversionIndex[bID];  
	 }
	 else return(bID);
	}

	function buildconversionIndex(){
	 conversionIndex = {};
	 for(var mat in shapedBlocks){
	  if(document.getElementById(mat).checked){
	   var newmat=document.getElementById(mat+"to").value;
		if (newmat!=mat){
		var blockcount = localShapedBlocks[mat].length;
		for(var i=0;i<blockcount;i++){
			var tempid=localShapedBlocks[mat][i];
			if(tempid!==undefined&&tempid>=0){
			   if(newmat==0){
				conversionIndex[tempid]=-1;
			   }else if ((i<localShapedBlocks[newmat].length)&&(localShapedBlocks[newmat][i]>=0)){
				conversionIndex[tempid] = localShapedBlocks[newmat][i];
			   }			
			}

		 
		}
	   }
	  }
	 }
	 if(document.getElementById("tosolidclip").checked){
		for(var guid in toSolid){
			conversionIndex[GuidToID[guid]]=GuidToID[toSolid[guid]];	
		}
	 
	 }else if(document.getElementById("fromsolidclip").checked){
		for(var guid in fromSolid){
			conversionIndex[GuidToID[guid]]=GuidToID[fromSolid[guid]];	
		}	 
	 }
	 
	 
		if(document.getElementById("cramSwap").checked){
			conversionIndex[GuidToID[document.getElementById("cramFrom").value]]=GuidToID[document.getElementById("cramTo").value];
		}
	 
	}

						

	function buildReplaceOldIndex(){
		replaceOldIndex = {};
		for(var key in ItemDic){
			var keyint = parseInt(key);
			var val = ItemDic[keyint];
			if(oldBlocks[val]){
				var tempblock={};
				tempblock.BlockId=GuidToID[oldBlocks[val].Guid];
				tempblock.Rot=oldBlocks[val].Rot;
				replaceOldIndex[keyint]=tempblock;
			}
		}
	}	
	function replaceOld(blocks){
		var SClist=blocks.SCs;
		blocks.designChanged = true;
		for(var scID = 0; scID < SClist.length; scID++){
			replaceOld(SClist[scID]);
		}
		var blocklist=blocks.BlockIds;
		var rotationList = blocks.BLR;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			if(replaceOldIndex[blocklist[blockIndex]]){
				var replaceData = replaceOldIndex[blocklist[blockIndex]];
				var newRotation = blockRotate(replaceData.Rot,rotationList[blockIndex]);
				var newBlock = replaceData.BlockId;				
				blocklist[blockIndex] = newBlock;
				rotationList[blockIndex] = newRotation;
			}
		}
	}
	

	function getBlock(bid){
		var tempBlock=ItemTable[ItemDic[bid]];
		tempBlock.blockId=GuidToID[ItemDic[bid]];
		return tempBlock;
	}
	

	//convert blocks between materials. also changes shield color.
	function convertblocks(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  convertblocks(SClist[scID]);
	 }
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
		  blocklist[blockIndex] = getconverted(blocklist[blockIndex]);
		  if(document.getElementById("shieldcolor").checked){
		   if (nameID[blocklist[blockIndex]]=="Shield Color Changer"){
			blocks.BP1[blockIndex] = "" + document.getElementById("shieldr").value + "," +  document.getElementById("shieldg").value + "," + document.getElementById("shieldb").value + "," + document.getElementById("shielda").value;
		   }
		  }
		}
	 }
	 cleanBlueprint(blocks);
	}


	function mirrorVehicle(blocks){
		var SClist=blocks.SCs;
		blocks.designChanged = true;
		for(var scID = 0; scID < SClist.length; scID++){
			var curSC=SClist[scID];
			curSC.LocalPosition=flipX(curSC.LocalPosition);
			curSC.LocalRotation=quatMirror(curSC.LocalRotation);
			mirrorVehicle(curSC);
		}
		var blocklist=blocks.BlockIds;
		var positionList=blocks.BLP;
		var rotationList = blocks.BLR;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

			blocklist[blockIndex]=mirrordata.blockID;
			positionList[blockIndex]=mirrordata.position;
			rotationList[blockIndex]=mirrordata.rotation;
		}
	}

	function rotateBlueprint(blocks,dir){
		var SClist=blocks.SCs;
		blocks.designChanged = true;
		for(var scID = 0; scID < SClist.length; scID++){
			var curSC=SClist[scID];
			curSC.LocalPosition=positionRotate(curSC.LocalPosition,dir);
			curSC.LocalRotation=quatRotate(curSC.LocalRotation,dir);  
		}
		var blocklist=blocks.BlockIds;
		var positionList=blocks.BLP;
		var rotationList = blocks.BLR;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			positionList[blockIndex]=positionRotate(positionList[blockIndex],dir);
			rotationList[blockIndex]=blockRotate(rotationList[blockIndex],dir);
		}
	}

	//builds index of file to keep via the clearhull() function
	function buildkeepIndex(){
	 keepIndex = {};
	 for(var mat in shapedBlocks){
		for (var key in shapedBlocks[mat].blockGuid){
			if(GuidToID[key]!==undefined){
				keepIndex[GuidToID[key]] = true;
			}
			
		}
		/*
	  var blockcount =  shapedBlocks[mat].blockGuid.length;
	  for(var i=0;i<blockcount;i++){
	   keepIndex[GuidToID[shapedBlocks[mat].blockGuid[i]]] = true;
	  }
	  */
	 }
	}

	//delete everything except structural blocks on the main vehicle
	function clearhull(blocks){
	 blocks.SCs = [];
	 blocks.BlockStringData = [];
	 blocks.BlockStringDataIds = [];
	 blocks.BEI = [];
	 var blocklist=blocks.BlockIds;
	 var blrlist=blocks.BLR;
	 var blplist=blocks.BLP;
	 var bp1list=blocks.BP1;
	 var bp2list=blocks.BP2;
	 var bcilist=blocks.BCI; 
	 var blocknew=[];
	 var blrnew=[];
	 var blpnew=[];
	 var bp1new=[];
	 var bp2new=[];
	 var bcinew=[];
	 var currentIndex = 0;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  if(keepIndex[blocklist[blockIndex]]){
	   blocknew[currentIndex]=blocklist[blockIndex];
	   blrnew[currentIndex]=blrlist[blockIndex];
	   blpnew[currentIndex]=blplist[blockIndex];
	   bp1new[currentIndex]=bp1list[blockIndex];
	   bp2new[currentIndex]=bp2list[blockIndex];   
	   bcinew[currentIndex]=bcilist[blockIndex];   
	   currentIndex +=1;
	  }
	 } 
	 blocks.BlockIds=blocknew;
	 blocks.BLR=blrnew;
	 blocks.BLP=blpnew;
	 blocks.BP1=bp1new;
	 blocks.BP2=bp2new;
	 blocks.BCI=bcinew;
	}

	//randomly color blocks
	function randomcolorblocks(blocks){
	 var SClist=blocks.SCs;
	 //blocks.designChanged = true;
	 if(blocks.COL){
	   for(var i=0;i<28;i++){
		var colorseed = Math.floor((Math.random() * 15));
		var othercolor = 0.0;
		if (Math.random()<0.5){
		 othercolor = 1.0;
		}
		if (colorseed>8){
		 blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + Math.random()  +",0.99";
		}
		else if (colorseed>6){
		 blocks.COL[i]= "" +othercolor + "," + Math.random()  + "," + Math.random()  +",0.99";
		}
		else if (colorseed>4){
		 blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + Math.random()  +",0.99";
		}
		else if (colorseed>2){
		 blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + othercolor  +",0.99";
		}
		else if (colorseed>1){
		 blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + othercolor  +",0.99";
		}   
		else if (colorseed>0){
		 blocks.COL[i]= "" + othercolor + "," + Math.random()  + "," + othercolor  +",0.99";
		}else{
		 blocks.COL[i]= "" + othercolor + "," + othercolor  + "," + Math.random()  +",0.99";
		}
		
	   } 
	 }
	 for(var scID = 0; scID < SClist.length; scID++){

	   randomcolorblocks(SClist[scID]);
	  
	 }
	 var colorlist=blocks.BCI;
	 for(var blockIndex = 0; blockIndex < colorlist.length; blockIndex++){
	   colorlist[blockIndex] = Math.floor((Math.random() * 28));
	 }
	}

	//paint blocks
	function colorblocks(blocks){
	 var SClist=blocks.SCs;
	 var deleteblock=false;
	 //blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  if(!(SClist[scID].COL)){
	   colorblocks(SClist[scID]);
	  }
	 }
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
		  var newcolor = getNewColor(blocklist[blockIndex]);
		  if (newcolor==32){
			colorlist[blockIndex] = 1+Math.floor((Math.random() * 4));
		  }else if (newcolor==33){
			colorlist[blockIndex] = 28+Math.floor((Math.random() * 4));
		  }else if (newcolor==34){
			blocklist[blockIndex] = -1;
			deleteblock=true;
		  }else if (newcolor>=0){
		   colorlist[blockIndex] = newcolor;
		  }
		}
	 }
	 if(deleteblock){
		cleanBlueprint(blocks);
	 }
	}

	//turns beam into blocks
	function debeamifyblocks(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  debeamifyblocks(SClist[scID]);
	 } 
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 var positionList=blocks.BLP;
	 var rotationList = blocks.BLR; 
	 var newBlockIndex=blocklist.length;
	 var blockcount=blocklist.length;
	 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
	  var currentBlock = blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&beamToBlock[currentBlock]){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;
		var targetBlock =beamToBlock[currentBlock];
		var directionArray = getDirectionArray(rotationList[blockIndex]);
		if(directionArray){
		 
		 blocklist[blockIndex]=targetBlock;
		 for(var i=1;i<4;i++){
		  blocklist[newBlockIndex]=targetBlock;
		  rotationList[newBlockIndex]=0;
		  colorlist[newBlockIndex]=colorlist[blockIndex];
		  blocks.BP1[newBlockIndex]="0,0,0,0";
		  blocks.BP2[newBlockIndex]="0,0,0,0";
		  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
		  newBlockIndex+=1;
		 }
		}
	  }else if(ItemDic[currentBlock]&&beamToBlock3m[currentBlock]){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;
		var targetBlock =beamToBlock3m[currentBlock];
		var directionArray = getDirectionArray(rotationList[blockIndex]);
		if(directionArray){
		 
		 blocklist[blockIndex]=targetBlock;
		 for(var i=1;i<3;i++){
		  blocklist[newBlockIndex]=targetBlock;
		  rotationList[newBlockIndex]=0;
		  colorlist[newBlockIndex]=colorlist[blockIndex];
		  blocks.BP1[newBlockIndex]="0,0,0,0";
		  blocks.BP2[newBlockIndex]="0,0,0,0";
		  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
		  newBlockIndex+=1;
		 }
		}
	  }else if(ItemDic[currentBlock]&&beamToBlock2m[currentBlock]){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;
		var targetBlock =beamToBlock2m[currentBlock];
		var directionArray = getDirectionArray(rotationList[blockIndex]);
		if(directionArray){
		 
		 blocklist[blockIndex]=targetBlock;
		 for(var i=1;i<2;i++){
		  blocklist[newBlockIndex]=targetBlock;
		  rotationList[newBlockIndex]=0;
		  colorlist[newBlockIndex]=colorlist[blockIndex];
		  blocks.BP1[newBlockIndex]="0,0,0,0";
		  blocks.BP2[newBlockIndex]="0,0,0,0";
		  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
		  newBlockIndex+=1;
		 }
		}
	  }
	 }
	}


	function debeamifyslopeblocks(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  debeamifyslopeblocks(SClist[scID]);
	 }
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 var positionList=blocks.BLP;
	 var rotationList = blocks.BLR; 
	 var newBlockIndex=blocklist.length;
	 var blockcount=blocklist.length;
	 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
	  var currentBlock = blocklist[blockIndex];
	  var currentRotation = rotationList[blockIndex];
	  if(ItemDic[currentBlock]&&(slopeBeamToBlock[currentBlock]||slopeBeamToBlockM[currentBlock])){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;
		var targetBlock = 0;
		var targetRotation = 0;
		if(slopeBeamToBlock[currentBlock]){
		 targetBlock = slopeBeamToBlock[currentBlock];
		 targetRotation = slopeBeamToBlockOrientation(currentRotation,false);
		}else if (slopeBeamToBlockM[currentBlock]){
		 targetBlock = slopeBeamToBlockM[currentBlock];
		 targetRotation = slopeBeamToBlockOrientation(currentRotation,true);
		}

		var directionArray = getDirectionArray(rotationList[blockIndex]);
		if(directionArray){
		 
		 blocklist[blockIndex]=targetBlock;
		 rotationList[blockIndex]=targetRotation;
		 for(var i=1;i<4;i++){
		  blocklist[newBlockIndex]=targetBlock;
		  rotationList[newBlockIndex]=targetRotation;
		  colorlist[newBlockIndex]=colorlist[blockIndex];
		  blocks.BP1[newBlockIndex]="0,0,0,0";
		  blocks.BP2[newBlockIndex]="0,0,0,0";
		  positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
		  newBlockIndex+=1;
		 }
		}

	  }
	 }
	 
	}	

	function beamifyslopeblocks(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  beamifyslopeblocks(SClist[scID]);
	 }
	 var blockPositionData = {};
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 var positionList=blocks.BLP;
	 var rotationList = blocks.BLR;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock = blocklist[blockIndex];
	  if(ItemDic[currentBlock]){
	   if(slopeBlockToBeam[currentBlock]){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;       
		blockPositionData[currentPosition]=blockIndex;    
	   }
	  }
	 }
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex]; 
	  var currentRotation=rotationList[blockIndex];
	  var dirx=0;
	  var diry=0;
	  var dirz=0;
	  switch (currentRotation) {
	   case 0:
	   case 2:
	   case 4:
	   case 6:
	   case 8:
	   case 10:
	   case 12:
	   case 14:
		dirx=1;
		diry=0;
		dirz=0;
		break;
	   case 16:
	   case 17:
	   case 18:
	   case 19:
	   case 20:
	   case 21:
	   case 22:
	   case 23:
		dirx=0;
		diry=1;
		dirz=0;
		break;   
	   case 1:
	   case 3:
	   case 5:
	   case 7:
	   case 9:
	   case 11:
	   case 13:
	   case 15:
		dirx=0;
		diry=0;
		dirz=1;
		break;
	   default:
	  } 
	 
	  if(ItemDic[currentBlock]&&slopeBlockToBeam[currentBlock]){
	  
	   var lookbackArray=getLookbackArraySloped((-dirx),(-diry),(-dirz),blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList);   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxisSloped(dirx,diry,dirz,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,slopeBlockToBeamOrientation(currentRotation,false));
	   }
	  }
	 }
	 
		cleanBlueprint(blocks);
	}


	function beamifyaxisSloped(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
	 var tempBlockIndex = blockIndex;
	 var currentBlock = blocklist[tempBlockIndex];
	 if(ItemDic[currentBlock]){
	  if(slopeBlockToBeam[currentBlock]){
	   
	   var currentColor = colorlist[tempBlockIndex];
	   var currentPosition = positionList[tempBlockIndex];
	   var currentRotation = rotationList[tempBlockIndex];
	   
	   var posArray = JSON.parse("["+currentPosition+"]");
	   posArray[0] = Math.round(posArray[0]);
	   posArray[1] = Math.round(posArray[1]);
	   posArray[2] = Math.round(posArray[2]);
	   var result = true;
	   
	   
	   result = true;
	   for(var i=1;i<4;i++){
		var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
		 
		}else{
		 result = false;
		}
	   }
	   if(result){
		for(i=1;i<4;i++){
		 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		 blocklist[blockPositionData[tempPosition]]=-1;
		}
		blocklist[tempBlockIndex]=slopeBlockToBeam[currentBlock];
		rotationList[tempBlockIndex]=rotation;     
	   }
	   
	   
	  }
	 }

	}
	//turn this blocks and adjacent 3 1x1x1 blocks in a particular direction into 1x1x4 beams
	function beamifyaxis(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
	 var tempBlockIndex = blockIndex;
	 var currentBlock = blocklist[tempBlockIndex];
	 if(ItemDic[currentBlock]){
	  if(blockToBeam[currentBlock]){
	 
	   var currentColor = colorlist[tempBlockIndex];
	   var currentPosition = positionList[tempBlockIndex];
	   
	   var posArray = JSON.parse("["+currentPosition+"]");
	   posArray[0] = Math.round(posArray[0]);
	   posArray[1] = Math.round(posArray[1]);
	   posArray[2] = Math.round(posArray[2]);
	   var result = true;
	   
	   
	   result = true;
	   for(i=1;i<4;i++){
		var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
		 
		}else{
		 result = false;
		}
	   }
	   if(result){    
		for(i=1;i<4;i++){
		 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		 blocklist[blockPositionData[tempPosition]]=-1;
		}
		blocklist[tempBlockIndex]=blockToBeam[currentBlock];

		rotationList[tempBlockIndex]=rotation;     
	   }
	   
	   
	  }
	 }

	}

	function beamifyaxis3m(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
	 var tempBlockIndex = blockIndex;
	 var currentBlock = blocklist[tempBlockIndex];
	 if(ItemDic[currentBlock]){
	  if(blockToBeam3m[currentBlock]){
	   var currentColor = colorlist[tempBlockIndex];
	   var currentPosition = positionList[tempBlockIndex];
	   
	   var posArray = JSON.parse("["+currentPosition+"]");
	   posArray[0] = Math.round(posArray[0]);
	   posArray[1] = Math.round(posArray[1]);
	   posArray[2] = Math.round(posArray[2]);
	   var result = true;
	   
	   
	   result = true;
	   for(i=1;i<3;i++){
		var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
		 
		}else{
		 result = false;
		}
	   }
	   if(result){
		for(i=1;i<3;i++){
		 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		 blocklist[blockPositionData[tempPosition]]=-1;
		}
		blocklist[tempBlockIndex]=blockToBeam3m[currentBlock];
		rotationList[tempBlockIndex]=rotation;     
	   }
	   
	   
	  }
	 }

	}

	function beamifyaxis2m(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
	 var tempBlockIndex = blockIndex;
	 var currentBlock = blocklist[tempBlockIndex];
	 if(ItemDic[currentBlock]){
	  if(blockToBeam2m[currentBlock]){
	   var currentColor = colorlist[tempBlockIndex];
	   var currentPosition = positionList[tempBlockIndex];
	   
	   var posArray = JSON.parse("["+currentPosition+"]");
	   posArray[0] = Math.round(posArray[0]);
	   posArray[1] = Math.round(posArray[1]);
	   posArray[2] = Math.round(posArray[2]);
	   var result = true;
	   
	   
	   result = true;
	   for(i=1;i<2;i++){
		var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
		 
		}else{
		 result = false;
		}
	   }
	   if(result){
		for(i=1;i<2;i++){
		 var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
		 blocklist[blockPositionData[tempPosition]]=-1;
		}
		blocklist[tempBlockIndex]=blockToBeam2m[currentBlock];
		rotationList[tempBlockIndex]=rotation;     
	   }
	   
	   
	  }
	 }

	}

	function getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData){
	 
	 var queue1=[blockIndex];
	 var queue1index=1; 
	 var queue1process=0;
	 while(queue1process<queue1index){
	  var tempBlockIndex = queue1[queue1process];
	  var currentBlock = blocklist[tempBlockIndex];
	  var currentColor = colorlist[tempBlockIndex];
	  var currentPosition = positionList[tempBlockIndex];
	  var posArray = JSON.parse("["+currentPosition+"]");
	  posArray[0] = Math.round(posArray[0]);
	  posArray[1] = Math.round(posArray[1]);
	  posArray[2] = Math.round(posArray[2]);
	  var tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]);
	  if(blockPositionData[tempPosition]){
	   var tempblock = {}
	   tempblock.blockIndex=tempBlockIndex;
	   tempblock.score=0;
	   localPositionData[tempPosition]=tempblock;
	   delete blockPositionData[tempPosition]; 
	   
	   tempPosition = "" + (posArray[0]+1)+","+(posArray[1])+","+(posArray[2]);
	   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
		queue1[queue1index]=blockPositionData[tempPosition];
		queue1index++;
	   }
	   
	   tempPosition = "" + (posArray[0]-1)+","+(posArray[1])+","+(posArray[2]);
	   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
		queue1[queue1index]=blockPositionData[tempPosition];
		queue1index++;
	   }

	   tempPosition = "" + (posArray[0])+","+(posArray[1]+1)+","+(posArray[2]);
	   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
		queue1[queue1index]=blockPositionData[tempPosition];
		queue1index++;
	   }

	   tempPosition = "" + (posArray[0])+","+(posArray[1]-1)+","+(posArray[2]);
	   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
		queue1[queue1index]=blockPositionData[tempPosition];
		queue1index++;
	   }

	   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]+1);
	   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
		queue1[queue1index]=blockPositionData[tempPosition];
		queue1index++;
	   }

	   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]-1);
	   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
		queue1[queue1index]=blockPositionData[tempPosition];
		queue1index++;
	   }   
	   
	   
	  }
	 
	 
	  queue1process++;
	 }

	}

	//get an array containing 1x1x1 blocks in a direction.
	function getLookbackArray(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData){
	 var tempindex=0;
	 var tempList=[];
	 var tempBlockIndex = blockIndex;
	 var currentBlock = blocklist[tempBlockIndex];
	 var currentColor = colorlist[tempBlockIndex];
	 var currentPosition = positionList[tempBlockIndex];
	 var posArray = JSON.parse("["+currentPosition+"]");
	 posArray[0] = Math.round(posArray[0]);
	 posArray[1] = Math.round(posArray[1]);
	 posArray[2] = Math.round(posArray[2]); 
	 
	 
	 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
	 
	 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
	  tempList[tempindex]=blockPositionData[tempPosition];
	  
	  tempindex+=1;
	  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
	  
	 }
	 return tempList;
	}

	function getLookbackArraySloped(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList){
	 var tempindex=0;
	 var tempList=[];
	 var tempBlockIndex = blockIndex;
	 var currentBlock = blocklist[tempBlockIndex];
	 var currentColor = colorlist[tempBlockIndex];
	 var currentPosition = positionList[tempBlockIndex];
	 var currentRotation = rotationList[tempBlockIndex];
	 var posArray = JSON.parse("["+currentPosition+"]");
	 posArray[0] = Math.round(posArray[0]);
	 posArray[1] = Math.round(posArray[1]);
	 posArray[2] = Math.round(posArray[2]); 
	 
	 
	 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
	 
	 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
	  tempList[tempindex]=blockPositionData[tempPosition];
	  
	  tempindex+=1;
	  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
	  
	 }
	 return tempList;
	}




	function becomeStructure(blocks,subcon){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  if(!(SClist[scID].COL)){
	   //no palette=turret or spinblock
	   becomeStructure(SClist[scID],true);
	  } 
	  
	 }
	 var start=0;
	 if(subcon){
	  start=1;
	 }
	 var deletecount=0;
	 var blocklist=blocks.BlockIds;
	 for(var blockIndex = start; blockIndex < blocklist.length; blockIndex++){
	  var currentBlockInfo = getBlock(blocklist[blockIndex]);
	  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnStructure)){
	   deletecount+=1;
	   blocklist[blockIndex]=-1;
	  }

	 }
	 
	 cleanBlueprint(blocks);
	}


	function becomeVehicle(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  becomeVehicle(SClist[scID]);
	 }
	 var deletecount=0;
	 var blocklist=blocks.BlockIds;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlockInfo = getBlock(blocklist[blockIndex]);
	  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnVehicle)){
	   deletecount+=1;
	   blocklist[blockIndex]=-1;
	  }

	 }
	 cleanBlueprint(blocks);
	 
	}
	
	function becomeFortress(blocks,subcon){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  if(!(SClist[scID].COL)){
	   //no palette=turret or spinblock
	   becomeFortress(SClist[scID],true);
	  } 
	  
	 }
	 var start=0;
	 if(subcon){
	  start=1;
	 }
	 var deletecount=0;
	 var blocklist=blocks.BlockIds;
	 for(var blockIndex = start; blockIndex < blocklist.length; blockIndex++){
	  var currentBlockInfo = getBlock(blocklist[blockIndex]);
	  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnFortress)){
	   deletecount+=1;
	   blocklist[blockIndex]=-1;
	  }

	 }
	 
	 cleanBlueprint(blocks);
	}	


	function cutInHalfSC(blocks,midx){
		var blocklist=blocks.BlockIds;
		var positionList=blocks.BLP;
		var scRotation = "["+blocks.LocalRotation+"]";
		var scPosition = "["+blocks.LocalPosition+"]";
		var scp = JSON.parse(scPosition);
		var q = JSON.parse(scRotation);
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var currentPosition = "["+positionList[blockIndex]+"]";
			var tpa = JSON.parse(currentPosition);
			var tpaq = [tpa[0],tpa[1],tpa[2],0];
			var transpos = quatmul(q,quatmul(tpaq,quatconj(q)));
			var finalx = scp[0]+transpos[0];
			finalx=Math.round(finalx);
			if(finalx>midx){
				blocklist[blockIndex]=-1;
			}
		}
		cleanBlueprint(blocks);
	}

	function cutInHalf(blocks,xshift,originID){
		blocks.designChanged = true;
		var SClist=blocks.SCs;
		var minx=0;
		var maxx=0;
		var midx=0;
		var originfound=false;
		var orix=0;
		var blocklist=blocks.BlockIds;
		var positionList=blocks.BLP;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var currentPosition = "["+positionList[blockIndex]+"]";
			var tpa = JSON.parse(currentPosition);
			var curx = Math.round(tpa[0]);
			minx=Math.min(curx,minx);
			maxx=Math.max(curx,maxx);
			if(currentBlock==originID){
				originfound=true;
				orix=Math.round(tpa[0]);
			}			
		}
		if(originfound){
			midx=orix+xshift;		
		}else{
			midx=((minx+maxx)/2)+xshift;				
		}
		

		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var currentPosition = "["+positionList[blockIndex]+"]";
			var tpa = JSON.parse(currentPosition);
			var curx = Math.round(tpa[0]);
			if (curx>midx){
				blocklist[blockIndex]=-1;
			}
		}

		for(var scID = 0; scID < SClist.length; scID++){
			if(!(SClist[scID].COL)){
				var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
				var tpa = JSON.parse(currentPosition);
				var curx = Math.round(tpa[0]);
				if(curx>midx){
					SClist[scID].ItemNumber=-1;
				}else{
					cutInHalfSC(SClist[scID],midx);
				}
			}else{
				SClist[scID].ItemNumber=-1;
			}
		}
		cleanBlueprint(blocks);
	}



	//need to modify when we can check for parts sticking out
	function widenVehicle(blocks,xdist,xshift,originID){
		blocks.designChanged = true;
		var blockPositionData={};
		var SClist=blocks.SCs;
		var minx=0;
		var maxx=0;
		var miny=0;
		var maxy=0;
		var minz=0;
		var maxz=0;
		var midx=0;
		var leftx=0;
		var rightx=0;
		var bestrs;
		var bestls;
		var bestrp;
		var bestlp;	
		var originfound=false;
		var orix=0;		
		var xmove=Math.round(parseFloat(xdist));
		var maxmirrorx=0;
		var rightconnected=false;
		var leftconnected=false;	
		var fillerblock=GuidToID["9a0ae372-beb4-4009-b14e-36ed0715af73"];		
		var blocklist=blocks.BlockIds;
		var positionList=blocks.BLP;
		var rotationList=blocks.BLR;
		var bp1list=blocks.BP1;
		var bp2list=blocks.BP2;
		var colorlist=blocks.BCI;
		var beilist=blocks.BEI;	
		var blockcount=blocklist.length; //needed cause variableblocklist :D
		var beiIndex=0;
		var currentIndex = blockcount; //index to add new blocks
		var currentBeiIndex = beilist.length;; //index to add new blocks
		var currentSCIndex=SClist.length;
		var SCcount=SClist.length;
		for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var currentPosition = "["+positionList[blockIndex]+"]";
			var tpa = JSON.parse(currentPosition);
			var curx = Math.round(tpa[0]);
			blockPositionData[atos(tpa)]=blockIndex;
			minx=Math.min(curx,minx);
			maxx=Math.max(curx,maxx);
			miny=Math.min(tpa[1],miny);
			maxy=Math.max(tpa[1],maxy);
			minz=Math.min(tpa[2],minz);
			maxz=Math.max(tpa[2],maxz);
			if(currentBlock==originID){
				originfound=true;
				orix=Math.round(tpa[0]);
			}			
		}
		var midy=Math.round((miny+maxy)/2);
		var midz=Math.round((minz+maxz)/2);	
		if(originfound){
			midx=orix+xshift;	
		}else{
			midx=((minx+maxx)/2)+xshift;				
		}				
		midx=Math.round(midx-0.2);
		leftx=midx;
		rightx=leftx+1;	
		
		for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var tpa = stoar(positionList[blockIndex]);
			var curx = tpa[0];
			if (curx>midx){
				positionList[blockIndex]=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
				if((tpa[0]==rightx)&&(!leftconnected)&&(!rightconnected)){
					leftblock=atos([leftx,tpa[1],tpa[2]]);
					if(blockPositionData[leftblock]!==undefined&&blockPositionData[leftblock]>=0){
						midy=tpa[1];
						midz=tpa[2];
						leftconnected=true;
						rightconnected=true;
					}
				}
				if((tpa[0]==rightx)&&(!rightconnected)){
					if(!bestrp){
						bestrp=atos(tpa);
						bestrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
					}else{
						var currentrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
						if(currentrs<bestrs){
							bestrp=atos(tpa);
							bestrs=currentrs;
						}
					}
					
				}
			
			}else{
				if((tpa[0]==leftx)&&(!leftconnected)){
					if(!bestlp){
						bestlp=atos(tpa);
						bestls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
					}else{
						var currentls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
						if(currentls<bestls){
							bestlp=atos(tpa);
							bestls=currentls;					
						}
					}
				}
			}
		}
		//add filllerblock

		for (var i=rightx;i<(rightx+xmove);i++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([i,midy,midz]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;
		}
		
		//connect left
		if((bestlp)&&(!leftconnected)){
			var bestla=stoar(bestlp);
			var starty=Math.min(bestla[1],midy+1);
			var endy=Math.max(bestla[1],midy-1);		
			var startz=Math.min(bestla[2],midz+1);
			var endz=Math.max(bestla[2],midz-1);
			
			for(var y=starty;y<=endy;y++){
				blocks.BlockIds[currentIndex]=fillerblock;
				blocks.BLP[currentIndex]=atos([leftx+1,y,midz]);
				blocks.BLR[currentIndex]=0;
				blocks.BP1[currentIndex]="0,0,0,0";
				blocks.BP2[currentIndex]="0,0,0,0";
				blocks.BCI[currentIndex]=0;
				currentIndex++;		
			}
			for(var z=startz;z<=endz;z++){
				blocks.BlockIds[currentIndex]=fillerblock;
				blocks.BLP[currentIndex]=atos([leftx+1,bestla[1],z]);
				blocks.BLR[currentIndex]=0;
				blocks.BP1[currentIndex]="0,0,0,0";
				blocks.BP2[currentIndex]="0,0,0,0";
				blocks.BCI[currentIndex]=0;
				currentIndex++;		
			}
			leftconnected=true;
		}
		//connect right
		if((bestrp)&&(!rightconnected)){
			var bestra=stoar(bestrp);
			var starty=Math.min(bestra[1],midy+1);
			var endy=Math.max(bestra[1],midy-1);		
			var startz=Math.min(bestra[2],midz+1);
			var endz=Math.max(bestra[2],midz-1);
			
			for(var y=starty;y<=endy;y++){
				blocks.BlockIds[currentIndex]=fillerblock;
				blocks.BLP[currentIndex]=atos([leftx+xmove,y,midz]);
				blocks.BLR[currentIndex]=0;
				blocks.BP1[currentIndex]="0,0,0,0";
				blocks.BP2[currentIndex]="0,0,0,0";
				blocks.BCI[currentIndex]=0;
				currentIndex++;		
			}
			for(var z=startz;z<=endz;z++){
				blocks.BlockIds[currentIndex]=fillerblock;
				blocks.BLP[currentIndex]=atos([leftx+xmove,bestra[1],z]);
				blocks.BLR[currentIndex]=0;
				blocks.BP1[currentIndex]="0,0,0,0";
				blocks.BP2[currentIndex]="0,0,0,0";
				blocks.BCI[currentIndex]=0;
				currentIndex++;		
			}
			rightconnected=true;
		}
		if((!leftconnected)||(!rightconnected)){
			alert("Left and right sides might not be connected properly");
		}


		for(var scID = 0; scID < SCcount; scID++){
			var sctype=getType(SClist[scID].ItemNumber);
			var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
			var tpa = stoar((SClist[scID]).LocalPosition);
			var curx = tpa[0];
			if(curx>midx){			
				(SClist[scID]).LocalPosition=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
				//check if turret disconnected
				if((sctype==2)&&(tpa[0]==rightx)){
					var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
					if(Math.round(newpos[0])==-1){
						alert("A turret or spin block might be disconnected after after the process.");
					}
				}
			}else{
				if((sctype==2)&&(tpa[0]==leftx)){
					var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
					if(Math.round(newpos[0])==1){
						alert("A turret or spin block might be disconnected after after the process.");
					}			
				}
				
			}
		}
		cleanBlueprint(blocks);		
	}



	//need to modify when we can check for parts sticking out
	function cutAndMirror(blocks,xshift,even,originID){
		blocks.designChanged = true;
		var SClist=blocks.SCs;
		var minx=0;
		var maxx=0;
		var midx=0;
		var xmove=0;
		var maxmirrorx=0;
		var originfound=false;
		var orix=0;			
		var blocklist=blocks.BlockIds;
		var positionList=blocks.BLP;
		var rotationList=blocks.BLR;
		var bp1list=blocks.BP1;
		var bp2list=blocks.BP2;
		var colorlist=blocks.BCI;
		var beilist=blocks.BEI;	
		var blockcount=blocklist.length; //needed cause variableblocklist :D
		var beiIndex=0;
		var currentIndex = blockcount; //index to add new blocks
		var currentBeiIndex = beilist.length;; //index to add new blocks
		var currentSCIndex=SClist.length;
		var SCcount=SClist.length;
		for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var currentPosition = "["+positionList[blockIndex]+"]";
			var tpa = JSON.parse(currentPosition);
			var curx = Math.round(tpa[0]);
			minx=Math.min(curx,minx);
			maxx=Math.max(curx,maxx);
			if(currentBlock==originID){
				originfound=true;
				orix=Math.round(tpa[0]);
			}			
		}
		if(originfound){
			midx=orix+xshift;	
		}else{
			midx=((minx+maxx)/2)+xshift;				
		}				
		midx=Math.round(midx-0.2);
		
		if(even){
			maxmirrorx=midx;
			xmove=(midx*2)+1;
		}else{
			maxmirrorx=midx-1;
			xmove=midx*2;
		}
		
		for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var tpa = stoar(positionList[blockIndex]);
			var curx = tpa[0];
			if (curx>midx){
				blocklist[blockIndex]=-1;
			}else if (curx<=maxmirrorx){
				var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

				blocks.BlockIds[currentIndex]=mirrordata.blockID;
				var newposition=stoar(mirrordata.position);
				newposition[0]=newposition[0]+xmove;
				blocks.BLP[currentIndex]=atos(newposition);
				blocks.BLR[currentIndex]=mirrordata.rotation;
				blocks.BP1[currentIndex]=bp1list[blockIndex];
				blocks.BP2[currentIndex]=bp2list[blockIndex];
				blocks.BCI[currentIndex]=colorlist[blockIndex];
				if((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]==blockIndex)){
					blocks.BEI[currentBeiIndex]=currentIndex;
					var beiIncrement = beilist[beiIndex+1]+2;
					for(var i=1;i<beiIncrement;i++){
						blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
					}
					beiIndex+=beiIncrement;
					currentBeiIndex+=beiIncrement;
				}else if((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]<blockIndex)){				
					var beiIncrement = beilist[beiIndex+1]+2;
					beiIndex+=beiIncrement;
				}		
				//blocklist[blockIndex]=-1;			
				currentIndex+=1;
			}
					
		}

		for(var scID = 0; scID < SCcount; scID++){
			if(!(SClist[scID].COL)){
				var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
				var tpa = stoar((SClist[scID]).LocalPosition);
				var curx = tpa[0];
				if(curx>midx){
					SClist[scID].ItemNumber=-1;
				}else if (curx<=maxmirrorx){
					tpa[0]=xmove-tpa[0];
					blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
					blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
					blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
					mirrorVehicle(blocks.SCs[currentSCIndex]);
					currentSCIndex++;			
				}			
			}else{
				SClist[scID].ItemNumber=-1;
			}
		}
		cleanBlueprint(blocks);		
	}


	//need to modify when we can check for parts sticking out
	function jointMirror(blocks,even){
		blocks.designChanged = true;
		var SClist=blocks.SCs;
		var minx=0;
		var maxx=0;
		var xmove=0;
		var maxmirrorx=0;
		var blocklist=blocks.BlockIds;
		var positionList=blocks.BLP;
		var rotationList=blocks.BLR;
		var bp1list=blocks.BP1;
		var bp2list=blocks.BP2;
		var colorlist=blocks.BCI;
		var beilist=blocks.BEI;	
		var blockcount=blocklist.length; //needed cause variableblocklist :D
		var beiIndex=0;
		var currentIndex = blockcount; //index to add new blocks
		var currentBeiIndex = beilist.length;; //index to add new blocks
		var currentSCIndex=SClist.length;
		var SCcount=SClist.length;
		for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var currentPosition = "["+positionList[blockIndex]+"]";
			var tpa = JSON.parse(currentPosition);
			var curx = Math.round(tpa[0]);
			minx=Math.min(curx,minx);
			maxx=Math.max(curx,maxx);
		}
		
		
		
		if(even){
			maxmirrorx=maxx;
			xmove=(maxx*2)+1;
		}else{
			maxmirrorx=maxx-1;
			xmove=maxx*2;
		}


		
		for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			var tpa = stoar(positionList[blockIndex]);
			var curx = tpa[0];
			if (curx<=maxmirrorx){
				var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

				blocks.BlockIds[currentIndex]=mirrordata.blockID;
				var newposition=stoar(mirrordata.position);
				newposition[0]=newposition[0]+xmove;
				blocks.BLP[currentIndex]=atos(newposition);
				blocks.BLR[currentIndex]=mirrordata.rotation;
				blocks.BP1[currentIndex]=bp1list[blockIndex];
				blocks.BP2[currentIndex]=bp2list[blockIndex];
				blocks.BCI[currentIndex]=colorlist[blockIndex];
				if((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]==blockIndex)){
					blocks.BEI[currentBeiIndex]=currentIndex;
					var beiIncrement = beilist[beiIndex+1]+2;
					for(var i=1;i<beiIncrement;i++){
						blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
					}
					beiIndex+=beiIncrement;
					currentBeiIndex+=beiIncrement;
				}else if((beilist[beiIndex]!==undefined)&&(beilist[beiIndex]<blockIndex)){				
					var beiIncrement = beilist[beiIndex+1]+2;
					beiIndex+=beiIncrement;
				}		
				//blocklist[blockIndex]=-1;			
				currentIndex+=1;
			}
					
		}

		for(var scID = 0; scID < SCcount; scID++){
			if(!(SClist[scID].COL)){
				var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
				var tpa = stoar((SClist[scID]).LocalPosition);
				var curx = tpa[0];
				if (curx<=maxmirrorx){
					tpa[0]=xmove-tpa[0];
					blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
					blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
					blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
					mirrorVehicle(blocks.SCs[currentSCIndex]);
					currentSCIndex++;			
				}			
			}else{
				SClist[scID].ItemNumber=-1;
			}
		}
		cleanBlueprint(blocks);		
	}





	function beamifyblocks(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  beamifyblocks(SClist[scID]);
	 }
	 var blockPositionData = {};
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 var positionList=blocks.BLP;
	 var rotationList = blocks.BLR;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock = blocklist[blockIndex];
	  if(ItemDic[currentBlock]){
	   if(blockToBeam[currentBlock]){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;    
		//var currentPosition = ""+Math.round(tpa[0])+","+Math.round(tpa[1])+","+Math.round(tpa[2]);
		//targetBlock =blockToBeam[currentBlock];    
		blockPositionData[currentPosition]=blockIndex;    
	   }
	  }
	 }
	 
	 //z=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
	   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
	   }

	  }

	 }//z=axis 
	 

	 //y=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
	   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
	   }

	  }
	 }//y=axis 
	 
	 
	 //x=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
	   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
	   }

	  }
	 }//x=axis  

		cleanBlueprint(blocks);
	}

	function beamifyblocks3m(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  beamifyblocks3m(SClist[scID]);
	 }
	 var blockPositionData = {};
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 var positionList=blocks.BLP;
	 var rotationList = blocks.BLR;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock = blocklist[blockIndex];
	  if(ItemDic[currentBlock]){
	   if(blockToBeam3m[currentBlock]){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;    
	 
		blockPositionData[currentPosition]=blockIndex;    
	   }
	  }
	 }
	 
	 //z=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){

	   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis3m(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
	   }

	  }

	 }//z=axis 
	 

	 //y=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){

	   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis3m(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
	   }

	  }
	 }//y=axis 
	 
	 
	 //x=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){

	   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis3m(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
	   }

	  }
	 }//x=axis  

		cleanBlueprint(blocks);
	}


	function beamifyblocks2m(blocks){
	 var SClist=blocks.SCs;
	 blocks.designChanged = true;
	 for(var scID = 0; scID < SClist.length; scID++){
	  beamifyblocks2m(SClist[scID]);
	 }
	 var blockPositionData = {};
	 var blocklist=blocks.BlockIds;
	 var colorlist=blocks.BCI;
	 var positionList=blocks.BLP;
	 var rotationList = blocks.BLR;
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock = blocklist[blockIndex];
	  if(ItemDic[currentBlock]){
	   if(blockToBeam2m[currentBlock]){
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		var cury = Math.round(tpa[1]);
		var curz = Math.round(tpa[2]);
		currentPosition = ""+curx+","+cury+","+curz;    
	 
		blockPositionData[currentPosition]=blockIndex;    
	   }
	  }
	 }
	 
	 //z=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){

	   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis2m(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
	   }

	  }

	 }//z=axis 
	 

	 //y=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){

	   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis2m(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
	   }

	  }
	 }//y=axis 
	 
	 
	 //x=axis
	 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	  var currentBlock=blocklist[blockIndex];
	  if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){

	   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
	   
	   for(var k=(lookbackArray.length-1);k>=0;k--){
		beamifyaxis2m(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
	   }

	  }
	 }//x=axis  

		cleanBlueprint(blocks);
	}
	
	function beamifyblocksOptimized(blocks){
		var SClist=blocks.SCs;
		blocks.designChanged = true;
		for(var scID = 0; scID < SClist.length; scID++){
			beamifyblocksOptimized(SClist[scID]);
		}
		var blockPositionData = {};
		var blocklist=blocks.BlockIds;
		var colorlist=blocks.BCI;
		var positionList=blocks.BLP;
		var rotationList = blocks.BLR;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			if(ItemDic[currentBlock]){
				if(blockToBeam[currentBlock]){				
					var tpa = stoar(positionList[blockIndex]);
					var currentPosition = atos(tpa);
					blockPositionData[currentPosition]=blockIndex;    
				}
			}
		}

		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock=blocklist[blockIndex];
			if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){

				var localPositionData = {};
				getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
				while(true){
					for(position in localPositionData){
						if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
							delete localPositionData[position];
						}else{
							localPositionData[position].score=0;
						}
					}
					//scoring start
					var localScore=0;
					var beamAxis=0;
					for(position in localPositionData){
						var blockscore=false;
						var currentData=localPositionData[position];
						var lpa = stoar(position);
						var templength;
						var tempdir;
						//scoring for each axis x,y,z
						for (var axis=0;axis<3;axis++){
							templength=1;
							for(var neg=0;neg<2;neg++){
								tempdir=getAxis(axis,neg);
								for(var tempindex=1;tempindex<4;tempindex++){
									var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
									if(localPositionData[tempLocalPosition]!==undefined){
										templength+=1;      
									}else{
										break;
									}
								}
							}
							if (templength>=4){
								
								blockscore=true;
								beamAxis+=1;
								localPositionData[position].score+=(templength-1);
							}
						}
						//score local block
						if(blockscore){
							
							currentData.score+=1;
							localScore+=1;
						}
					}
					
					//proceed if there are beamable blocks
					if (localScore>0){					

						//beamAxis is number of axis that is beamable 

						var scoreTable=[];
						var scoreIndex=0;
						var dedup={};

						//permutate possible beams and scores, then sort
						var minscore=200;
						var scorecap=11;
						for(position in localPositionData){
							var currentData=localPositionData[position];
							var lpa = stoar(position);
							var tempdir1;
							var tempdir2;
							
							for (var axis=0;axis<3;axis++){
							
								dedup={};
								tempdir1=getAxis(axis,true);
								tempdir2=getAxis(axis,false);
								for(tempindex=0;tempindex<4;tempindex++){
									var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
									if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=4)){
										if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-12))){										
											dedup[tempLocalPosition]=true;
											continue;
										}
										var llpa = stoar(tempLocalPosition);
										if(!dedup[tempLocalPosition]){
											var templength=1;
											for(var temptempindex=1;temptempindex<4;temptempindex++){											
												temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
												if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=4)){
													templength+=1;
												}else{
													break;
												}
											}
											if(templength==4){
												
												dedup[tempLocalPosition]=true;
												var scoreBlock=[];
												for(var temptempindex=0;temptempindex<4;temptempindex++){
													temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
													scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
												}
												scoreBlock[4]=BeamAxisRot[axis]; //rotation
												scoreBlock[5]=BeamAxisPriority[axis]; //priority
												scoreBlock[6]=llpa[axis]; //priority2

												var tempscore=scoreBlock[0].score+scoreBlock[1].score+scoreBlock[2].score+scoreBlock[3].score;
												if((tempscore>=16)&&(tempscore<=minscore)){
													minscore=tempscore;
													scoreTable[scoreIndex] = scoreBlock;
													scoreIndex++;
												}
											}
										}
									}else{
										break;
									}
								}							

							}
					  
						}

						//sort
						var bestscore=199;
						while(scoreTable.length>0){
							scoreTable.sort(function(a, b){
								res=(a[0].score+a[1].score+a[2].score+a[3].score)-(b[0].score+b[1].score+b[2].score+b[3].score);
								if(res==0){
									var resa=(a[5]-b[5]);
									if(resa==0){
										return a[6]-b[6];
									}else{
										return resa;
									}
								}else{
									return res;
								}
							});

							currentScoreBlock=scoreTable[0];
							if((currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score)>bestscore){
								break;
							}else{
								bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score;
								currentScoreBlock[0].score=200;
								currentScoreBlock[1].score=200;
								currentScoreBlock[2].score=200;
								currentScoreBlock[3].score=200;							

								blocklist[currentScoreBlock[1].blockIndex]=-1;
								blocklist[currentScoreBlock[2].blockIndex]=-1;
								blocklist[currentScoreBlock[3].blockIndex]=-1;

								blocklist[currentScoreBlock[0].blockIndex]=blockToBeam[currentBlock];
								rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
							}
						}
					}
					else{
						//exit loop if no beamable blocks
						break;
					}
				}//end while
			   //scoring end
			}
		}
		cleanBlueprint(blocks);
	}


	//optimize3m
	function beamifyblocksOptimized3m(blocks){	
		var SClist=blocks.SCs;
		blocks.designChanged = true;
		for(var scID = 0; scID < SClist.length; scID++){
			beamifyblocksOptimized3m(SClist[scID]);
		}
		var blockPositionData = {};
		var blocklist=blocks.BlockIds;
		var colorlist=blocks.BCI;
		var positionList=blocks.BLP;
		var rotationList = blocks.BLR;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			if(ItemDic[currentBlock]){
				if(blockToBeam3m[currentBlock]){		
						
					var tpa = stoar(positionList[blockIndex]);
					var currentPosition = atos(tpa);
					blockPositionData[currentPosition]=blockIndex;    
				}
			}
		}

		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock=blocklist[blockIndex];
			if(ItemDic[currentBlock]&&blockToBeam3m[currentBlock]){
				var localPositionData = {};
				getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
				while(true){
					for(position in localPositionData){
						if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
							delete localPositionData[position];
						}else{
							localPositionData[position].score=0;
						}
					}
					//scoring start
					var localScore=0;
					var beamAxis=0;
					for(position in localPositionData){
						var blockscore=false;
						var currentData=localPositionData[position];
						var lpa = stoar(position);
						var templength;
						var tempdir;
						//scoring for each axis x,y,z
						for (var axis=0;axis<3;axis++){
							templength=1;
							for(var neg=0;neg<2;neg++){
								tempdir=getAxis(axis,neg);
								for(var tempindex=1;tempindex<3;tempindex++){
									var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
									if(localPositionData[tempLocalPosition]!==undefined){
										templength+=1;      
									}else{
										break;
									}
								}
							}
							if (templength>=3){
								
								blockscore=true;
								beamAxis+=1;
								localPositionData[position].score+=(templength-1);
							}
						}
						//score local block
						if(blockscore){
							
							currentData.score+=1;
							localScore+=1;
						}
					}
					
					//proceed if there are beamable blocks
					if (localScore>0){					
						
						//beamAxis is number of axis that is beamable 

						var scoreTable=[];
						var scoreIndex=0;
						var dedup={};

						//permutate possible beams and scores, then sort
						var minscore=150;
						var scorecap=7;
						for(position in localPositionData){
							var currentData=localPositionData[position];
							var lpa = stoar(position);
							var tempdir1;
							var tempdir2;
							
							for (var axis=0;axis<3;axis++){
							
								dedup={};
								tempdir1=getAxis(axis,true);
								tempdir2=getAxis(axis,false);
								for(tempindex=0;tempindex<3;tempindex++){
									var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
									if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=3)){
										if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-9))){										
											dedup[tempLocalPosition]=true;
											continue;
										}
										var llpa = stoar(tempLocalPosition);
										if(!dedup[tempLocalPosition]){
											var templength=1;
											for(var temptempindex=1;temptempindex<3;temptempindex++){											
												temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
												if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=3)){
													templength+=1;
												}else{
													break;
												}
											}
											if(templength==3){
												
												dedup[tempLocalPosition]=true;
												var scoreBlock=[];
												for(var temptempindex=0;temptempindex<3;temptempindex++){
													temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
													scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
												}
												scoreBlock[4]=BeamAxisRot[axis]; //rotation
												scoreBlock[5]=BeamAxisPriority[axis]; //priority
												scoreBlock[6]=llpa[axis]; //priority2

												var tempscore=scoreBlock[0].score+scoreBlock[1].score+scoreBlock[2].score;
												if((tempscore>=9)&&(tempscore<=minscore)){
													minscore=tempscore;
													scoreTable[scoreIndex] = scoreBlock;
													scoreIndex++;
												}
											}
										}
									}else{
										break;
									}
								}							

							}
					  
						}

						//sort
						var bestscore=149;
						while(scoreTable.length>0){
							scoreTable.sort(function(a, b){
								res=(a[0].score+a[1].score+a[2].score)-(b[0].score+b[1].score+b[2].score);
								if(res==0){
									var resa=(a[5]-b[5]);
									if(resa==0){
										return a[6]-b[6];
									}else{
										return resa;
									}
								}else{
									return res;
								}
							});

							currentScoreBlock=scoreTable[0];
							if((currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score)>bestscore){
								break;
							}else{
								bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score;
								currentScoreBlock[0].score=150;
								currentScoreBlock[1].score=150;
								currentScoreBlock[2].score=150;
								

								blocklist[currentScoreBlock[1].blockIndex]=-1;
								blocklist[currentScoreBlock[2].blockIndex]=-1;
								

								blocklist[currentScoreBlock[0].blockIndex]=blockToBeam3m[currentBlock];
								rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
							}
						}
					}
					else{
						//exit loop if no beamable blocks
						break;
					}
				}//end while
			   //scoring end
			}
		}
		cleanBlueprint(blocks);
	}



	//optimize2m
	function beamifyblocksOptimized2m(blocks){	
		var SClist=blocks.SCs;
		blocks.designChanged = true;
		for(var scID = 0; scID < SClist.length; scID++){
			beamifyblocksOptimized2m(SClist[scID]);
		}
		var blockPositionData = {};
		var blocklist=blocks.BlockIds;
		var colorlist=blocks.BCI;
		var positionList=blocks.BLP;
		var rotationList = blocks.BLR;
		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock = blocklist[blockIndex];
			if(ItemDic[currentBlock]){
				if(blockToBeam2m[currentBlock]){		
						
					var tpa = stoar(positionList[blockIndex]);
					var currentPosition = atos(tpa);
					blockPositionData[currentPosition]=blockIndex;    
				}
			}
		}

		for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
			var currentBlock=blocklist[blockIndex];
			if(ItemDic[currentBlock]&&blockToBeam2m[currentBlock]){
				var localPositionData = {};
				getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
				while(true){
					for(position in localPositionData){
						if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
							delete localPositionData[position];
						}else{
							localPositionData[position].score=0;
						}
					}
					//scoring start
					var localScore=0;
					var beamAxis=0;
					for(position in localPositionData){
						var blockscore=false;
						var currentData=localPositionData[position];
						var lpa = stoar(position);
						var templength;
						var tempdir;
						//scoring for each axis x,y,z
						for (var axis=0;axis<3;axis++){
							templength=1;
							for(var neg=0;neg<2;neg++){
								tempdir=getAxis(axis,neg);
								for(var tempindex=1;tempindex<2;tempindex++){
									var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
									if(localPositionData[tempLocalPosition]!==undefined){
										templength+=1;      
									}else{
										break;
									}
								}
							}
							if (templength>=2){
								
								blockscore=true;
								beamAxis+=1;
								localPositionData[position].score+=(templength-1);
							}
						}
						//score local block
						if(blockscore){
							
							currentData.score+=1;
							localScore+=1;
						}
					}
					
					//proceed if there are beamable blocks
					if (localScore>0){					
						
						//beamAxis is number of axis that is beamable 

						var scoreTable=[];
						var scoreIndex=0;
						var dedup={};

						//permutate possible beams and scores, then sort
						var minscore=100;
						var scorecap=2;
						for(position in localPositionData){
							var currentData=localPositionData[position];
							var lpa = stoar(position);
							var tempdir1;
							var tempdir2;
							
							for (var axis=0;axis<3;axis++){
							
								dedup={};
								tempdir1=getAxis(axis,true);
								tempdir2=getAxis(axis,false);
								for(tempindex=0;tempindex<2;tempindex++){
									var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
									if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=2)){
										if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-1))){										
											dedup[tempLocalPosition]=true;
											continue;
										}
										var llpa = stoar(tempLocalPosition);
										if(!dedup[tempLocalPosition]){
											var templength=1;
											for(var temptempindex=1;temptempindex<2;temptempindex++){											
												temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
												if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=2)){
													templength+=1;
												}else{
													break;
												}
											}
											if(templength==2){
												
												dedup[tempLocalPosition]=true;
												var scoreBlock=[];
												for(var temptempindex=0;temptempindex<2;temptempindex++){
													temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
													scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
												}
												scoreBlock[4]=BeamAxisRot[axis]; //rotation
												scoreBlock[5]=BeamAxisPriority[axis]; //priority
												scoreBlock[6]=llpa[axis]; //priority2

												var tempscore=scoreBlock[0].score+scoreBlock[1].score;
												if((tempscore>=2)&&(tempscore<=minscore)){
													minscore=tempscore;
													scoreTable[scoreIndex] = scoreBlock;
													scoreIndex++;
												}
											}
										}
									}else{
										break;
									}
								}							

							}
					  
						}

						//sort
						var bestscore=99;
						while(scoreTable.length>0){
							scoreTable.sort(function(a, b){
								res=(a[0].score+a[1].score)-(b[0].score+b[1].score);
								if(res==0){
									var resa=(a[5]-b[5]);
									if(resa==0){
										return a[6]-b[6];
									}else{
										return resa;
									}
								}else{
									return res;
								}
							});

							currentScoreBlock=scoreTable[0];
							if((currentScoreBlock[0].score+currentScoreBlock[1].score)>bestscore){
								break;
							}else{
								bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score;
								currentScoreBlock[0].score=100;
								currentScoreBlock[1].score=100;
							


								blocklist[currentScoreBlock[1].blockIndex]=-1;
								
								

								blocklist[currentScoreBlock[0].blockIndex]=blockToBeam2m[currentBlock];
								rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
							}
						}
					}
					else{
						//exit loop if no beamable blocks
						break;
					}
				}//end while
			   //scoring end
			}
		}
		cleanBlueprint(blocks);
	}	

	

	//process
	  localProcessData();
		var originID=GuidToID["f817665f-e59a-43a0-9c86-0d39f64b594a"];
		if(originID==undefined){
			originID=-2;
		}	  
	  if(document.getElementById("paintrestrict").checked){
		allowedcolor=tempallowedcolor;
	  }
	  else{
		allowedcolor=-1;
	  }
	  if(document.getElementById("replaceold").checked){
	   buildReplaceOldIndex();
	   replaceOld(CurrentBlueprint.Blueprint);
	   ga('send', 'event', 'bpmod', 'replaceold');
	  }	  
	  if(document.getElementById("clearhull").checked){
		buildkeepIndex();
		clearhull(CurrentBlueprint.Blueprint);
	  }
	  if(document.getElementById("cutinhalf").checked){
		var xshift=parseInt(document.getElementById("centershift").value);
		cutInHalf(CurrentBlueprint.Blueprint,xshift,originID);
	  }
	  if(document.getElementById("cutandmirror").checked){
		var xshift=parseInt(document.getElementById("cloneshift").value);
		var even=document.getElementById("evenclone1").checked;
		cutAndMirror(CurrentBlueprint.Blueprint,xshift,even,originID);
		removeOverlap(CurrentBlueprint.Blueprint);
	  }
	  if(document.getElementById("jointmirror").checked){
		var even=document.getElementById("evenclone2").checked;
		jointMirror(CurrentBlueprint.Blueprint,even);
		removeOverlap(CurrentBlueprint.Blueprint);
	  }
	  if(document.getElementById("widen").checked){
		var xdist=parseInt(document.getElementById("widendistance").value);
		var xshift=parseInt(document.getElementById("widenshift").value);
		widenVehicle(CurrentBlueprint.Blueprint,xdist,xshift,originID);
		removeOverlap(CurrentBlueprint.Blueprint);
	  }

	  if (!isNumeric(document.getElementById("shieldr").value)){
		document.getElementById("shieldr").value=1.0;
	  }
	  if (!isNumeric(document.getElementById("shieldg").value)){
		document.getElementById("shieldg").value=1.0;
	  }
	  if (!isNumeric(document.getElementById("shieldb").value)){
		document.getElementById("shieldb").value=1.0;
	  }
	  if (!isNumeric(document.getElementById("shielda").value)){
		document.getElementById("shielda").value=1.0;
	  }
	  if(document.getElementById("shieldcolor").checked){
		ga('send', 'event', 'bpmod', 'shieldcolor');
	  }
	  
	  document.getElementById("shieldr").value=Math.min(1.0,document.getElementById("shieldr").value);
	  document.getElementById("shieldg").value=Math.min(1.0,document.getElementById("shieldg").value);
	  document.getElementById("shieldb").value=Math.min(1.0,document.getElementById("shieldb").value);
	  document.getElementById("shielda").value=Math.min(10.0,document.getElementById("shielda").value);
	  document.getElementById("shieldr").value=Math.max(0.0,document.getElementById("shieldr").value);
	  document.getElementById("shieldg").value=Math.max(0.0,document.getElementById("shieldg").value);
	  document.getElementById("shieldb").value=Math.max(0.0,document.getElementById("shieldb").value);
	  document.getElementById("shielda").value=Math.max(0.10,document.getElementById("shielda").value);
	  buildconversionIndex();
	  buildblockColorIndex();
	  convertblocks(CurrentBlueprint.Blueprint);
	  if(document.getElementById("randomcolor").checked){
		randomcolorblocks(CurrentBlueprint.Blueprint);
	  }
	  else{
		if(document.getElementById("paint").checked){
		  colorblocks(CurrentBlueprint.Blueprint);
		}
		if(singleFile&&CurrentBlueprint.Blueprint.COL&&colorTable2){
		  for(var palID=0;palID<32;palID++){
			if(colorTable2[palID]&&colorTable2[palID].changed){
			  CurrentBlueprint.Blueprint.COL[palID]=atos(colorTable2[palID].colorN);			  
			}
		  }
		}else if(!singleFile&&document.getElementById("applymultipalette").checked){
			if(CurrentBlueprint.Blueprint.COL){
				CurrentBlueprint.Blueprint.COL=newPalette;
			}
		}
		if(CurrentBlueprint.Blueprint.COL&&document.getElementById("scpalette").checked){
		  var SClist=CurrentBlueprint.Blueprint.SCs;
		  for(var scID = 0; scID < SClist.length; scID++){
			if(SClist[scID].COL){
			  SClist[scID].COL=CurrentBlueprint.Blueprint.COL;
			}
		  }
		}

	  }
	  if(document.getElementById("becomeStructure").checked){
		//CurrentBlueprint.Blueprint.ItemNumber=ItemTable["cb5bfa64-c3fd-435c-b0da-3891a86b20d2"].BlockId;
		CurrentBlueprint.Blueprint.ItemNumber=GuidToID["cb5bfa64-c3fd-435c-b0da-3891a86b20d2"];
		becomeStructure(CurrentBlueprint.Blueprint,false);
	  }
	  else if(document.getElementById("becomeVehicle").checked){
		//CurrentBlueprint.Blueprint.ItemNumber=ItemTable["e63040c9-0027-4fd3-be30-67fe3e950140"].BlockId;
		CurrentBlueprint.Blueprint.ItemNumber=GuidToID["e63040c9-0027-4fd3-be30-67fe3e950140"];
		becomeVehicle(CurrentBlueprint.Blueprint);
	  }
	  else if(document.getElementById("becomeFortress").checked){
		//CurrentBlueprint.Blueprint.ItemNumber=ItemTable["74c982f4-305f-411e-a8b4-d193315ab3bc"].BlockId;
		CurrentBlueprint.Blueprint.ItemNumber=GuidToID["74c982f4-305f-411e-a8b4-d193315ab3bc"];
		becomeFortress(CurrentBlueprint.Blueprint);
	  }
	  if(document.getElementById("rotateVehicle").checked){
		rotateBlueprint(CurrentBlueprint.Blueprint,document.getElementById("rotatedir").value);
	  }
	  if(document.getElementById("mirrorLateral").checked){
		mirrorVehicle(CurrentBlueprint.Blueprint);
	  }
	  if(document.getElementById("debeamify").checked){
		blocksDebeamed = 0;
		debeamifyblocks(CurrentBlueprint.Blueprint);
		debeamifyslopeblocks(CurrentBlueprint.Blueprint);
	  }
	  if(document.getElementById("beamifyOptimized").checked){
		blocksBeamed = 0;
		beamifyslopeblocks(CurrentBlueprint.Blueprint);
		beamifyblocksOptimized(CurrentBlueprint.Blueprint);
		beamifyblocksOptimized3m(CurrentBlueprint.Blueprint);
		beamifyblocks2m(CurrentBlueprint.Blueprint);
		ga('send', 'event', 'bpmod', 'beam', 'optimized');
		/*
		beamifyblocksOptimized2m(CurrentBlueprint.Blueprint);
		*/

	  }
	  else if(document.getElementById("beamify2").checked){
		blocksBeamed = 0;
		beamifyslopeblocks(CurrentBlueprint.Blueprint);
		beamifyblocks(CurrentBlueprint.Blueprint);
		beamifyblocks3m(CurrentBlueprint.Blueprint);
		beamifyblocks2m(CurrentBlueprint.Blueprint);
		ga('send', 'event', 'bpmod', 'beam', 'normal');
	  }
	  updateBlockCount(CurrentBlueprint.Blueprint);
	  //console.log("processing complete.");
	  //selectedFileName = "Modified_" + selectedFileName;

	  
	if(fi==selectedIndex){
		processData(selectedIndex);
	};
}

function updateBluePrintTO(fi){

	if(document.getElementById("paint").checked){
	  
	    if(document.getElementById("painttarget").value=="blockfilter"){
			blockFilterTable={};
			$('#table1.hasFilters tbody tr:visible').each(function(){
				/*
				console.log($(this).attr("blockid"));
				console.log(ItemDic[$(this).attr("blockid")]);
				*/
				blockFilterTable[ItemDic[$(this).attr("blockid")]]=true;
			
			});		
			
	    }
	}
	
	setTimeout(function(){
		try{
			updateBluePrint(fi);
		}finally{
			runningCount--;
		}				
	}
	,10);
};

function downloadBlueprint2(){
	console.log("processing...");
	$(".dl").prop('disabled',true);
	$(".dl").parent().addClass('ui-state-disabled');
	$.mobile.loading("show", {
		text: "Processing...",
		textVisible: true,
		textonly: true,
	});
	runningCount = currentBlueprints.length;
	runningTimeOut = 3000*runningCount;
	ga('send', 'event', 'bpmod', 'download', 'download' ,runningCount);
	if(!singleFile&&document.getElementById("applymultipalette").checked){
		newPalette=[];
		for(var palID = 0; palID < 32; palID++){
				if(colorTable2[palID]){
				  newPalette[palID]=colorTable2[palID].colorN[0]+","+colorTable2[palID].colorN[1]+","+colorTable2[palID].colorN[2]+","+colorTable2[palID].colorN[3];
				}
				else{
				  newPalette[palID]="0,0,0,0";
				}
		}
	}
	for(var fi=0;fi<currentBlueprints.length;fi++){
		updateBluePrintTO(fi);	
	}

	function waitRunning() {
		
		if((runningCount>0)&&(runningTimeOut>0)) {
			//console.log("wait");
			runningTimeOut-=1;
			setTimeout(waitRunning, 100);
			return;
		}else{
			console.log("done");
			if(runningCount>runningTimeOut){
				console.log("Time Out during processing.");
			}
			
			
			
			if(singleFile){
			
				document.getElementById("filecontent").style.display="block";
				document.getElementById("filetext").style.display="none";
				var outputcontent=JSON.stringify(currentBlueprints[0]);
				document.getElementById("filetextbox").value=outputcontent;
				console.log("downloading file: modified_"+currentFilenames[0]);
				download("modified_"+currentFilenames[0],outputcontent);

			}else{
				var zipfile = new JSZip();
				for(var fi=0;fi<currentBlueprints.length;fi++){
					zipfile.file("modified_"+currentFilenames[fi], JSON.stringify(currentBlueprints[fi]));
				}			
				
				zipfile.generateAsync({type:"blob"})
				.then(function (blobdata) {
					download("blueprints.zip",blobdata);
				});			
			
			}
			
			$(".dl").prop('disabled',false);
			$(".dl").parent().removeClass('ui-state-disabled');	
			$.mobile.loading( "hide" );			
		}
	}
	waitRunning();	
	

}



function togglefiletext(){
  if(document.getElementById("filetext").style.display=="none"){
	document.getElementById("filetext").style.display="block";
	document.getElementById("filetextbox").select();
  }
  else{
	document.getElementById("filetext").style.display="none";
  }
}


function slopeBeamToBlockOrientation(blockrotate, mirrored){
  if(mirrored){
	switch (blockrotate) {
	  case 0:
		return 1;
	  case 1:
		return 2;
	  case 2:
		return 3;
	  case 3:
		return 0;
	  case 4:
		return 16;
	  case 5:
		return 17;
	  case 6:
		return 19;
	  case 7:
		return 18;
	  case 8:
		return 18;
	  case 9:
		return 16;
	  case 10:
		return 17;
	  case 11:
		return 19;
	  case 12:
		return 7;
	  case 13:
		return 4;
	  case 14:
		return 5;
	  case 15:
		return 6;
	  case 16:
		return 5;
	  case 17:
		return 1;
	  case 18:
		return 3;
	  case 19:
		return 7;
	  case 20:
		return 0;
	  case 21:
		return 4;
	  case 22:
		return 6;
	  case 23:
		return 2;
	  default:
		return -1;
	}
  }
  else{
	switch (blockrotate) {
	  case 0:
		return 3;
	  case 1:
		return 0;
	  case 2:
		return 1;
	  case 3:
		return 2;
	  case 4:
		return 18;
	  case 5:
		return 16;
	  case 6:
		return 17;
	  case 7:
		return 19;
	  case 8:
		return 16;
	  case 9:
		return 17;
	  case 10:
		return 19;
	  case 11:
		return 18;
	  case 12:
		return 5;
	  case 13:
		return 6;
	  case 14:
		return 7;
	  case 15:
		return 4;
	  case 16:
		return 1;
	  case 17:
		return 5;
	  case 18:
		return 7;
	  case 19:
		return 3;
	  case 20:
		return 4;
	  case 21:
		return 0;
	  case 22:
		return 2;
	  case 23:
		return 6;
	  default:
		return -1;
	}
  }
  return -1;
}
function slopeBlockToBeamOrientation(beamrotate, negative){
  //negative not implemented
  switch (beamrotate) {
	case 0:
	case 8:
	  return 1;
	case 2:
	case 10:
	  return 22;
	case 4:
	case 12:
	  return 20;
	case 6:
	case 14:
	  return 13;
	case 1:
	case 9:
	  return 16;
	case 3:   
	case 11:
	  return 0;
	case 5:  
	case 13:
	  return 12;
	case 7:  
	case 15:
	  return 18;
	case 16:  
	case 20:
	  return 8;
	case 17:  
	case 22:
	  return 9;
	case 18:   
	case 21:
	  return 11;
	case 19:   
	case 23:
	  return 10;
	default:
	  return -1;
  }
  return -1;
}
function quatMirror(quat){
  var resquat = stoa(quat);
  resquat[0] = -resquat[0];
  resquat[3] = -resquat[3];
  return atos(resquat);
}

function flipX(position){
  var pa=stoar(position);
  pa[0]=(-pa[0]);
  var strposition = ""+pa[0]+","+pa[1]+","+pa[2];
  return strposition;
}
function rotationMirror(blockrotate){
  var q=getQuat(blockrotate);
  if(q){
	q[0]=-q[0];
	q[3]=-q[3];
	return getRot(q);
  }
  else{
	return -1;
  }
}
//rotate block rotation
function blockRotate(blockrotate,dir){
  var q=getQuat(blockrotate);
  if(q){
	var q1=getQuat(dir);
	return getRot(quatmul(q1,q));
  }
  else{
	return -1;
  }
}
//rotate block position
function positionRotate(position,dir){
  var pa=stoar(position);
  return atos(posTransform(pa,getQuat(dir)));
}
//rotate block quat
function quatRotate(quat,dir){
  return atos(quatmul(getQuat(dir),stoa(quat)));
}
function sameSlopeBlockOrientation(rotate1,rotate2){
  if(rotate1==rotate2){
	return true;
  }
  var r1=Math.min(rotate1,rotate2);
  var r2=Math.max(rotate1,rotate2);
  if((r1==0&&r2==8)||(r1==1&&r2==9)||(r1==2&&r2==10)||(r1==3&&r2==11)||(r1==4&&r2==12)||(r1==5&&r2==13)||(r1==6&&r2==14)||(r1==7&&r2==15)||(r1==16&&r2==20)||(r1==17&&r2==22)||(r1==18&&r2==21)||(r1==19&&r2==23)){
	return true;
  }
  else{
	return false;
  }
}
//download file
//text/plain
//application/json
function download(filename, data) {
  var blob = new Blob([data], {
	type: 'text/plain'}
					 );
  if(window.navigator.msSaveOrOpenBlob) {
	window.navigator.msSaveBlob(blob, filename);
  }
  else{
	var elem = window.document.createElement('a');
	elem.href = window.URL.createObjectURL(blob);
	elem.download = filename;
	document.body.appendChild(elem)
	elem.click();
	document.body.removeChild(elem);
  }
}
//load palette for new palettetool
var colorTable2={
};
function getpalette2(blocks){
  //console.log("tempallowedcolor: "+tempallowedcolor);
  colorTable2={
  };
  //tempallowedcolor=0;
  var palettedata = blocks.COL;
  if(palettedata){
	for(var palID = 0; palID < palettedata.length; palID++){
	  var colorString = palettedata[palID];
	  var colorArray = colorString.split(',');
	  var tempcolor = {
	  };
	  tempcolor.colorA=colorArray;
	  tempcolor.colorN=colorArray;
	  tempcolor.colorS="rgba("+Math.round(colorArray[0]*255)+","+Math.round(colorArray[1]*255)+","+Math.round(colorArray[2]*255)+","+colorArray[3]+")";
	  tempcolor.changed=false;
	  colorTable2[palID]=tempcolor;
	  //$("#pal-overlay-"+palID).css('background-color', tempcolor.colorS);
	  $(".color-overlay-"+palID).css('background-color', tempcolor.colorS);
	  //$("#co-overlay-"+palID).css('background-color', tempcolor.colorS);
	  if(tempallowedcolor==palID){
		$("#popupallowedcolorbutton-overlay").css('background-color', tempcolor.colorS);
		//console.log("triggered!");
	  }
	  if(temppaintcolor==palID){
		$("#popuppaintcolorbutton-overlay").css('background-color', tempcolor.colorS);
		//console.log("triggered!");
	  }
	  //console.log("#pal-overlay-"+palID);
	  //console.log(palID + ": " + tempcolor.colorS);
	}
  }
};

function isString(arrayIndex,str,currentData ){
	tempresult=true;
	for(var i=0;i<str.length;i++){
		if(currentData.length<=arrayIndex+i){
			tempresult=false;
			break;
		}
		else if(currentData[arrayIndex+i]==str.charCodeAt(i)){
			continue;
		}else{
			tempresult=false;
			break;
		}
	}

	return tempresult;
}
function getCurrentPalette(){
  var temppalette=[32];
  for(var palID = 0; palID < 32; palID++){
	if(colorTable2[palID]){
	  temppalette[palID]=colorTable2[palID].colorN;
	}
	else{
	  temppalette[palID]=[0,0,0,0];
	}
  }
  return temppalette;
}
function resetPalette(){
  for(var palID = 0; palID < 32; palID++){
	if(colorTable2[palID]){
	  var tempcolor=colorTable2[palID];
	  if(tempcolor.changed){
		tempcolor.colorN=tempcolor.colorA;
		var colorArray=tempcolor.colorA;
		tempcolor.colorS="rgba("+Math.round(colorArray[0]*255)+","+Math.round(colorArray[1]*255)+","+Math.round(colorArray[2]*255)+","+colorArray[3]+")";
		tempcolor.changed=false;
		colorTable2[palID]=tempcolor;
		$(".color-overlay-"+palID).css('background-color', tempcolor.colorS);
		if(tempallowedcolor==palID){
		  $("#popupallowedcolorbutton-overlay").css('background-color', tempcolor.colorS);
		  //console.log("triggered!");
		}
		if(temppaintcolor==palID){
		  $("#popuppaintcolorbutton-overlay").css('background-color', tempcolor.colorS);
		  //console.log("triggered!");
		}
	  }
	}
  }
  $('#palettelist').val("");
  $('#palettelist').selectmenu('refresh');
  $('#palettename').val("");
}
/*
toastr.info();
toastr.warning();
toastr.success();
toastr.error();
*/
function verifyName(name){
  var checker = /^[A-Za-z0-9_-]+$/
  return checker.test(name);
}
function savePalette(){
  var palettename=$("#palettename").val();
  //verify palette;
  if(verifyName(palettename)){
	localforage.setItem("ftdpal:"+palettename, getCurrentPalette(), function (err) {
	  if(err){
		toastr.error("saving error");
		console.log("error saving palette: "+err);
	  }
	  else{
		toastr.success(palettename+" saved");
		loadPalettes();
	  }
	  // if err is non-null, we got an error
	}
					   );
  }
  else{
	toastr.error("Invalid Name:\r\nPlease use alphabets, numbers, underscore and hyphens only.");
	$("#palettename").focus();
	$("#palettename").select();
  }
}
function loadPalette(palettename){
  localforage.getItem(palettename, function (err, value) {
	if(err){
	  toastr.error("error");
	  console.log("error loading palette: "+palettename + "error: "+err);
	}
	else{
	  var tempnameArray=palettename.split(':');
	  if(tempnameArray.length>1){
		for(var palID = 0; palID < 32; palID++){
		  var colorArray = value[palID];
		  var colorString = "rgba("+Math.round(colorArray[0]*255)+","+Math.round(colorArray[1]*255)+","+Math.round(colorArray[2]*255)+","+colorArray[3]+")";
		  if(colorTable2&&colorTable2[palID]){
			colorTable2[palID].colorN=colorArray;
			colorTable2[palID].colorS=colorString;
			colorTable2[palID].changed=true;
		  }
		  $(".color-overlay-"+palID).css('background-color', colorString);
		  if(tempallowedcolor==palID){
			$("#popupallowedcolorbutton-overlay").css('background-color', colorString);
		  }
		  if(temppaintcolor==palID){
			$("#popuppaintcolorbutton-overlay").css('background-color', colorString);
		  }
		}
		$('#palettelist').val("");
		$('#palettelist').selectmenu('refresh');
		$('#palettename').val(tempnameArray[1]);
		toastr.success(tempnameArray[1]+" loaded");
	  }
	  else{
		toastr.error("error");
		console.log("error loading palette: "+palettename + "error: "+err);
	  }
	}
	// if err is non-null, we got an error. otherwise, value is the value 
  }
					 );
}
function removePalette(){
  palettename=$("#palettename").val();
  if(verifyName(palettename)){
	localforage.removeItem("ftdpal:"+palettename, function (err) {
	  console.log(err);
	  if(!err){
		$('#palettename').val("");
		toastr.info(palettename+ " deleted");
		loadPalettes();
	  }
	}
						  );
  }
}
function loadPalettes(){
  $('#palettelist').val("");
  $('#palettelist').html('<option value="" selected>Load Palette</option>');
  if ($('#palettelist').hasClass('ui-select')) {
	$('#palettelist').selectmenu('refresh');
  }
  localforage.keys(function (err, value) {
	if(err){
	  console.log("error loading palettes: "+err);
	}
	else{
	  //console.log(value);
	  for(var i=0;i<value.length;i++){
		var tempnameArray=value[i].split(':');
		if(tempnameArray.length>1){
		  $('#palettelist').append('<option value="'+value[i]+'">'+tempnameArray[1]+'</option>');
		}
	  }
	}
	// if err is non-null, we got an error. otherwise, value is the value
  }
				  );
}
//loads color palette
function getpalette(blocks){
  colorTableInverse=[];
  colorTable=[];
  var palettedata = blocks.COL;
  if(palettedata){
	for(var palID = 0; palID < palettedata.length; palID++){
	  var palStr = "" + palID;
	  if (palStr.length<2){
		palStr = "0" + palStr;
	  }
	  var colorString = palettedata[palID];
	  var colorArray = colorString.split(',');
	  var tempr = (colorArray[0] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
	  var tempg = (colorArray[1] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
	  var tempb = (colorArray[2] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
	  var rtempr = ((1-colorArray[0]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
	  var rtempg = ((1-colorArray[1]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
	  var rtempb = ((1-colorArray[2]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
	  colorTable[palID]=rgb2hex(tempr,tempg,tempb);
	  colorTableInverse[palID]=rgb2hex(rtempr,rtempg,rtempb);
	  //document.getElementById("pal" + palStr).style.backgroundColor = colorTable[palID];
	  //document.getElementById("pal" + palStr).style.color = colorTableInverse[palID];
	  //document.getElementById("co" + palStr).style.backgroundColor = colorTable[palID];
	  //document.getElementById("co" + palStr).style.color = colorTableInverse[palID];
	}
	//$( ".palette" ).change();
  }
  else{
	for(var palID=0;palID<32;palID++){
	  palStr = "" + palID;
	  if (palStr.length<2){
		palStr = "0" + palStr;
	  }
	  colorTable[palID]=rgb2hex(255,255,255);
	  colorTableInverse[palID]=rgb2hex(0,0,0);
	  //document.getElementById("pal" + palStr).style.backgroundColor = colorTable[palID];
	  //document.getElementById("pal" + palStr).style.color = colorTableInverse[palID];
	  //document.getElementById("co" + palStr).style.backgroundColor = colorTable[palID];
	  //document.getElementById("co" + palStr).style.color = colorTableInverse[palID];	
	}
  }
}
function countblocks(blocks){
  blockRenderData={
  };
  blockRenderIndex=0;
  maxc=[0,0,0,0];
  minc=[0,0,0,0];
  totalstats["Game Version*"]=blocks.GameVersion;
  return countblocksR(blocks,false,{
  }
					  ,[0,0,0],[0,0,0,1]);
}
//counts blocks and accumulate vehicle data
function countblocksR(blocks,notmain,parentpalette,parentposition,parentrotation){
  var shiftposition =[0,0,0];
  var shiftRotation =[0,0,0,1];
  if(notmain){
	shiftposition=stoa3(blocks.LocalPosition);
	shiftRotation=stoa(blocks.LocalRotation);
  }
  var SClist=blocks.SCs;
  for(var scID = 0; scID < SClist.length; scID++){
	countblocksR(SClist[scID],true,blocks.COL,shiftposition,shiftRotation);
  }
  totalstats["Max Power*"] += Math.max(0,blocks.CSI[7]);
  totalstats["Max Battery Capacity*"] += Math.max(0,blocks.CSI[49]);
  totalstats["Max Ammo Capacity*"] += Math.max(0,blocks.CSI[38]);
  totalstats["Max Fuel Capacity*"] += Math.max(0,blocks.CSI[40]);
  if(blocks.designChanged){
	totalstats["Blueprint Modified*"] = true;
  }
  var blocklist=blocks.BlockIds;
  for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	countID[blocklist[blockIndex]] +=1;
	var currentBlock = getBlock(blocklist[blockIndex]);
	var tempRender={
	}
	var tempPosition=stoa3(blocks.BLP[blockIndex]);
	var tempRotation=getQuat(blocks.BLR[blockIndex]);
	if(notmain){
	  var ttPosition=posTransformNR(shiftposition,parentrotation);
	  //tempPosition=(tempPosition[0]+shiftRotation[0],tempPosition[1]+shiftRotation[1],tempPosition[2]+shiftRotation[2]);
	  tempPosition=posTransformNR(tempPosition,shiftRotation);
	  tempPosition=posTransformNR(tempPosition,parentrotation);
	  tempPosition=[tempPosition[0]+ttPosition[0]+parentposition[0],tempPosition[1]+ttPosition[1]+parentposition[1],tempPosition[2]+ttPosition[2]+parentposition[2]];
	  var ttrotation=quatmul(parentrotation,shiftRotation);
	  //tempRotation=quatmul(shiftRotation,tempRotation);  
	  //tempRotation=quatmul(parentrotation,tempRotation);  
	  tempRotation=quatmul(ttrotation,tempRotation);
	}
	var tempColor=[80,80,80,1];
	if(colorID[blocklist[blockIndex]]){
	  tempColor=colorID[blocklist[blockIndex]];
	}
	var paintColor=[0,0,0,0];
	if(blocks.COL){
	  paintColor=stoa(blocks.COL[blocks.BCI[blockIndex]]);
	}
	else{
	  paintColor=stoa(parentpalette[blocks.BCI[blockIndex]]);
	}
	var tempr = (paintColor[0] * 255 * (paintColor[3])) +(tempColor[0]*(1-paintColor[3]));
	var tempg = (paintColor[1] * 255 * (paintColor[3])) +(tempColor[1]*(1-paintColor[3]));
	var tempb = (paintColor[2] * 255 * (paintColor[3])) +(tempColor[2]*(1-paintColor[3]));
	var tempa = Math.max(paintColor[3]+tempColor[3],1);
	//tempColor = [tempr,tempg,tempb,tempa];
	tempColor=rgb2hex(tempr, tempg, tempb);
	var posx=0;
	var negx=0;
	var posy=0;
	var negy=0;
	var posz=0;
	var negz=0;
	if(currentBlock){
	  posx=currentBlock.posx;
	  negx=currentBlock.negx;
	  posy=currentBlock.posy;
	  negy=currentBlock.negy;
	  posz=currentBlock.posz;
	  negz=currentBlock.negz;
	  totalstats["Material Cost"]+=currentBlock.Material;
	  totalstats["Volume"]+=currentBlock.Volume;
	}
	tempRender.position=tempPosition;
	tempRender.rotation=tempRotation;
	tempRender.posx=posx;
	tempRender.negx=negx;
	tempRender.posy=posy;
	tempRender.negy=negy;
	tempRender.posz=posz;
	tempRender.negz=negz;
	tempRender.color=tempColor;
	maxc[0]=Math.max(maxc[0],tempPosition[0]);
	maxc[1]=Math.max(maxc[1],tempPosition[1]);
	maxc[2]=Math.max(maxc[2],tempPosition[2]);
	minc[0]=Math.min(minc[0],tempPosition[0]);
	minc[1]=Math.min(minc[1],tempPosition[1]);
	minc[2]=Math.min(minc[2],tempPosition[2]);
	blockRenderData[blockRenderIndex]=tempRender;
	blockRenderIndex++
  }
}
//check for numeric
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
//change colors to hex format
function rgb2hex(red, green, blue) {
  var rgb = blue | (green << 8) | (red << 16);
  return '#' + (0x1000000 + rgb).toString(16).slice(1)
}
//getblockdata
function getBlock(bid){
  return ItemTable[ItemDic[bid]];
}
function roundToTwo(num) {
  return +(Math.round(num + "e+2")  + "e-2");
}
</script>	
</head>

<body>

	<div data-role="page">
		<div class="fullscreen-overlay"></div>
		<div data-role="header">
			<a href="#popupMenu" data-rel="popup" class="ui-btn ui-corner-all ui-shadow ui-btn-inline ui-icon-gear ui-btn-icon-left ui-btn-a">Links
			</a>
			<h1>Blueprint Modification Tool
			</h1>
		</div>
		<!-- /header -->
		<div data-role="content">
			<div data-role="popup" id="popupMenu">
				<ul id="linklist" data-role="listview" data-inset="true" style="min-width:210px;">
				</ul>
			</div>
			<p>Last updated for FTD 
				<span id="version">v1.95864
				</span>
				<span id="mod-ac-version" class="mod-ac">&nbsp;
				</span>
			</p>
			<p>The version for FTD v1.9572 can be found 
				<a data-ajax='false' href="blueprint-modification-1.9572.html">here
				</a>
			</p>
			<br>
			<p>To start, click on the button below and choose a blueprint file.
			</p>
			<br>	
			<p>Please report any issues in the forum thread 
				<a href="https://www.fromthedepthsgame.com/forum/showthread.php?tid=19547">here
				</a>
			</p>
			<div class="hidden">
				<input type="file" id="blueprintfile" accept=".blueprint, .schematic" onchange="openFile('blueprintfile');">
				<input type="file" id="blueprintfiles" accept=".blueprint" multiple onchange="openFile('blueprintfiles');">
				
			</div>					
			<div class="ui-grid-a">
				<div class="ui-block-a">
					<input class="lb" type="button" btarget="#blueprintfile" value="Open Blueprint/Schematic" disabled>
				</div>
				<div class="ui-block-b">
					<input class="lb" type="button" btarget="#blueprintfiles" value="Open Multiple Blueprints" disabled>
				</div>					
			</div>
			<div class="ui-grid-a">
				<div class="ui-block-a">
					<div id="blocktoolpanel" data-role="collapsible">
						<h4>Block Modification Tools
						</h4>
						<br>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox" >
								<input class="bigbox" id="paintrestrict" type="checkbox" data-role="none">Restrict block modifications to blocks colored: 
								</label>
							</div>
							<div class="ui-block-b">
								<!--<a id="popupallowedcolorbutton" href="#popupallowedcolor" data-rel="popup" data-position-to="window" class="ui-btn ui-corner-all ui-shadow ui-btn-a sp-preview" data-transition="pop">0</a>-->
								<button id="popupallowedcolorbutton" class="ui-btn ui-btn-inline">
								</button>
								<div data-role="popup" id="popupallowedcolor" data-theme="a" class="ui-corner-all">
									<div class="ui-grid-solo">
										<div class="ui-block-a">
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
											<button class="ui-btn ui-btn-inline cobutton"> 
											</button>
										</div>
									</div>
								</div>
							</div>
						</div>
						<hr>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="wood" type="checkbox" data-role="none">Convert Wood: 
									<select id="woodto" data-role="none">
										<option value="wood" selected="selected"> to Wood
										</option>
										<option value="alloy" >to Alloy
										</option>
										<option value="metal">to Metal
										</option>
										<option value="glass">to Glass
										</option>
										<option value="heavyarmour">to Heavy Armour
										</option>
										<option value="stone">to Stone
										</option>
										<option value="lead">to Lead
										</option>
										<option value="kca" class="mod-ac">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="metal" type="checkbox" data-role="none">Convert Metal: 
									<select id="metalto" data-role="none">
										<option value="wood" > to Wood
										</option>
										<option value="alloy" >to Alloy
										</option>
										<option value="metal" selected="selected">to Metal
										</option>
										<option value="glass">to Glass
										</option>
										<option value="heavyarmour">to Heavy Armour
										</option>
										<option value="stone">to Stone
										</option>
										<option value="lead">to Lead
										</option>
										<option value="kca" class="mod-ac">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="alloy" type="checkbox" data-role="none">Convert Alloy: 
									<select id="alloyto" data-role="none">
										<option value="wood" > to Wood
										</option>
										<option value="alloy" selected="selected">to Alloy
										</option>
										<option value="metal">to Metal
										</option>
										<option value="glass">to Glass
										</option>
										<option value="heavyarmour">to Heavy Armour
										</option>
										<option value="stone">to Stone
										</option>
										<option value="lead">to Lead
										</option>
										<option value="kca" class="mod-ac">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="glass" type="checkbox" data-role="none">Convert Glass: 
									<select id="glassto" data-role="none">
										<option value="wood" > to Wood
										</option>
										<option value="alloy" >to Alloy
										</option>
										<option value="metal">to Metal
										</option>
										<option value="glass" selected="selected">to Glass
										</option>
										<option value="heavyarmour">to Heavy Armour
										</option>
										<option value="stone">to Stone
										</option>
										<option value="lead">to Lead
										</option>
										<option value="kca" class="mod-ac">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="heavyarmour" type="checkbox" data-role="none">Convert Heavy Armour: 
									<select id="heavyarmourto" data-role="none">
										<option value="wood" > to Wood
										</option>
										<option value="alloy" >to Alloy
										</option>
										<option value="metal">to Metal
										</option>
										<option value="glass">to Glass
										</option>
										<option value="heavyarmour" selected="selected">to Heavy Armour
										</option>
										<option value="stone">to Stone
										</option>
										<option value="lead">to Lead
										</option>
										<option value="kca" class="mod-ac">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="stone" type="checkbox" data-role="none">Convert Stone: 
									<select id="stoneto" data-role="none">
										<option value="wood" > to Wood
										</option>
										<option value="alloy" >to Alloy
										</option>
										<option value="metal">to Metal
										</option>
										<option value="glass">to Glass
										</option>
										<option value="heavyarmour">to Heavy Armour
										</option>
										<option value="stone" selected="selected">to Stone
										</option>
										<option value="lead">to Lead
										</option>
										<option value="kca" class="mod-ac">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="lead" type="checkbox" data-role="none">Convert Lead: 
									<select id="leadto" data-role="none">
										<option value="wood" > to Wood
										</option>
										<option value="alloy" >to Alloy
										</option>
										<option value="metal">to Metal
										</option>
										<option value="glass">to Glass
										</option>
										<option value="heavyarmour">to Heavy Armour
										</option>
										<option value="stone">to Stone
										</option>
										<option value="lead" selected="selected">to Lead
										</option>
										<option value="kca" class="mod-ac">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<div class="ui-grid-solo mod-ac">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="kca" type="checkbox" data-role="none">Convert KCA: 
									<select id="kcato" data-role="none">
										<option value="wood" > to Wood
										</option>
										<option value="alloy" >to Alloy
										</option>
										<option value="metal">to Metal
										</option>
										<option value="glass">to Glass
										</option>
										<option value="heavyarmour">to Heavy Armour
										</option>
										<option value="stone">to Stone
										</option>
										<option value="lead">to Lead
										</option>
										<option value="kca"  selected="selected">to KCA
										</option>										
										<option value="0" >delete!
										</option>
									</select>
								</label>
							</div>
						</div>
						<hr>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="cramSwap" type="checkbox" data-role="none">Swap CRAM Pellets: 
									<select id="cramFrom" data-role="none">
										<option value="4bd38234-b485-4a94-bc2d-d3fc80d89955" >High Explosive
										</option>
										<option value="47c8ddc8-9dca-4363-a39e-95dd28008e30" >Hardener
										</option>
										<option value="87142f81-71ce-4d60-9b81-4fe5674112db">EMP
										</option>
										<option value="379c94e6-7f27-42ab-ab45-66e3533ecde8">Fragmentationn
										</option>
									</select> 
									&nbsp; to &nbsp; 
									<select id="cramTo" data-role="none">
										<option value="4bd38234-b485-4a94-bc2d-d3fc80d89955" >High Explosive
										</option>
										<option value="47c8ddc8-9dca-4363-a39e-95dd28008e30" >Hardener
										</option>
										<option value="87142f81-71ce-4d60-9b81-4fe5674112db">EMP
										</option>
										<option value="379c94e6-7f27-42ab-ab45-66e3533ecde8">Fragmentationn
										</option>
									</select>									
								</label>
							</div>
						</div>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox" ><input class="bigbox" id="tosolidclip" type="checkbox" data-role="none">Convert APS ammo clips to solid clips</label>
							</div>
							<div class="ui-block-b">
							<label class="checkbox" >
								<input class="bigbox" id="fromsolidclip" type="checkbox" data-role="none">Convert APS ammo clips to regular/open? clips</label>
							</div>						
						</div>
						<hr>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox" >
									<input class="bigbox" id="paint" type="checkbox" data-role="none">Paint:
									<select id="painttarget" data-role="none">
										<option value="all" selected="selected"> all blocks
										</option>
										<option value="wood"> Wood 
										</option>
										<option value="metal"> Metal 
										</option>
										<option value="alloy"> Alloy 
										</option>
										<option value="glass"> Glass 
										</option>
										<option value="heavyarmour"> Heavy Armour 
										</option>
										<option value="stone"> Stone 
										</option>
										<option value="lead"> Lead 
										</option>
										<option value="kca" class="mod-ac"> KCA 
										</option>										
										<option value="paintstruct"> All of the above 
										</option>
										<option value="paintothers"> None of the above
										</option>
										<option value="blockfilter"> Use Block Filter
										</option>										
									</select>
								</label>
							</div>
							<div class="ui-block-b">
								<button id="popuppaintcolorbutton" class="ui-btn ui-btn-inline">
								</button>
								<div data-role="popup" id="popuppaintcolor" data-theme="a" class="ui-corner-all">
									<div class="ui-grid-solo">
										<div class="ui-block-a">
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button class="ui-btn ui-btn-inline ptbutton"> 
											</button>
											<button id="camobutton1" class="ui-btn ui-btn-inline camobutton sp-preview">
												<div class="camo-small-overlay1 sp-preview-inner color-overlay-1">
												</div>
												<div class="camo-small-overlay2 sp-preview-inner color-overlay-2">
												</div>
												<div class="camo-small-overlay3 sp-preview-inner color-overlay-3">
												</div>
												<div class="camo-small-overlay4 sp-preview-inner color-overlay-4">
												</div>
												<div class="camo-big-overlay sp-preview-inner">Camo
												</div>
											</button>
											<button id="camobutton2" class="ui-btn ui-btn-inline camobutton sp-preview">
												<div class="camo-small-overlay1 sp-preview-inner color-overlay-28">
												</div>
												<div class="camo-small-overlay2 sp-preview-inner color-overlay-29">
												</div>
												<div class="camo-small-overlay3 sp-preview-inner color-overlay-30">
												</div>
												<div class="camo-small-overlay4 sp-preview-inner color-overlay-31">
												</div>
												<div class="camo-big-overlay sp-preview-inner small-font">Fleet
													<br>Camo
												</div>
											</button>
											<button id="deletebutton" class="ui-btn ui-btn-inline">
												<div class="camo-big-overlay sp-preview-inner deletebutton small-font">Delete<br>Blocks
												</div>
											</button>											
										</div>
									</div>
								</div>
							</div>
						</div>
						<hr>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox">
								<input class="bigbox" id="shieldcolor" type="checkbox" data-role="none">Modify all shield color changers 
								</label>
								<div class="subtext">
									<i>Limits: 
									<br>R, G, B between 0 and 1,
									<br>Alpha between 0.10 and 10.
									<br>
									<br>Only affect shields with shield color changers. 
									<br>
									</i>
								</div>
							</div>
							<div class="ui-block-b">
								<div class="ui-field-contain">
									<label for="shieldr">R
									</label>
									<input type="range" name="shieldr" style="background-color:#FF7F7F;" id="shieldr" min="0" max="1" step="0.01" value="1">
								</div>
								<div class="ui-field-contain">
									<label for="shieldg">G
									</label>
									<input type="range" name="shieldg" style="background-color:#7FFF7F;" id="shieldg" min="0" max="1" step="0.01" value="1">
								</div>
								<div class="ui-field-contain">
									<label for="shieldb">B
									</label>
									<input type="range" name="shieldb" style="background-color:#7F7FFF;" id="shieldb" min="0" max="1" step="0.01" value="1">
								</div>
								<div class="ui-field-contain">
									<label for="shielda">A
									</label>
									<input type="range" name="shielda" id="shielda" min="0.1" max="10" step="0.01" value="1">
								</div>
							</div>
						</div>
					</div>
					<div id="vehicletoolpanel" data-role="collapsible">
						<h4>Vehicle Modification Tools
						</h4>
						<br>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label>
								<input id="randomcolor"  type="checkbox" data-mini="true">Randomly paint main vehicle (will overwrite paint settings)
								</label>
							</div>
							<div class="ui-block-b">
								<label>
								<input id="clearhull" type="checkbox" data-mini="true">Delete all blocks except Wood/Alloy/Metal/Glass/HA/Stone/Lead.
								</label>
							</div>
						</div>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label>
								<input id="becomeVehicle" type="checkbox" data-mini="true">Turn blueprint into a Vehicle (Invalid blocks will be deleted!)
								</label>
							</div>
							<div class="ui-block-b">
								<label>
								<input id="becomeStructure" type="checkbox" data-mini="true">Turn blueprint into a Structure (Invalid blocks will be deleted!)
								</label>
							</div>
						</div>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label><input id="replaceold" type="checkbox" data-mini="true">Replace old armor blocks (1m and 2m left,right,and up slopes)</label>
							</div>
							<div class="ui-block-b">
								<label>
								<input id="becomeFortress" type="checkbox" data-mini="true">Turn blueprint into a Fortress (Use with caution!)
								</label>
							</div>						
						</div>	
						
						<hr>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox">
								<input class="bigbox" id="rotateVehicle" type="checkbox" data-role="none">Rotate vehicle: 
								</label>
							</div>
							<div class="ui-block-b">
								<select id="rotatedir" data-mini="true" >
									<option value="1" selected="selected">Turn Right
									</option>
									<option value="3" >Turn Left
									</option>
									<option value="10" >Nose Up
									</option>
									<option value="4" >Nose Down
									</option>
									<option value="16" >Roll Right
									</option>
									<option value="18" >Roll Left
									</option>
								</select>
							</div>
						</div>
						<hr>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label>
								<input id="debeamify" type="checkbox" data-mini="true">DeBeamify. Turns Wood/Alloy/Metal/Glass/HA/Stone/Lead beams and diagonal slopes into 1m blocks and slopes.
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label>
								<input id="beamify2" type="checkbox" data-mini="true">Beamify. Turns Wood/Alloy/Metal/Glass/HA/Stone/Lead 1m blocks and slopes into beams and diagonal slopes.
								</label>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label>
								<input id="beamifyOptimized" type="checkbox" data-mini="true">Beamify using an optimization algorithm. Slower but will fit in more 4m beams. It can take up to a few minutes for large unbeamed vehicles.
								</label>
							</div>
						</div>
						<hr>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label>
								<input id="mirrorLateral" type="checkbox" data-mini="true">Mirror vehicle laterally (flip left and right sides)
								</label>
							</div>
						</div>
						<hr>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox">
								<input class="bigbox" id="cutinhalf" type="checkbox" data-role="none">Cut the blueprint in half! Only left side remains!
								</label>
							</div>
							<div class="ui-block-b" >
								<div class="ui-field-contain">
									<label for="centershift">Cut position
									</label>
									<input  data-mini="true" type="range" min="-100" max="100" name="centershift" id="centershift"  step="1" value="0">
								</div>
							</div>
						</div>
						<hr>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox">
								<input class="bigbox" id="jointmirror" type="checkbox" data-role="none">Attach a mirrored copy of the vehicle on the right!
								</label>
							</div>
							<div class="ui-block-b">
								<label>
								<input  id="evenclone2" type="checkbox" data-mini="true">Even Width?
								</label>
							</div>
						</div>
						<hr>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label class="checkbox">
								<input class="bigbox" id="cutandmirror" type="checkbox" data-role="none">Replace the right side with a mirrored copy of the left!
								</label>
							</div>
							<div class="ui-block-b">
								<label>
								<input id="evenclone1" type="checkbox" data-mini="true">Even Width?
								</label>
								<div class="ui-field-contain">
									<label for="cloneshift">Flip position:
									</label>
									<input data-mini="true" type="range" min="-100" max="100" name="cloneshift" id="cloneshift"  step="1" value="0">
								</div>
							</div>
						</div>
						<hr>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<label  class="checkbox">
								<input class="bigbox" id="widen" type="checkbox" data-role="none">Widen the vehicle by splitting it apart!
								</label>
							</div>
							<div class="ui-block-b">
								<div class="ui-field-contain">
									<label for="widendistance">Distance:
									</label>
									<input data-mini="true" type="range" min="-100" max="100" name="widendistance" id="widendistance"  step="1" value="1">
								</div>
								<div class="ui-field-contain">
									<label for="widenshift">Split position:
									</label>
									<input data-mini="true" type="range" min="-100" max="100" name="widenshift" id="widenshift"  step="1" value="0">
								</div>
							</div>
						</div>
						<!--<input id="removeoverlap" type="checkbox">Remove Overlapped blocks<br>-->
					</div>
					<div id="palettetoolpanel" data-role="collapsible">
						<h4>Palette Tools
						</h4>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<input type="text" name="palettename" id="palettename" placeholder="Palette Name" value="">	
							</div>
							<div class="ui-block-b">
								<input type="button" class="ui-btn ui-mini" value="Save Palette" onclick="savePalette();">
							</div>
						</div>
						<div class="ui-grid-a">
							<div class="ui-block-a">
								<select name="palettelist" id="palettelist" value="">
									<option value="" selected>Load Palette
									</option>
								</select>
							</div>
							<div class="ui-block-b">
								<input type="button" class="ui-btn ui-mini" data-theme="b" value="Delete Palette" onclick="removePalette();">
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<div class="subtext">Click on a number to edit color.
								</div>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
								<button class="ui-btn ui-btn-inline palettebutton"> 
								</button>
							</div>
						</div>
						<div class="ui-grid-solo">
							<div class="ui-block-a">
								<label>
								<input id="scpalette"  type="checkbox" data-mini="true">Overwrite Palette of sub-vehicles
								</label>
								<div class="multionly">
								<label>
								<input id="applymultipalette"  type="checkbox" data-mini="true">Replace colors of all loaded blueprints
								</label>
								You can either replace the palette for all loaded blueprints, or ignore palette color changes. 
								</div>
							</div>
						</div>
						<div class="ui-grid-a">
							<div class="ui-block-a">
							</div>
							<div class="ui-block-b">
								<input type="button" data-theme="b" value="Reset Palette" onclick="resetPalette();">	
							</div>
						</div>
					</div>
					<!--end of palettetoolpanel-->
					<div class="ui-grid-solo">
						<div class="ui-block-a">
							<input type="button" class="dl" value="Apply Modifications & Download" onclick="downloadBlueprint2();" disabled>
							<div id="filecontent" class="hidden">
								<a href="#filetext" onClick="togglefiletext();">
								<i>Blueprint not downloading?
								</i>
								</a>
								<div id="filetext" name="filetext">
									<br>
									Copy and paste the following into a new .blueprint file!
									<br>
									<textarea id="filetextbox" wrap="hard" cols="45" rows="30" readonly>
									</textarea>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!--end of left block-->
				<div class="ui-block-b">
					<div id="blueprintpanel" data-role="collapsible" >
						<h4>Blueprint(s)</h4>
						<table id="table3"  class="table3 tablesorter">
						  <thead>

						  <tr>
							  <th class="nosort" colspan="2">Filename</th>			  
							</tr>
						  </thead>
						  <tbody>

						  </tbody>
						</table>

					</div>				
					<div id="renderpanel" data-role="collapsible">
						<h4><span>3D Preview</span><span id="expand" class="ui-btn-icon-notext ui-icon-arrow-u-l"></span>
						</h4>
						
						<div id="container">
						</div>
							
						
						
					</div>
					<div id="blockcountpanel" data-role="collapsible" >
						<h4>Block Count / Filter
						</h4>
						<table id="table1"  class="table1 tablesorter">
							<thead>
								<tr>
									<td colspan="2" align="center" class="b1name">Blueprint
									</td>
								</tr>
								<tr>
									<th>Block
									</th>
									<th>Count
									</th>
								</tr>
							</thead>
							<tbody>
							</tbody>
						</table>
					</div>
					<div id="blockstatpanel" data-role="collapsible">
						<h4>Blueprint Statistics
						</h4>
						<table id="table2"  class="table2 tablesorter">
							<thead>
								<tr>
									<td colspan="2" align="center" class="b1name">Blueprint
									</td>
								</tr>
								<tr>
									<th>Statistic
									</th>
									<th>Value
									</th>
								</tr>
							</thead>
							<tbody>
							</tbody>
						</table>
						<div class="subtext">
							<i>*These numbers are based on saved values in the blueprint, and might not be accurate especially after block modification.
							</i>
						</div>
					</div>
				</div>
			</div>
			<p>
			</p>
			<p>Copyright &copy; 2016 Zyonix Gaming
			</p>
		</div>
	</div>
	
<script>
	loadLinks();
</script>
</body>
</html>