<!DOCTYPE html>
<html lang="en">
	<head>
		<title>FTD Blueprint Modification Tool</title>
		<meta charset="utf-8">
		
	<link rel='shortcut icon' href='ico/favicon.ico' type='image/x-icon'/ >
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/css/theme.blue.min.css">
<style>


hr{
	width:90%;
}

.subtext{
margin:4px;
}

.hidden{
	display:none;
}
.ui-header {
background: #D0D0FF !important;
}

.ui-collapsible-content {
	margin-left:4px !important;
	margin-right:4px !important;
    padding: 0px;
}

.ui-collapsible-heading{
	margin-left:4px;
	margin-right:4px;
}
.ui-listview{
	margin: 0px !important;
}

.tablesorter-blue{
	margin:0 0;
	text-align: center;
}
#disqus_thread{
	margin: 0 0;
	padding: 0.8em;
}
#container{
	background-color:#8CCFFF;
}

.bigbox{
	width:22px;
	height:22px;
	vertical-align:middle; 
}

.checkbox{
	margin: 0px;
	font-weight:bold !important;
	padding-top:12px;
	padding-left:8px;
	align:right;
	vertical-align:middle; 
	display:inline;
}

.ui-slider-track.ui-mini {
	margin-left:58px;
}

.box{
	
    border: 2px solid black;

}


tbody tr:nth-child(even) td:nth-child(odd){background: #E0E0F0}
tbody tr:nth-child(odd) td:nth-child(even){background: #FFFFFF}
tbody tr:nth-child(even) td:nth-child(even){background: #F0F0FF}
tbody tr:nth-child(odd) td:nth-child(odd){background: #F0F0F0}


</style>
	<script src="js/links.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/js/jquery.tablesorter.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.26.0/js/widgets/widget-filter.min.js"></script>	
	<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
	<script src="https://cdn.rawgit.com/ZyonixGaming/ftd-blueprint-tools/gh-pages/js/OrbitControls.js"></script>	
	<script src="https://cdn.rawgit.com/ZyonixGaming/ftd-blueprint-tools/gh-pages/js/ConvexGeometry.js"></script>	
	<script src="js/itemtable-1.9572.js"></script>
	<script src="js/preview3d.js"></script>
	
<script>


var QuatTable = {0:"0,0,0,1",1:"0,0.707106781186547,0,0.707106781186547",2:"0,1,0,0",3:"0,0.707106781186547,0,-0.707106781186547",4:"0.707106781186547,0,0,0.707106781186547",5:"0.5,0.5,-0.5,0.5",6:"0,-0.707106781186547,0.707106781186547,0",7:"-0.5,0.5,-0.5,-0.5",8:"0,-0.707106781186547,-0.707106781186547,0",9:"0.5,0.5,0.5,-0.5",10:"-0.707106781186547,0,0,0.707106781186547",11:"-0.5,0.5,0.5,0.5",12:"0,0,-1,0",13:"-0.707106781186547,0,-0.707106781186547,0",14:"1,0,0,0",15:"0.707106781186547,0,-0.707106781186547,0",16:"0,0,-0.707106781186547,0.707106781186547",17:"0.707106781186547,0.707106781186547,0,0",18:"0,0,0.707106781186547,0.707106781186547",19:"-0.707106781186547,0.707106781186547,0,0",20:"0.5,0.5,0.5,0.5",21:"0.5,-0.5,-0.5,0.5",22:"-0.5,0.5,-0.5,0.5",23:"-0.5,-0.5,0.5,0.5",}
var RotTable = {"0,0,0,1":0,"0,1,0,1":1,"0,1,0,0":2,"0,1,0,-1":3,"1,0,0,1":4,"1,1,-1,1":5,"0,1,-1,0":6,"1,-1,1,1":7,"0,1,1,0":8,"1,1,1,-1":9,"1,0,0,-1":10,"1,-1,-1,-1":11,"0,0,1,0":12,"1,0,1,0":13,"1,0,0,0":14,"1,0,-1,0":15,"0,0,1,-1":16,"1,1,0,0":17,"0,0,1,1":18,"1,-1,0,0":19,"1,1,1,1":20,"1,-1,-1,1":21,"1,-1,1,-1":22,"1,1,-1,-1":23}

var BeamAxisRot = [1,8,0];
var BeamAxisPriority = [3,2,1];


//maps block ID of block to beam
var blockToBeam = {}

//maps block ID of beam to block
var beamToBlock = {}

var maxc=[0,0,0,0];
var minc=[0,0,0,0];

var blockRenderData = {}
var blockRenderIndex = 0;

var slopeBlockToBeam = {}
var slopeBeamToBlock = {}
var slopeBeamToBlockM = {}

//maintains a list of blockID:newBlockID to facilitate switching blocks via convertblocks() function
var conversionIndex = {}

var replaceOldIndex = {}

//maintains a list of blockID to keep via clearhull() function
var keepIndex = {}

//maintains a list of blockID to determine color changes via colorblocks() function
var blockColorIndex = {}

//blockID:blockname
var nameID = {}

//blockID:blockcount
var countID = {}

var colorID = {}

//blockname:blockcount
var blockCountData = {}

//store stats
var totalstats = {}

var selectedFile
var selectedFileName
var ItemDic
var CurrentBlueprint

var selectedcolor

var allowedcolor = -1;

var blocksBeamed = 0;

var blocksDebeamed = 0;



var colorTable=[];
var colorTableInverse=[];

$(document).ready(function(){

	$( ".palette" )
	  .change(function () {
		
		var value = $( this ).val();
		value=parseInt(value);
		if(colorTable[value]){
			$(this).parent().css("background-color",colorTable[value]);
		}

		//$(this).hide(1500).show(1500);
	  });
	//$( ".palette" ).change();
	
	
	$( ".lb" ).click(function() {
	  $($(this).attr("btarget")).click();
	  
  
	});
	

	

	
	
	$(function() {
  // simple reflow widget (table with 1 header row)
  
  $("#table1").tablesorter({
    theme: 'blue',
    widgets: ['reflow','filter'],
    widgetOptions : {
      // class name added to make it responsive (class name within media query)
      reflow_className    : 'ui-table-reflow',
      // header attribute containing modified header name
      reflow_headerAttrib : 'data-name',
      // data attribute added to each tbody cell
      // it contains the header cell text, visible upon reflow
      reflow_dataAttrib   : 'data-title',
	  filter_defaultFilter: { 0 : '~{query}' },
	  // include column filters
	  filter_columnFilters: true,
	  filter_placeholder: { search : 'Search...' },		  
	  
    },	
	selectorHeaders: "thead th"
  });
  
});

	$(function() {
  // simple reflow widget (table with 1 header row)
  $("#table2").tablesorter({
    theme: 'blue',
    widgets: ['reflow'],
    widgetOptions : {
      // class name added to make it responsive (class name within media query)
      reflow_className    : 'ui-table-reflow',
      // header attribute containing modified header name
      reflow_headerAttrib : 'data-name',
      // data attribute added to each tbody cell
      // it contains the header cell text, visible upon reflow
      reflow_dataAttrib   : 'data-title',
    },	
	selectorHeaders: "thead th"
  });
  
});



//alert("Warning:\r\nThe interface is currently quite terrible and is being worked on.\r\nFor a simpler and easier to use interface, go to the 'Modification Tool with basic interface' page from the links provided (top left corner)");

});


//rotation*vector*rotation_conjugate
//alert(JSON.stringify(RotTable));
//alert(atos(posTransform([1,2,3],[0.5,0.5,-0.5,0.5])));
//inverse x and inverse w to flip along yz plane

//run once to populate RotTable from QuatTable - not needed with static table
function initRotTable(){
	for(rot in QuatTable){
		var quat=getquatformatted(getQuat(rot));
		var quatstr=atos(quat);
		RotTable[quatstr]=rot;
	}
}//not needed now with static table



//pos as [x,y,z] quat as[x,y,z,w]
// transforms co-ordinate pos by the quaternion quat
function posTransform(pos,quat){
	var p = [pos[0],pos[1],pos[2],0];
	var transpos = quatmul(quat,quatmul(p,quatconj(quat)));
	return [Math.round(transpos[0]),Math.round(transpos[1]),Math.round(transpos[2])]
}

function posTransformNR(pos,quat){
	var p = [pos[0],pos[1],pos[2],0];
	var transpos = quatmul(quat,quatmul(p,quatconj(quat)));
	return [(transpos[0]),(transpos[1]),(transpos[2])]
}

//combining 2 quat transforms e.g. q1 then q2 = applying q2*q1 or quatmul(q2,q1);


function atos(a){
	var s="";
	if(a){
		s=""+a[0];
	}
	for (var i=1;i<a.length;i++){
		s=s + "," + a[i];
	}
	return s;
}

function stoa(s){
	var temp=s.split(",");
	return [parseFloat(temp[0]),parseFloat(temp[1]),parseFloat(temp[2]),parseFloat(temp[3])];
}

function stoa3(s){
	var temp=s.split(",");
	return [parseFloat(temp[0]),parseFloat(temp[1]),parseFloat(temp[2])];
}


function stoar(s){
	var temp=s.split(",");
	return [Math.round(parseFloat(temp[0])),Math.round(parseFloat(temp[1])),Math.round(parseFloat(temp[2]))];
}

function getQuat(rotation){
	return JSON.parse("[" + QuatTable[rotation] + "]");
}

function getRot(quat){
	var quatstr=atos(getquatformatted(quat));
	return RotTable[quatstr];
}

//quat as array
function getquatformatted(quat){
	var q=[quat[0],quat[1],quat[2],quat[3]];
	var r = Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]);
	q[0]=Math.round(q[0]*r);
	q[1]=Math.round(q[1]*r);
	q[2]=Math.round(q[2]*r);
	q[3]=Math.round(q[3]*r);
	for(var i=0;i<4;i++){
		if(q[i]>0){
			break;
		}else if(q[i]<0){
			q=quatneg(q);
			break;
		}
	}
	return q;
}

//quat as array
function getquatnormalized(quat){
	var q=[quat[0],quat[1],quat[2],quat[3]];
	var r = Math.sqrt(Math.abs(q[0])+Math.abs(q[1])+Math.abs(q[2])+Math.abs(q[3]));
	q[0]=q[0]/r;
	q[1]=q[1]/r;
	q[2]=q[2]/r;
	q[3]=q[3]/r;
	return q;
}

//quat in x, y, z, w
function quatneg(q){
 return[-q[0],-q[1],-q[2],-q[3]];
}
//quat in x, y, z, w
function quatconj(q){
 return[-q[0],-q[1],-q[2],q[3]];
}

//quat in x, y, z, w
function quatmul(q,r){
 return [q[3] * r[0] + q[0] * r[3] + q[1] * r[2] - q[2] * r[1],
     q[3] * r[1] - q[0] * r[2] + q[1] * r[3] + q[2] * r[0],
     q[3] * r[2] + q[0] * r[1] - q[1] * r[0] + q[2] * r[3],
     q[3] * r[3] - q[0] * r[0] - q[1] * r[1] - q[2] * r[2]];
}

function loadLinks(){
	$('#linklist').empty();
	for(var i=0;i<LinkList.length;i++){
		$('#linklist').append(LinkList[i]);
	}
	
}

function loadError(message){
	if(message){
		alert(message);
	}else{
		alert("failure");
	}	
}

function openFile() {
 var selectedFile = document.getElementById('blueprintfile').files[0];
 if (selectedFile){
  var reader = new FileReader();
  reader.onload = function(evt) {
   try{    
     if(evt){
		 CurrentBlueprint = JSON.parse(evt.target.result);    
		 selectedFileName = selectedFile.name;
		 autorender=false;
		 if (!processData()){
		  throw "unable to process blueprint"
		 }
     
    }else{
     throw "unable to load blueprint"
    }
   }
   catch(err){
	throw err;
    loadError(err);
	
    } 
  };
  reader.readAsText(selectedFile);
 }else{
  //no file selected;
 }
 document.getElementById('blueprintfile').value="";
};

function processData(){



    nameID = {}
    countID = {}
 blockCountData = {}
 ItemDic =  CurrentBlueprint.ItemDictionary;
 
 		$("#table1 tbody").empty(); 
		$("#table2 tbody").empty(); 
		$("#renderpanel").collapsible("collapse");
		document.getElementById("container").innerHTML="";
		document.getElementById("filecontent").style.display="none";
		alreadyrender=false;
 
 var a1;
 var a2;
 var b1;
 var b2;
 var c1;
 var c2;
 var d1;
 var d2;
 var e1;
 var e2;
 var f1;
 var f2;
 var g1;
 var g2;
 
 //for sloped blocks
 var aa1=-1;
 var aa2=-1;
 var aa3=-1;
 var ab1=-1;
 var ab2=-1;
 var ab3=-1;
 var ac1=-1;
 var ac2=-1;
 var ac3=-1;
 var ad1=-1;
 var ad2=-1;
 var ad3=-1;
 var ae1=-1;
 var ae2=-1;
 var ae3=-1;
 
 
 blockToBeam={};
 beamToBlock={};
 
 slopeBlockToBeam={};
 slopeBeamToBlock={};
 slopeBeamToBlockM={};
  
 
 for(var key in ItemDic) {
  var keyint = parseInt(key);
  val = ItemDic[keyint];
  if(ItemTable[val]){
   nameID[keyint]=(ItemTable[val]).Name;
   ItemTable[val].BlockId=keyint;
  }else{
   nameID[keyint]="unnamed";
  }
  countID[keyint]=0;
  if (val=="9a0ae372-beb4-4009-b14e-36ed0715af73"){
   a1=keyint;//woodblock
  }else if(val=="05475442-0e52-4e0b-9fbb-2715f0e54f97"){
   a2=keyint;//woodbeam
  }else if(val=="ab699540-efc8-4592-bc97-204f6a874b3a"){
   b1=keyint;//metalblock
  }else if(val=="a7f5d8de-4882-4111-9d01-436493e5b2d8"){
   b2=keyint;//metalbeam
  }else if(val=="3cc75979-18ac-46c4-9a5b-25b327d99410"){
   c1=keyint;//alloyblock
  }else if(val=="9411e401-27da-4546-b805-3334f200f055"){
   c2=keyint;//alloybeam
  }else if(val=="2d519ca8-1f12-4a8e-9340-aa6648b5e799"){
   d1=keyint;//glassblock
  }else if(val=="395179c1-37a0-4250-851b-5bc19fd601b6"){
   d2=keyint;//glassbeam
  }else if(val=="e71e6f97-fbe8-4bf5-9645-d15179ba0c17"){
   e1=keyint;//leadblock
  }else if(val=="f5d2db25-114e-473a-8313-96831ccd011e"){
   e2=keyint;//leadbeam
  }else if(val=="710ee212-563b-42f8-acd1-57515479524d"){
   f1=keyint;//stoneblock
  }else if(val=="c7a19161-b361-4074-8c51-2398a0a70d1b"){
   f2=keyint;//stonebeam
  }else if(val=="bdafa446-f615-49cb-94f3-d7652dde6cec"){
   aa1=keyint;//wood
  }else if(val=="2ee817c1-f2a3-407a-847d-b97ffb844e45"){
   aa2=keyint;//wood
  }else if(val=="d077c2a4-4578-4965-9318-c14bb7ac1bd6"){
   aa3=keyint;//wood
  }else if(val== "5548037e-8428-43f8-bcb6-d730dbcd0a79"){
   ab1=keyint;//metal
  }else if(val== "0d554a9d-7d06-48b3-8aea-ffaeaa30380a"){
   ab2=keyint;//metal
  }else if(val== "e5d065f6-907b-450d-b998-213cdc54eec1"){
   ab3=keyint;//metal
  }else if(val=="911fe222-f9b2-4892-9cd6-8b154d55b2aa"){
   ac1=keyint;//alloy
  }else if(val=="9af822b3-80d9-46bd-9ce0-e6e5c2e61da4"){
   ac2=keyint;//alloy
  }else if(val=="b5d46bb7-d49e-42f6-817b-323fbf6d62b0"){
   ac3=keyint;//alloy
  }else if(val=="174b5b41-b70e-485d-b00a-a61cc9826b2c"){
   ad1=keyint;//glass
  }else if(val=="35abb89b-33b8-4cb4-b3d0-ee132247de8d"){
   ad2=keyint;//glass
  }else if(val=="0c64d302-c6df-42eb-a0ff-7c90f867ba4b"){
   ad3=keyint;//glass
  }else if(val=="0c03433e-8947-4e7d-9dec-793526fe06d1"){
   g1=keyint;//heavyarmour block
  }else if(val=="867cea4e-6ea4-4fe2-a4a1-b6230308f8f1"){
   g2=keyint;//heavyarmour beam
  }else if(val=="78b81c0a-44df-4c24-b2a5-5d273737da60"){
   ae1=keyint;//heavyarmour
  }else if(val=="6e5c9f1d-160b-49b1-9b74-606d2f695c7e"){
   ae2=keyint;//heavyarmour
  }else if(val=="c61c1c19-cc53-49a2-b207-9de6b9ce328a"){
   ae3=keyint;//heavyarmour
  }



  colorID[keyint]=[80,80,80,1];
 
  for(var mat in shapedBlocks){
   var tempindex = shapedBlocks[mat].blockGuid; 
   var matID = tempindex[val];
    if(matID!==undefined){
	 colorID[keyint]= shapedBlocks[mat].color;
     shapedBlocks[mat].blockIds[matID] = keyint;
    }
  }
 }
 
 blockToBeam[a1]=a2;
 blockToBeam[b1]=b2;
 blockToBeam[c1]=c2;
 blockToBeam[d1]=d2;
 beamToBlock[a2]=a1;
 beamToBlock[b2]=b1;
 beamToBlock[c2]=c1;
 beamToBlock[d2]=d1; 
 if(e1&&e2){
  blockToBeam[e1]=e2;
  beamToBlock[e2]=e1; 

 }
 if(f1&&f2){
  blockToBeam[f1]=f2;
  beamToBlock[f2]=f1; 
 }
 if(g1&&g2){
  blockToBeam[g1]=g2;
  beamToBlock[g2]=g1; 
 }
 
 slopeBlockToBeam[aa1]=aa2;
 slopeBlockToBeam[ab1]=ab2;
 slopeBlockToBeam[ac1]=ac2;
 slopeBlockToBeam[ad1]=ad2;
 slopeBlockToBeam[ae1]=ae2;
 slopeBeamToBlock[aa2]=aa1;
 slopeBeamToBlockM[aa3]=aa1;
 slopeBeamToBlock[ab2]=ab1;
 slopeBeamToBlockM[ab3]=ab1;
 slopeBeamToBlock[ac2]=ac1;
 slopeBeamToBlockM[ac3]=ac1;
 slopeBeamToBlock[ad2]=ad1;
 slopeBeamToBlockM[ad3]=ad1;
 slopeBeamToBlock[ae2]=ae1;
 slopeBeamToBlockM[ae3]=ae1;
 
 totalstats = {
  "Block Count":0,
  "Natural Cost":0,
  "Metal Cost":0,
  "Oil Cost":0,
  "Scrap Cost":0,
  "Crystal Cost":0,
  "RP Cost":0,
  "Volume":0,
  "Max Power*":0,
  "Max Battery Capacity*":0,
  "Max Ammo Capacity*":0,
  "Max Fuel Capacity*":0,
  "Max Natural Storage*":0,
  "Max Metal Storage*":0,
  "Max Oil Storage*":0,
  "Max Scrap Storage*":0,
  "Max Crystal Storage*":0,
  "Blueprint Modified*":false,
 } 
 countblocks(CurrentBlueprint.Blueprint);
 totalstats["Volume"]=roundToTwo(totalstats["Volume"]);
 getpalette(CurrentBlueprint.Blueprint);

 var outputstring = "";
 var totalcount = 0;
 for(var blockID in countID) {
  if(countID[blockID] >0) {
   blockCountData[nameID[blockID]] =  countID[blockID];
   totalcount+=countID[blockID];
  }
 }
 totalstats["Block Count"] = totalcount;
 
 keysSorted = Object.keys(blockCountData).sort(function(b,a){return blockCountData[a]-blockCountData[b]})
 for (var bName in keysSorted){ 
  outputstring +=  "<tr><td>" + keysSorted[bName]  + "</td><td><b>" + blockCountData[keysSorted[bName]] + "</b></td></tr>";
  
 }
$("#table1 tbody").append(outputstring); 

$("#table1").trigger("update");
$("#blockcountpanel").collapsible("expand");

 var statisticsString = "";
 for (var stats in totalstats){ 
  statisticsString +=  "<tr><td>" + stats  + "</td><td><b>" + totalstats[stats] + "</b></td></tr>";  
 }

$("#table2 tbody").append(statisticsString); 
$("#table2").trigger("update");
$("#blockstatpanel").collapsible("expand");

$(".b1name").html(selectedFileName);


$( "#renderpanel" ).collapsible({
  expand: function( event, ui ) {
 	if(!alreadyrender){
		//$("#container").width($("#renderpanel").innerWidth());
		alreadyrender=true;
		autorender=true;
		init();
		animate();
	}
  }
  
     
});

 if(autorender){
	$("#renderpanel").collapsible("expand");
 }
 
 $(".dl").prop('disabled',false);		
 $(".dl").parent().removeClass('ui-state-disabled');	
 return true;
}


//convert blocks between materials. also changes shield color.
function convertblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  convertblocks(SClist[scID]);
 }
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
	  blocklist[blockIndex] = getconverted(blocklist[blockIndex]);
	  if(document.getElementById("shieldcolor").checked){
	   if (nameID[blocklist[blockIndex]]=="Shield Color Changer"){
		blocks.BP1[blockIndex] = "" + document.getElementById("shieldr").value + "," +  document.getElementById("shieldg").value + "," + document.getElementById("shieldb").value + "," + document.getElementById("shielda").value;
	   }
	  }
	}
 }
 cleanBlueprint(blocks);
}


function mirrorVehicle(blocks){
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		var curSC=SClist[scID];
		curSC.LocalPosition=flipX(curSC.LocalPosition);
		curSC.LocalRotation=quatMirror(curSC.LocalRotation);
		mirrorVehicle(curSC);
	}
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

		blocklist[blockIndex]=mirrordata.blockID;
		positionList[blockIndex]=mirrordata.position;
		rotationList[blockIndex]=mirrordata.rotation;
	}
}

function rotateBlueprint(blocks,dir){
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		var curSC=SClist[scID];
		curSC.LocalPosition=positionRotate(curSC.LocalPosition,dir);
		curSC.LocalRotation=quatRotate(curSC.LocalRotation,dir);  
	}
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		positionList[blockIndex]=positionRotate(positionList[blockIndex],dir);
		rotationList[blockIndex]=blockRotate(rotationList[blockIndex],dir);
	}
}

//builds index of file to keep via the clearhull() function
function buildkeepIndex(){
 keepIndex = {};
 for(var mat in shapedBlocks){
  var blockcount =  shapedBlocks[mat].blockIds.length;
  for(var i=0;i<blockcount;i++){
   keepIndex[shapedBlocks[mat].blockIds[i]] = true;
  }
 }
}

//delete everything except structural blocks on the main vehicle
function clearhull(blocks){
 blocks.SCs = [];
 blocks.BlockStringData = [];
 blocks.BlockStringDataIds = [];
 blocks.BEI = [];
 var blocklist=blocks.BlockIds;
 var blrlist=blocks.BLR;
 var blplist=blocks.BLP;
 var bp1list=blocks.BP1;
 var bp2list=blocks.BP2;
 var bcilist=blocks.BCI; 
 var blocknew=[];
 var blrnew=[];
 var blpnew=[];
 var bp1new=[];
 var bp2new=[];
 var bcinew=[];
 var currentIndex = 0;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  if(keepIndex[blocklist[blockIndex]]){
   blocknew[currentIndex]=blocklist[blockIndex];
   blrnew[currentIndex]=blrlist[blockIndex];
   blpnew[currentIndex]=blplist[blockIndex];
   bp1new[currentIndex]=bp1list[blockIndex];
   bp2new[currentIndex]=bp2list[blockIndex];   
   bcinew[currentIndex]=bcilist[blockIndex];   
   currentIndex +=1;
  }
 } 
 blocks.BlockIds=blocknew;
 blocks.BLR=blrnew;
 blocks.BLP=blpnew;
 blocks.BP1=bp1new;
 blocks.BP2=bp2new;
 blocks.BCI=bcinew;
}

//randomly color blocks
function randomcolorblocks(blocks){
 var SClist=blocks.SCs;
 //blocks.designChanged = true;
 if(blocks.COL){
   for(var i=0;i<28;i++){
    var colorseed = Math.floor((Math.random() * 15));
    var othercolor = 0.0;
    if (Math.random()<0.5){
     othercolor = 1.0;
    }
    if (colorseed>8){
     blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + Math.random()  +",0.99";
    }
    else if (colorseed>6){
     blocks.COL[i]= "" +othercolor + "," + Math.random()  + "," + Math.random()  +",0.99";
    }
    else if (colorseed>4){
     blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + Math.random()  +",0.99";
    }
    else if (colorseed>2){
     blocks.COL[i]= "" + Math.random() + "," + Math.random()  + "," + othercolor  +",0.99";
    }
    else if (colorseed>1){
     blocks.COL[i]= "" + Math.random() + "," + othercolor  + "," + othercolor  +",0.99";
    }   
    else if (colorseed>0){
     blocks.COL[i]= "" + othercolor + "," + Math.random()  + "," + othercolor  +",0.99";
    }else{
     blocks.COL[i]= "" + othercolor + "," + othercolor  + "," + Math.random()  +",0.99";
    }
    
   } 
 }
 for(var scID = 0; scID < SClist.length; scID++){

   randomcolorblocks(SClist[scID]);
  
 }
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < colorlist.length; blockIndex++){
   colorlist[blockIndex] = Math.floor((Math.random() * 28));
 }
}

//paint vehicles black and certain blocks in brighter colors
function highlightBlocks(blocks){
/*
  
  "AI Mainframe"
  "(CARD) Aerial AI"
  "(CARD) Naval AI"
  "(CARD) sailing"
  "PID"
  "Wireless Reciever"
  "Wireless Transmitter"
  "Local Weapon Controller"
  
  "PID (General Purpose)"
  "Automated Control Block"
  
  "(CARD) Propulsion Balancing"
  
  "LUA Box"  
  
*/
 var SClist=blocks.SCs;
 //blocks.designChanged = true;
 if(blocks.COL){
   blocks.COL[0]="0,0,0,0";
   blocks.COL[1]="0,0,0,0.66"; //black
   blocks.COL[2]="1,0,0,0.99"; //red
   blocks.COL[3]="1,0.5,0,0.99"; //orange
   blocks.COL[4]="1,1,0,0.99"; //yellow
   blocks.COL[5]="0,1,0,0.99"; //green
   blocks.COL[6]="0,0,1,0.99"; //blue
   blocks.COL[7]="0.7,0,0.7,0.99"; //purple
   blocks.COL[8]="1,0.5,1,0.99"; //pink	
 }
 for(var scID = 0; scID < SClist.length; scID++){

   highlightBlocks(SClist[scID]);
  
 }
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var blockname = nameID[blocklist[blockIndex]];
  
  if ((blockname=="AI Mainframe")||(blockname=="(CARD) Aerial AI")||(blockname=="(CARD) Naval AI")||(blockname=="(CARD) sailing")||(blockname=="PID")||(blockname=="Wireless Reciever")||(blockname=="Wireless Transmitter")||(blockname=="Local Weapon Controller")){
   colorlist[blockIndex] = 2;
  }
  else if ((blockname=="PID (General Purpose)")||(blockname=="Automated Control Block")){
   colorlist[blockIndex] = 3;
  }
  else if ((blockname=="(CARD) Propulsion Balancing")){
   colorlist[blockIndex] = 6;
  }  
  else if ((blockname=="LUA Box")){
   colorlist[blockIndex] = 8;
  }  
  else{
   colorlist[blockIndex] = 1;
  }  
 }
}

//paint blocks
function colorblocks(blocks){
 var SClist=blocks.SCs;
 //blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  if(!(SClist[scID].COL)){
   colorblocks(SClist[scID]);
  }
 }
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
	if((allowedcolor<0)||(allowedcolor==colorlist[blockIndex])){
	  var newcolor = getNewColor(blocklist[blockIndex]);
	  if (newcolor>=0){
	   colorlist[blockIndex] = newcolor;
	  }
	}
 }
}


//turns beam into blocks
function debeamifyblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  debeamifyblocks(SClist[scID]);
 } 
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR; 
 newBlockIndex=blocklist.length;
 blockcount=blocklist.length;
 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  if(ItemDic[currentBlock]&&beamToBlock[currentBlock]){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;
    var targetBlock =beamToBlock[currentBlock];
    var directionArray = getDirectionArray(rotationList[blockIndex]);
    if(directionArray){
     blocksDebeamed+=1;
     blocklist[blockIndex]=targetBlock;
     for(var i=1;i<4;i++){
      blocklist[newBlockIndex]=targetBlock;
      rotationList[newBlockIndex]=0;
      colorlist[newBlockIndex]=colorlist[blockIndex];
      blocks.BP1[newBlockIndex]="0,0,0,0";
      blocks.BP2[newBlockIndex]="0,0,0,0";
      positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
      newBlockIndex+=1;
     }
    }

  }
 }
 
}


function debeamifyslopeblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  debeamifyslopeblocks(SClist[scID]);
 } 
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR; 
 newBlockIndex=blocklist.length;
 blockcount=blocklist.length;
 for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  var currentRotation = rotationList[blockIndex];
  if(ItemDic[currentBlock]&&(slopeBeamToBlock[currentBlock]||slopeBeamToBlockM[currentBlock])){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;
    var targetBlock = 0;
    var targetRotation = 0;
    if(slopeBeamToBlock[currentBlock]){
     targetBlock = slopeBeamToBlock[currentBlock];
     targetRotation = slopeBeamToBlockOrientation(currentRotation,false);
    }else if (slopeBeamToBlockM[currentBlock]){
     targetBlock = slopeBeamToBlockM[currentBlock];
     targetRotation = slopeBeamToBlockOrientation(currentRotation,true);
    }

    var directionArray = getDirectionArray(rotationList[blockIndex]);
    if(directionArray){
     blocksDebeamed+=1;
     blocklist[blockIndex]=targetBlock;
     rotationList[blockIndex]=targetRotation;
     for(var i=1;i<4;i++){
      blocklist[newBlockIndex]=targetBlock;
      rotationList[newBlockIndex]=targetRotation;
      colorlist[newBlockIndex]=colorlist[blockIndex];
      blocks.BP1[newBlockIndex]="0,0,0,0";
      blocks.BP2[newBlockIndex]="0,0,0,0";
      positionList[newBlockIndex]= "" + (curx+(i*directionArray[0])) + "," + (cury+(i*directionArray[1])) +"," + (curz+(i*directionArray[2]));
      newBlockIndex+=1;
     }
    }

  }
 }
 
}


//get array of to represent block rotation
function getDirectionArray(rotation){
 if(rotation==0||rotation==16||rotation==12||rotation==18){
  return [0,0,1];
 }else if(rotation==2||rotation==17||rotation==14||rotation==19){
  return [0,0,-1];
 }else if(rotation==8||rotation==9||rotation==10||rotation==11){
  return [0,1,0];
 }else if(rotation==4||rotation==5||rotation==6||rotation==7){
  return [0,-1,0];
 }else if(rotation==1||rotation==20||rotation==13||rotation==22){
  return [1,0,0];
 }else if(rotation==3||rotation==21||rotation==15||rotation==23){
  return [-1,0,0];
 }else{
  return false;
 }
}


function beamifyaxisSloped(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 if(ItemDic[currentBlock]){
  if(slopeBlockToBeam[currentBlock]){
   
   var currentColor = colorlist[tempBlockIndex];
   var currentPosition = positionList[tempBlockIndex];
   var currentRotation = rotationList[tempBlockIndex];
   
   var posArray = JSON.parse("["+currentPosition+"]");
   posArray[0] = Math.round(posArray[0]);
   posArray[1] = Math.round(posArray[1]);
   posArray[2] = Math.round(posArray[2]);
   var result = true;
   
   
   result = true;
   for(i=1;i<4;i++){
    var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
    if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
     
    }else{
     result = false;
    }
   }
   if(result){
    blocksBeamed+=1;
    for(i=1;i<4;i++){
     var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
     blocklist[blockPositionData[tempPosition]]=-1;
    }
    blocklist[tempBlockIndex]=slopeBlockToBeam[currentBlock];
    rotationList[tempBlockIndex]=rotation;     
   }
   
   
  }
 }

}
//turn this blocks and adjacent 3 1x1x1 blocks in a particular direction into 1x1x4 beams
function beamifyaxis(x,y,z,blockIndex,blocklist,colorlist,positionList,rotationList,blockPositionData,rotation){
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 if(ItemDic[currentBlock]){
  if(blockToBeam[currentBlock]){
   
   var currentColor = colorlist[tempBlockIndex];
   var currentPosition = positionList[tempBlockIndex];
   
   var posArray = JSON.parse("["+currentPosition+"]");
   posArray[0] = Math.round(posArray[0]);
   posArray[1] = Math.round(posArray[1]);
   posArray[2] = Math.round(posArray[2]);
   var result = true;
   
   
   result = true;
   for(i=1;i<4;i++){
    var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
    if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
     
    }else{
     result = false;
    }
   }
   if(result){
    blocksBeamed+=1;
    for(i=1;i<4;i++){
     var tempPosition = "" + (posArray[0]+x*i)+","+(posArray[1]+y*i)+","+(posArray[2]+z*i);
     blocklist[blockPositionData[tempPosition]]=-1;
    }
    blocklist[tempBlockIndex]=blockToBeam[currentBlock];
    rotationList[tempBlockIndex]=rotation;     
   }
   
   
  }
 }

}

function getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData){
 
 var queue1=[blockIndex];
 var queue1index=1; 
 var queue1process=0;
 while(queue1process<queue1index){
  var tempBlockIndex = queue1[queue1process];
  var currentBlock = blocklist[tempBlockIndex];
  var currentColor = colorlist[tempBlockIndex];
  var currentPosition = positionList[tempBlockIndex];
  var posArray = JSON.parse("["+currentPosition+"]");
  posArray[0] = Math.round(posArray[0]);
  posArray[1] = Math.round(posArray[1]);
  posArray[2] = Math.round(posArray[2]);
  var tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]);
  if(blockPositionData[tempPosition]){
   var tempblock = {}
   tempblock.blockIndex=tempBlockIndex;
   tempblock.score=0;
   localPositionData[tempPosition]=tempblock;
   delete blockPositionData[tempPosition]; 
   
   tempPosition = "" + (posArray[0]+1)+","+(posArray[1])+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }
   
   tempPosition = "" + (posArray[0]-1)+","+(posArray[1])+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1]+1)+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1]-1)+","+(posArray[2]);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]+1);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }

   tempPosition = "" + (posArray[0])+","+(posArray[1])+","+(posArray[2]-1);
   if((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(localPositionData[tempPosition]==undefined)){
    queue1[queue1index]=blockPositionData[tempPosition];
    queue1index++;
   }   
   
   
  }
 
 
  queue1process++;
 }

}

//get an array containing 1x1x1 blocks in a direction.
function getLookbackArray(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData){
 var tempindex=0;
 var tempList=[];
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 var currentColor = colorlist[tempBlockIndex];
 var currentPosition = positionList[tempBlockIndex];
 var posArray = JSON.parse("["+currentPosition+"]");
 posArray[0] = Math.round(posArray[0]);
 posArray[1] = Math.round(posArray[1]);
 posArray[2] = Math.round(posArray[2]); 
 
 
 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
 
 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)){
  tempList[tempindex]=blockPositionData[tempPosition];
  
  tempindex+=1;
  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
  
 }
 return tempList;
}

function getLookbackArraySloped(x,y,z,blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList){
 var tempindex=0;
 var tempList=[];
 var tempBlockIndex = blockIndex;
 var currentBlock = blocklist[tempBlockIndex];
 var currentColor = colorlist[tempBlockIndex];
 var currentPosition = positionList[tempBlockIndex];
 var currentRotation = rotationList[tempBlockIndex];
 var posArray = JSON.parse("["+currentPosition+"]");
 posArray[0] = Math.round(posArray[0]);
 posArray[1] = Math.round(posArray[1]);
 posArray[2] = Math.round(posArray[2]); 
 
 
 var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
 
 while((blockPositionData[tempPosition]!==undefined)&&(blocklist[blockPositionData[tempPosition]]==currentBlock)&&(colorlist[blockPositionData[tempPosition]]==currentColor)&&(sameSlopeBlockOrientation(rotationList[blockPositionData[tempPosition]],currentRotation))){
  tempList[tempindex]=blockPositionData[tempPosition];
  
  tempindex+=1;
  var tempPosition = "" + (posArray[0]+x*tempindex)+","+(posArray[1]+y*tempindex)+","+(posArray[2]+z*tempindex);
  
 }
 return tempList;
}




function becomeStructure(blocks,subcon){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  if(!(SClist[scID].COL)){
   //no palette=turret or spinblock
   becomeStructure(SClist[scID],true);
  } 
  
 }
 var start=0;
 if(subcon){
  start=1;
 }
 var deletecount=0;
 var blocklist=blocks.BlockIds;
 for(var blockIndex = start; blockIndex < blocklist.length; blockIndex++){
  var currentBlockInfo = getBlock(blocklist[blockIndex]);
  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnStructure)){
   deletecount+=1;
   blocklist[blockIndex]=-1;
  }

 }
 
cleanBlueprint(blocks);
}


function becomeVehicle(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  becomeVehicle(SClist[scID]);
 }
 var deletecount=0;
 var blocklist=blocks.BlockIds;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlockInfo = getBlock(blocklist[blockIndex]);
  if((currentBlockInfo)&&(!currentBlockInfo.PlaceableOnVehicle)){
   deletecount+=1;
   blocklist[blockIndex]=-1;
  }

 }
 cleanBlueprint(blocks);
 
}


function cutInHalfSC(blocks,midx){
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var scRotation = "["+blocks.LocalRotation+"]";
	var scPosition = "["+blocks.LocalPosition+"]";
	var scp = JSON.parse(scPosition);
	var q = JSON.parse(scRotation);
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var tpaq = [tpa[0],tpa[1],tpa[2],0];
		var transpos = quatmul(q,quatmul(tpaq,quatconj(q)));
		var finalx = scp[0]+transpos[0];
		finalx=Math.round(finalx);
		if(finalx>midx){
			blocklist[blockIndex]=-1;
		}
	}
	cleanBlueprint(blocks);
}

function cutInHalf(blocks,xshift){
	blocks.designChanged = true;
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var midx=0;
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
	}
	midx=((minx+maxx)/2)+xshift;

	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		if (curx>midx){
			blocklist[blockIndex]=-1;
		}
	}

	for(var scID = 0; scID < SClist.length; scID++){
		if(!(SClist[scID].COL)){
			var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
			var tpa = JSON.parse(currentPosition);
			var curx = Math.round(tpa[0]);
			if(curx>midx){
				SClist[scID].ItemNumber=-1;
			}else{
				cutInHalfSC(SClist[scID],midx);
			}
		}else{
			SClist[scID].ItemNumber=-1;
		}
	}
	cleanBlueprint(blocks);
}



//need to modify when we can check for parts sticking out
function widenVehicle(blocks,xdist,xshift){
	blocks.designChanged = true;
	var blockPositionData={};
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var miny=0;
	var maxy=0;
	var minz=0;
	var maxz=0;
	var midx=0;
	var leftx=0;
	var rightx=0;
	var bestrs;
	var bestls;
	var bestrp;
	var bestlp;	
	var xmove=Math.round(parseFloat(xdist));
	var maxmirrorx=0;
	var rightconnected=false;
	var leftconnected=false;	
	var fillerblock=(shapedBlocks["wood"]).blockIds[0];
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList=blocks.BLR;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var colorlist=blocks.BCI;
	var beilist=blocks.BEI;	
	var blockcount=blocklist.length; //needed cause variableblocklist :D
	var beiIndex=0;
	var currentIndex = blockcount; //index to add new blocks
	var currentBeiIndex = beilist.length;; //index to add new blocks
	var currentSCIndex=SClist.length;
	var SCcount=SClist.length;
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		blockPositionData[atos(tpa)]=blockIndex;
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
		miny=Math.min(tpa[1],miny);
		maxy=Math.max(tpa[1],maxy);
		minz=Math.min(tpa[2],minz);
		maxz=Math.max(tpa[2],maxz);
	}
	var midy=Math.round((miny+maxy)/2);
	var midz=Math.round((minz+maxz)/2);	
	midx=((minx+maxx)/2)+parseFloat(xshift);
	midx=Math.round(midx-0.2);
	leftx=midx;
	rightx=leftx+1;	
	
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var tpa = stoar(positionList[blockIndex]);
		var curx = tpa[0];
		if (curx>midx){
			positionList[blockIndex]=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
			if((tpa[0]==rightx)&&(!leftconnected)&&(!rightconnected)){
				leftblock=atos([leftx,tpa[1],tpa[2]]);
				if(blockPositionData[leftblock]!==undefined&&blockPositionData[leftblock]>=0){
					midy=tpa[1];
					midz=tpa[2];
					leftconnected=true;
					rightconnected=true;
				}
			}
			if((tpa[0]==rightx)&&(!rightconnected)){
				if(!bestrp){
					bestrp=atos(tpa);
					bestrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
				}else{
					var currentrs=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
					if(currentrs<bestrs){
						bestrp=atos(tpa);
						bestrs=currentrs;
					}
				}
				
			}
		
		}else{
			if((tpa[0]==leftx)&&(!leftconnected)){
				if(!bestlp){
					bestlp=atos(tpa);
					bestls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
				}else{
					var currentls=Math.pow(tpa[1],2)+Math.pow(tpa[2],2);
					if(currentls<bestls){
						bestlp=atos(tpa);
						bestls=currentls;					
					}
				}
			}
		}
	}
	//add filllerblock

	for (var i=rightx;i<(rightx+xmove);i++){
		blocks.BlockIds[currentIndex]=fillerblock;
		blocks.BLP[currentIndex]=atos([i,midy,midz]);
		blocks.BLR[currentIndex]=0;
		blocks.BP1[currentIndex]="0,0,0,0";
		blocks.BP2[currentIndex]="0,0,0,0";
		blocks.BCI[currentIndex]=0;
		currentIndex++;
	}
	
	//connect left
	if((bestlp)&&(!leftconnected)){
		var bestla=stoar(bestlp);
		var starty=Math.min(bestla[1],midy+1);
		var endy=Math.max(bestla[1],midy-1);		
		var startz=Math.min(bestla[2],midz+1);
		var endz=Math.max(bestla[2],midz-1);
		
		for(var y=starty;y<=endy;y++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+1,y,midz]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		for(var z=startz;z<=endz;z++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+1,bestla[1],z]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		leftconnected=true;
	}
	//connect right
	if((bestrp)&&(!rightconnected)){
		var bestra=stoar(bestrp);
		var starty=Math.min(bestra[1],midy+1);
		var endy=Math.max(bestra[1],midy-1);		
		var startz=Math.min(bestra[2],midz+1);
		var endz=Math.max(bestra[2],midz-1);
		
		for(var y=starty;y<=endy;y++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+xmove,y,midz]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		for(var z=startz;z<=endz;z++){
			blocks.BlockIds[currentIndex]=fillerblock;
			blocks.BLP[currentIndex]=atos([leftx+xmove,bestra[1],z]);
			blocks.BLR[currentIndex]=0;
			blocks.BP1[currentIndex]="0,0,0,0";
			blocks.BP2[currentIndex]="0,0,0,0";
			blocks.BCI[currentIndex]=0;
			currentIndex++;		
		}
		rightconnected=true;
	}
	if((!leftconnected)||(!rightconnected)){
		alert("Left and right sides might not be connected properly");
	}


	for(var scID = 0; scID < SCcount; scID++){
		var sctype=getType(SClist[scID].ItemNumber);
		var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
		var tpa = stoar((SClist[scID]).LocalPosition);
		var curx = tpa[0];
		if(curx>midx){			
			(SClist[scID]).LocalPosition=atos([tpa[0]+xmove,tpa[1],tpa[2]]);
			//check if turret disconnected
			if((sctype==2)&&(tpa[0]==rightx)){
				var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
				if(Math.round(newpos[0])==-1){
					alert("A turret or spin block might be disconnected after after the process.");
				}
			}
		}else{
			if((sctype==2)&&(tpa[0]==leftx)){
				var newpos=posTransform([0,-1,0],stoa((SClist[scID]).LocalRotation));
				if(Math.round(newpos[0])==1){
					alert("A turret or spin block might be disconnected after after the process.");
				}			
			}
			
		}
	}
	cleanBlueprint(blocks);		
}



//need to modify when we can check for parts sticking out
function cutAndMirror(blocks,xshift,even){
	blocks.designChanged = true;
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var midx=0;
	var xmove=0;
	var maxmirrorx=0;
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList=blocks.BLR;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var colorlist=blocks.BCI;
	var beilist=blocks.BEI;	
	var blockcount=blocklist.length; //needed cause variableblocklist :D
	var beiIndex=0;
	var currentIndex = blockcount; //index to add new blocks
	var currentBeiIndex = beilist.length;; //index to add new blocks
	var currentSCIndex=SClist.length;
	var SCcount=SClist.length;
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
	}
	
	midx=((minx+maxx)/2)+xshift;
	midx=Math.round(midx-0.2);
	
	if(even){
		maxmirrorx=midx;
		xmove=(midx*2)+1;
	}else{
		maxmirrorx=midx-1;
		xmove=midx*2;
	}
	
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var tpa = stoar(positionList[blockIndex]);
		var curx = tpa[0];
		if (curx>midx){
			blocklist[blockIndex]=-1;
		}else if (curx<=maxmirrorx){
			var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

			blocks.BlockIds[currentIndex]=mirrordata.blockID;
			var newposition=stoar(mirrordata.position);
			newposition[0]=newposition[0]+xmove;
			blocks.BLP[currentIndex]=atos(newposition);
			blocks.BLR[currentIndex]=mirrordata.rotation;
			blocks.BP1[currentIndex]=bp1list[blockIndex];
			blocks.BP2[currentIndex]=bp2list[blockIndex];
			blocks.BCI[currentIndex]=colorlist[blockIndex];
			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				blocks.BEI[currentBeiIndex]=currentIndex;
				var beiIncrement = beilist[beiIndex+1]+2;
				for(var i=1;i<beiIncrement;i++){
					blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
				}
				beiIndex+=beiIncrement;
				currentBeiIndex+=beiIncrement;
			}else if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){				
				var beiIncrement = beilist[beiIndex+1]+2;
				beiIndex+=beiIncrement;
			}		
			//blocklist[blockIndex]=-1;			
			currentIndex+=1;
		}
				
	}

	for(var scID = 0; scID < SCcount; scID++){
		if(!(SClist[scID].COL)){
			var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
			var tpa = stoar((SClist[scID]).LocalPosition);
			var curx = tpa[0];
			if(curx>midx){
				SClist[scID].ItemNumber=-1;
			}else if (curx<=maxmirrorx){
				tpa[0]=xmove-tpa[0];
				blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
				blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
				blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
				mirrorVehicle(blocks.SCs[currentSCIndex]);
				currentSCIndex++;			
			}			
		}else{
			SClist[scID].ItemNumber=-1;
		}
	}
	cleanBlueprint(blocks);		
}


//need to modify when we can check for parts sticking out
function jointMirror(blocks,even){
	blocks.designChanged = true;
	var SClist=blocks.SCs;
	var minx=0;
	var maxx=0;
	var xmove=0;
	var maxmirrorx=0;
	var blocklist=blocks.BlockIds;
	var positionList=blocks.BLP;
	var rotationList=blocks.BLR;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var colorlist=blocks.BCI;
	var beilist=blocks.BEI;	
	var blockcount=blocklist.length; //needed cause variableblocklist :D
	var beiIndex=0;
	var currentIndex = blockcount; //index to add new blocks
	var currentBeiIndex = beilist.length;; //index to add new blocks
	var currentSCIndex=SClist.length;
	var SCcount=SClist.length;
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var currentPosition = "["+positionList[blockIndex]+"]";
		var tpa = JSON.parse(currentPosition);
		var curx = Math.round(tpa[0]);
		minx=Math.min(curx,minx);
		maxx=Math.max(curx,maxx);
	}
	
	
	
	if(even){
		maxmirrorx=maxx;
		xmove=(maxx*2)+1;
	}else{
		maxmirrorx=maxx-1;
		xmove=maxx*2;
	}


	
	for(var blockIndex = 0; blockIndex < blockcount; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		var tpa = stoar(positionList[blockIndex]);
		var curx = tpa[0];
		if (curx<=maxmirrorx){
			var mirrordata=getMirrorData(blocklist[blockIndex],positionList[blockIndex],rotationList[blockIndex]);

			blocks.BlockIds[currentIndex]=mirrordata.blockID;
			var newposition=stoar(mirrordata.position);
			newposition[0]=newposition[0]+xmove;
			blocks.BLP[currentIndex]=atos(newposition);
			blocks.BLR[currentIndex]=mirrordata.rotation;
			blocks.BP1[currentIndex]=bp1list[blockIndex];
			blocks.BP2[currentIndex]=bp2list[blockIndex];
			blocks.BCI[currentIndex]=colorlist[blockIndex];
			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				blocks.BEI[currentBeiIndex]=currentIndex;
				var beiIncrement = beilist[beiIndex+1]+2;
				for(var i=1;i<beiIncrement;i++){
					blocks.BEI[currentBeiIndex+i]=beilist[beiIndex+i];
				}
				beiIndex+=beiIncrement;
				currentBeiIndex+=beiIncrement;
			}else if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){				
				var beiIncrement = beilist[beiIndex+1]+2;
				beiIndex+=beiIncrement;
			}		
			//blocklist[blockIndex]=-1;			
			currentIndex+=1;
		}
				
	}

	for(var scID = 0; scID < SCcount; scID++){
		if(!(SClist[scID].COL)){
			var currentPosition = "["+(SClist[scID]).LocalPosition+"]";
			var tpa = stoar((SClist[scID]).LocalPosition);
			var curx = tpa[0];
			if (curx<=maxmirrorx){
				tpa[0]=xmove-tpa[0];
				blocks.SCs[currentSCIndex]=JSON.parse(JSON.stringify(SClist[scID]));
				blocks.SCs[currentSCIndex].LocalRotation=quatMirror(SClist[currentSCIndex].LocalRotation);
				blocks.SCs[currentSCIndex].LocalPosition=atos(tpa);
				mirrorVehicle(blocks.SCs[currentSCIndex]);
				currentSCIndex++;			
			}			
		}else{
			SClist[scID].ItemNumber=-1;
		}
	}
	cleanBlueprint(blocks);		
}




//turn blocks into beams
function beamifyblocks2(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  beamifyblocks2(SClist[scID]);
 }
 var blockPositionData = {};
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  if(ItemDic[currentBlock]){
   if(blockToBeam[currentBlock]){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;    
    //var currentPosition = ""+Math.round(tpa[0])+","+Math.round(tpa[1])+","+Math.round(tpa[2]);
    //targetBlock =blockToBeam[currentBlock];    
    blockPositionData[currentPosition]=blockIndex;    
   }
  }
 }
 
 //z=axis
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex];
  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArray(0,0,-1,blockIndex,blocklist,colorlist,positionList,blockPositionData);
   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxis(0,0,1,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,0);
   }

  }

 }//z=axis 
 

 //y=axis
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex];
  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArray(0,-1,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxis(0,1,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,8);
   }

  }
 }//y=axis 
 
 
 //x=axis
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex];
  if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArray(-1,0,0,blockIndex,blocklist,colorlist,positionList,blockPositionData);
   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxis(1,0,0,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,1);
   }

  }
 }//x=axis  

	cleanBlueprint(blocks);
}



function getAxis(axis,neg){
	var tempaxis=[0,0,0];
	if(neg){
		tempaxis[axis]=-1;
	}else{
		tempaxis[axis]=1;
	}
	return tempaxis;
}


//optimize
function beamifyblocksOptimized(blocks){	
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		beamifyblocksOptimized(SClist[scID]);
	}
	var blockPositionData = {};
	var blocklist=blocks.BlockIds;
	var colorlist=blocks.BCI;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock = blocklist[blockIndex];
		if(ItemDic[currentBlock]){
			if(blockToBeam[currentBlock]){				
				var tpa = stoar(positionList[blockIndex]);
				var currentPosition = atos(tpa);
				blockPositionData[currentPosition]=blockIndex;    
			}
		}
	}

	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		var currentBlock=blocklist[blockIndex];
		if(ItemDic[currentBlock]&&blockToBeam[currentBlock]){
			var localPositionData = {};
			getLocalArray(blockIndex,blocklist,colorlist,positionList,blockPositionData,localPositionData);			
			while(true){
				for(position in localPositionData){
					if((blocklist[localPositionData[position].blockIndex]!==currentBlock)||(localPositionData[position].score>199)){
						delete localPositionData[position];
					}else{
						localPositionData[position].score=0;
					}
				}
				//scoring start
				var localScore=0;
				var beamAxis=0;
				for(position in localPositionData){
					var blockscore=false;
					var currentData=localPositionData[position];
					var lpa = stoar(position);
					var templength;
					var tempdir;
					//scoring for each axis x,y,z
					for (var axis=0;axis<3;axis++){
						templength=1;
						for(var neg=0;neg<2;neg++){
							tempdir=getAxis(axis,neg);
							for(var tempindex=1;tempindex<4;tempindex++){
								var tempLocalPosition = "" + (lpa[0]+tempdir[0]*tempindex)+","+(lpa[1]+tempdir[1]*tempindex)+","+(lpa[2]+tempdir[2]*tempindex);
								if(localPositionData[tempLocalPosition]!==undefined){
									templength+=1;      
								}else{
									break;
								}
							}
						}
						if (templength>=4){
							
							blockscore=true;
							beamAxis+=1;
							localPositionData[position].score+=(templength-1);
						}
					}
					//score local block
					if(blockscore){
						
						currentData.score+=1;
						localScore+=1;
					}
				}
				
				//proceed if there are beamable blocks
				if (localScore>0){					

					//beamAxis is number of axis that is beamable 

					var scoreTable=[];
					var scoreIndex=0;
					var dedup={};

					//permutate possible beams and scores, then sort
					var minscore=200;
					var scorecap=11;
					for(position in localPositionData){
						var currentData=localPositionData[position];
						var lpa = stoar(position);
						var tempdir1;
						var tempdir2;
						
						for (var axis=0;axis<3;axis++){
						
							dedup={};
							tempdir1=getAxis(axis,true);
							tempdir2=getAxis(axis,false);
							for(tempindex=0;tempindex<4;tempindex++){
								var tempLocalPosition = "" + (lpa[0]+tempdir1[0]*tempindex)+","+(lpa[1]+tempdir1[1]*tempindex)+","+(lpa[2]+tempdir1[2]*tempindex);
								if((localPositionData[tempLocalPosition]!==undefined)&&(localPositionData[tempLocalPosition].score>=4)){
									if((localPositionData[tempLocalPosition].score>scorecap)||(localPositionData[tempLocalPosition].score>(minscore-12))){										
										dedup[tempLocalPosition]=true;
										continue;
									}
									var llpa = stoar(tempLocalPosition);
									if(!dedup[tempLocalPosition]){
										var templength=1;
										for(var temptempindex=1;temptempindex<4;temptempindex++){											
											temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
											if((localPositionData[temptempLocalPosition]!==undefined)&&(localPositionData[temptempLocalPosition].score>=4)){
												templength+=1;
											}else{
												break;
											}
										}
										if(templength==4){
											
											dedup[tempLocalPosition]=true;
											var scoreBlock=[];
											for(var temptempindex=0;temptempindex<4;temptempindex++){
												temptempLocalPosition = "" + (llpa[0]+tempdir2[0]*temptempindex)+","+(llpa[1]+tempdir2[1]*temptempindex)+","+(llpa[2]+tempdir2[2]*temptempindex);
												scoreBlock[temptempindex]=localPositionData[temptempLocalPosition];
											}
											scoreBlock[4]=BeamAxisRot[axis]; //rotation
											scoreBlock[5]=BeamAxisPriority[axis]; //priority
											scoreBlock[6]=llpa[axis]; //priority2

											var tempscore=scoreBlock[0].score+scoreBlock[1].score+scoreBlock[2].score+scoreBlock[3].score;
											if((tempscore>=16)&&(tempscore<=minscore)){
												minscore=tempscore;
												scoreTable[scoreIndex] = scoreBlock;
												scoreIndex++;
											}
										}
									}
								}else{
									break;
								}
							}							

						}
				  
					}

					//sort
					var bestscore=199;
					while(scoreTable.length>0){
						scoreTable.sort(function(a, b){
							res=(a[0].score+a[1].score+a[2].score+a[3].score)-(b[0].score+b[1].score+b[2].score+b[3].score);
							if(res==0){
								var resa=(a[5]-b[5]);
								if(resa==0){
									return a[6]-b[6];
								}else{
									return resa;
								}
							}else{
								return res;
							}
						});

						currentScoreBlock=scoreTable[0];
						if((currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score)>bestscore){
							break;
						}else{
							bestscore=currentScoreBlock[0].score+currentScoreBlock[1].score+currentScoreBlock[2].score+currentScoreBlock[3].score;
							currentScoreBlock[0].score=200;
							currentScoreBlock[1].score=200;
							currentScoreBlock[2].score=200;
							currentScoreBlock[3].score=200;
							blocksBeamed+=1;

							blocklist[currentScoreBlock[1].blockIndex]=-1;
							blocklist[currentScoreBlock[2].blockIndex]=-1;
							blocklist[currentScoreBlock[3].blockIndex]=-1;

							blocklist[currentScoreBlock[0].blockIndex]=blockToBeam[currentBlock];
							rotationList[currentScoreBlock[0].blockIndex]=currentScoreBlock[4];  
						}
					}
				}
				else{
					//exit loop if no beamable blocks
					break;
				}
			}//end while
		   //scoring end
		}
	}
	cleanBlueprint(blocks);
}


function removeOverlap(blocks){
	var blockPosData = {};
	var blocklist=blocks.BlockIds;
	var colorlist=blocks.BCI;
	var positionList=blocks.BLP;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){		
		var currentBlock = blocklist[blockIndex];
		var blockData = getBlock(currentBlock);
		var tempBlock={};
		var currentPosition = stoar(positionList[blockIndex]);
		tempBlock.blockId=currentBlock;
		tempBlock.blockIndex=blockIndex;
		tempBlock.pos=positionList[blockIndex];
		tempBlock.rot=rotationList[blockIndex];
		tempBlock.bci=colorlist[blockIndex];
		tempBlock.overlap=false;
		if(blockData){
			
			for (var x=blockData.negx;x<=blockData.posx;x++){
				for (var y=blockData.negy;y<=blockData.posy;y++){
					for (var z=blockData.negz;z<=blockData.posz;z++){
						var q=getQuat(rotationList[blockIndex]);
						var temppos=posTransform([x,y,z],q);
						currentPosition
						var strPos=atos([temppos[0]+currentPosition[0],temppos[1]+currentPosition[1],temppos[2]+currentPosition[2]]);
						if (blockPosData[strPos]){
							//overlap
							//maybe can consider performing beam to block here
							tempBlock.overlap=true;
							blocklist[blockIndex]=-1;
						}else{
							blockPosData[strPos]=tempBlock;
							//no overlap
						}
					}
				}
			}
		}else{
			//block not found?
		}
	
	}
	var tempBlockIndex=blocklist.length;
	for(position in blockPosData){
		var tempBlock=blockPosData[position];
		if(tempBlock.overlap){
			if(beamToBlock[tempBlock.blockId]){
				var newBlockId=beamToBlock[tempBlock.blockId];
				blocklist[tempBlockIndex]=newBlockId;
				rotationList[tempBlockIndex]=0;
				colorlist[tempBlockIndex]=tempBlock.bci;
				blocks.BP1[tempBlockIndex]="0,0,0,0";
				blocks.BP2[tempBlockIndex]="0,0,0,0";
				positionList[tempBlockIndex]= position;
				tempBlockIndex+=1;				
			}else if(slopeBeamToBlock[tempBlock.blockId]){
				var newBlockId=slopeBeamToBlock[tempBlock.blockId];
				blocklist[tempBlockIndex]=newBlockId;
				var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],false);
				rotationList[tempBlockIndex]=targetRotation;
				colorlist[tempBlockIndex]=tempBlock.bci;
				blocks.BP1[tempBlockIndex]="0,0,0,0";
				blocks.BP2[tempBlockIndex]="0,0,0,0";
				positionList[tempBlockIndex]= position;
				tempBlockIndex+=1;			
			}else if(slopeBeamToBlockM[tempBlock.blockId]){
				var newBlockId=slopeBeamToBlockM[tempBlock.blockId];
				blocklist[tempBlockIndex]=newBlockId;
				var targetRotation = slopeBeamToBlockOrientation(rotationList[tempBlock.blockIndex],true);
				rotationList[tempBlockIndex]=targetRotation;
				colorlist[tempBlockIndex]=tempBlock.bci;
				blocks.BP1[tempBlockIndex]="0,0,0,0";
				blocks.BP2[tempBlockIndex]="0,0,0,0";
				positionList[tempBlockIndex]= position;
				tempBlockIndex+=1;			
			}

		}
		
	}	
	cleanBlueprint(blocks);
}


function beamifyslopeblocks(blocks){
 var SClist=blocks.SCs;
 blocks.designChanged = true;
 for(var scID = 0; scID < SClist.length; scID++){
  beamifyslopeblocks(SClist[scID]);
 }
 var blockPositionData = {};
 var blocklist=blocks.BlockIds;
 var colorlist=blocks.BCI;
 var positionList=blocks.BLP;
 var rotationList = blocks.BLR;
 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock = blocklist[blockIndex];
  if(ItemDic[currentBlock]){
   if(slopeBlockToBeam[currentBlock]){
    var currentPosition = "["+positionList[blockIndex]+"]";
    var tpa = JSON.parse(currentPosition);
    var curx = Math.round(tpa[0]);
    var cury = Math.round(tpa[1]);
    var curz = Math.round(tpa[2]);
    currentPosition = ""+curx+","+cury+","+curz;       
    blockPositionData[currentPosition]=blockIndex;    
   }
  }
 }
 


 
 

 for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
  var currentBlock=blocklist[blockIndex]; 
  var currentRotation=rotationList[blockIndex];


  var dirx=0;
  var diry=0;
  var dirz=0;

  switch (currentRotation) {
   case 0:
   case 2:
   case 4:
   case 6:
   case 8:
   case 10:
   case 12:
   case 14:
    dirx=1;
    diry=0;
    dirz=0;
    break;
   case 16:
   case 17:
   case 18:
   case 19:
   case 20:
   case 21:
   case 22:
   case 23:
    dirx=0;
    diry=1;
    dirz=0;
    break;   
   case 1:
   case 3:
   case 5:
   case 7:
   case 9:
   case 11:
   case 13:
   case 15:
    dirx=0;
    diry=0;
    dirz=1;
    break;
   default:
  } 
 

  if(ItemDic[currentBlock]&&slopeBlockToBeam[currentBlock]){
  
   var lookbackArray=getLookbackArraySloped((-dirx),(-diry),(-dirz),blockIndex,blocklist,colorlist,positionList,blockPositionData,rotationList);   
   for(var k=(lookbackArray.length-1);k>=0;k--){
    beamifyaxisSloped(dirx,diry,dirz,lookbackArray[k],blocklist,colorlist,positionList,rotationList,blockPositionData,slopeBlockToBeamOrientation(currentRotation,false));
   }

  }

 }
 
	cleanBlueprint(blocks);
}


//returns different block ID if blocks needs to be converted
function getconverted(bID){
 if (conversionIndex[bID]){
  return conversionIndex[bID];  
 }
 else return(bID);
}

//accepts natural,metal,oil,scrap,crystal, returns RP value
function calculateRP(r1,r2,r3,r4,r5){
 return r1+r2*2+r3*3+r4*4+r5*10;
}



function downloadBlueprint(){
 try{
 
  if(document.getElementById("paintrestrict").checked){
	allowedcolor=document.getElementById("paintallow").value;
  }else{
	allowedcolor=-1;
  }
  if(document.getElementById("replaceold").checked){
   buildReplaceOldIndex();
   replaceOld(CurrentBlueprint.Blueprint);
  }
  if(document.getElementById("clearhull").checked){
   buildkeepIndex();
   clearhull(CurrentBlueprint.Blueprint);
  }
  if(document.getElementById("cutinhalf").checked){
   var xshift=parseInt(document.getElementById("centershift").value);
   cutInHalf(CurrentBlueprint.Blueprint,xshift);
  } 
  if(document.getElementById("cutandmirror").checked){
   var xshift=parseInt(document.getElementById("cloneshift").value);
   var even=document.getElementById("evenclone1").checked;
   cutAndMirror(CurrentBlueprint.Blueprint,xshift,even);
   removeOverlap(CurrentBlueprint.Blueprint);
  } 
  if(document.getElementById("jointmirror").checked){
   var even=document.getElementById("evenclone2").checked;
   jointMirror(CurrentBlueprint.Blueprint,even);
   removeOverlap(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("widen").checked){
	var xdist=parseInt(document.getElementById("widendistance").value);
	var xshift=parseInt(document.getElementById("widenshift").value);
	widenVehicle(CurrentBlueprint.Blueprint,xdist,xshift);
	removeOverlap(CurrentBlueprint.Blueprint);
  }
  
/*  
  if(document.getElementById("removeoverlap").checked){
   removeOverlap(CurrentBlueprint.Blueprint);
  } 
 */

  

  if (!isNumeric(document.getElementById("shieldr").value)){document.getElementById("shieldr").value=1.0;}
  if (!isNumeric(document.getElementById("shieldg").value)){document.getElementById("shieldg").value=1.0;}
  if (!isNumeric(document.getElementById("shieldb").value)){document.getElementById("shieldb").value=1.0;}
  if (!isNumeric(document.getElementById("shielda").value)){document.getElementById("shielda").value=1.0;}
  document.getElementById("shieldr").value=Math.min(1.0,document.getElementById("shieldr").value);
  document.getElementById("shieldg").value=Math.min(1.0,document.getElementById("shieldg").value);
  document.getElementById("shieldb").value=Math.min(1.0,document.getElementById("shieldb").value);
  document.getElementById("shielda").value=Math.min(10.0,document.getElementById("shielda").value);
  document.getElementById("shieldr").value=Math.max(0.0,document.getElementById("shieldr").value);
  document.getElementById("shieldg").value=Math.max(0.0,document.getElementById("shieldg").value);
  document.getElementById("shieldb").value=Math.max(0.0,document.getElementById("shieldb").value);
  document.getElementById("shielda").value=Math.max(0.10,document.getElementById("shielda").value);


  buildconversionIndex();
  buildblockColorIndex();
  convertblocks(CurrentBlueprint.Blueprint);  
  if(document.getElementById("highlightAI").checked){

   highlightBlocks(CurrentBlueprint.Blueprint);
  }else if(document.getElementById("randomcolor").checked){

   randomcolorblocks(CurrentBlueprint.Blueprint);
  }
  else if(document.getElementById("paint").checked){
   colorblocks(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("becomeStructure").checked){
   CurrentBlueprint.Blueprint.ItemNumber=ItemTable["cb5bfa64-c3fd-435c-b0da-3891a86b20d2"].BlockId;
   becomeStructure(CurrentBlueprint.Blueprint,false);
  }else if(document.getElementById("becomeVehicle").checked){
   CurrentBlueprint.Blueprint.ItemNumber=ItemTable["e63040c9-0027-4fd3-be30-67fe3e950140"].BlockId;
   becomeVehicle(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("rotateVehicle").checked){
   rotateBlueprint(CurrentBlueprint.Blueprint,document.getElementById("rotatedir").value);
  }   
  
  if(document.getElementById("mirrorLateral").checked){
   mirrorVehicle(CurrentBlueprint.Blueprint);
  }
  
  
  if(document.getElementById("debeamify").checked){
   blocksDebeamed = 0;  
   debeamifyblocks(CurrentBlueprint.Blueprint);
   debeamifyslopeblocks(CurrentBlueprint.Blueprint);
  }
  
  if(document.getElementById("beamifyOptimized").checked){
   blocksBeamed = 0;

   beamifyslopeblocks(CurrentBlueprint.Blueprint);
   //var starttime=(new Date()).getTime();   
   beamifyblocksOptimized(CurrentBlueprint.Blueprint);
   //var endtime=(new Date()).getTime(); 
   //alert(endtime-starttime);

  }else if(document.getElementById("beamify2").checked){
   blocksBeamed = 0;
   beamifyblocks2(CurrentBlueprint.Blueprint);
   beamifyslopeblocks(CurrentBlueprint.Blueprint);
  }

  selectedFileName = "Modified_" + selectedFileName;
  processData();
  document.getElementById("filecontent").style.display="block";
  document.getElementById("filetext").style.display="none";
  var outputcontent=JSON.stringify(CurrentBlueprint);
  document.getElementById("filetextbox").value=outputcontent;
  download(selectedFileName,outputcontent); 
  //download(selectedFileName,JSON.stringify(RotTable)); 

  
 }catch(err){
   throw err;
  loadError(err);
 }
}


function togglefiletext(){
 if(document.getElementById("filetext").style.display=="none"){
  document.getElementById("filetext").style.display="block";
  document.getElementById("filetextbox").select();
 }else{
  document.getElementById("filetext").style.display="none";
 }
}

function buildReplaceOldIndex(){
	replaceOldIndex = {};
	for(var key in ItemDic){
		var keyint = parseInt(key);
		var val = ItemDic[keyint];
		if(oldBlocks[val]){
			var tempblock={};
			tempblock.BlockId=ItemTable[oldBlocks[val].Guid].BlockId;
			tempblock.Rot=oldBlocks[val].Rot;
			replaceOldIndex[keyint]=tempblock;
		}
	}
}

function replaceOld(blocks){
	var SClist=blocks.SCs;
	blocks.designChanged = true;
	for(var scID = 0; scID < SClist.length; scID++){
		replaceOld(SClist[scID]);
	}
	var blocklist=blocks.BlockIds;
	var rotationList = blocks.BLR;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		if(replaceOldIndex[blocklist[blockIndex]]){
			var replaceData = replaceOldIndex[blocklist[blockIndex]];
			var newRotation = blockRotate(replaceData.Rot,rotationList[blockIndex]);
			var newBlock = replaceData.BlockId;				
			blocklist[blockIndex] = newBlock;
			rotationList[blockIndex] = newRotation;
		}
	}
}

/*

  if(ItemTable[val]){
 for(var mat in shapedBlocks){
  if(document.getElementById(mat).checked){
   newmat=document.getElementById(mat+"to").value;
	if (newmat!=mat){
    var blockcount = shapedBlocks[mat].blockIds.length;
    for(var i=0;i<blockcount;i++){
	   if(newmat==0){
		conversionIndex[shapedBlocks[mat].blockIds[i]]=-1;
	   }else if ((i<shapedBlocks[newmat].blockIds.length)&&(shapedBlocks[newmat].blockIds[i]>=0)){
      conversionIndex[shapedBlocks[mat].blockIds[i]] = shapedBlocks[newmat].blockIds[i];
     }
    }
   }
  }  
 }
}
*/
//builds a lookup table of blockIDs to convert from:to
function buildconversionIndex(){
 conversionIndex = {};
 for(var mat in shapedBlocks){
  if(document.getElementById(mat).checked){
   newmat=document.getElementById(mat+"to").value;
	if (newmat!=mat){
    var blockcount = shapedBlocks[mat].blockIds.length;
    for(var i=0;i<blockcount;i++){
	   if(newmat==0){
		conversionIndex[shapedBlocks[mat].blockIds[i]]=-1;
	   }else if ((i<shapedBlocks[newmat].blockIds.length)&&(shapedBlocks[newmat].blockIds[i]>=0)){
      conversionIndex[shapedBlocks[mat].blockIds[i]] = shapedBlocks[newmat].blockIds[i];
     }
    }
   }
  }  
 }
}

//get color to paint blocks depending on selected option
function getNewColor(bID){
 if(document.getElementById("paint").checked){
  if(document.getElementById("painttarget").value=="all"){
   return selectedcolor;      
  }
  else if(document.getElementById("painttarget").value=="paintothers"){
   if(blockColorIndex[bID]!==undefined){
    return -1;
   }else{
    return selectedcolor;
   }
  }else{
   if(blockColorIndex[bID]!==undefined){
    return blockColorIndex[bID];
   }else{
    return -1;
   }
  }

 }
 else{
  return -1;
 }
}


//builds lookup table to help determine which blocks to color
function buildblockColorIndex(){
/*
painttarget:
all
wood
metal
alloy
glass
stone
lead
paintstruct
paintothers
*/
 blockColorIndex = {};
 
 if(document.getElementById("paint").checked){
  selectedcolor=document.getElementById("tocolor").value;
  
  if((document.getElementById("painttarget").value=="wood")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["wood"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["wood"].blockIds[i]] = selectedcolor;
   }
  }
  
  if((document.getElementById("painttarget").value=="metal")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["metal"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["metal"].blockIds[i]] = selectedcolor;
   }
  }  

  if((document.getElementById("painttarget").value=="alloy")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["alloy"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["alloy"].blockIds[i]] = selectedcolor;
   }
  } 

  if((document.getElementById("painttarget").value=="glass")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["glass"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["glass"].blockIds[i]] = selectedcolor;
   }
  }
  
  if((document.getElementById("painttarget").value=="heavyarmour")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["heavyarmour"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["heavyarmour"].blockIds[i]] = selectedcolor;
   }
  }
  
  if((document.getElementById("painttarget").value=="stone")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["stone"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["stone"].blockIds[i]] = selectedcolor;
   }
  }
  if((document.getElementById("painttarget").value=="lead")||(document.getElementById("painttarget").value=="paintstruct")||(document.getElementById("painttarget").value=="paintothers")){
   var blockcount =  shapedBlocks["lead"].blockIds.length;
   for(var i=0;i<blockcount;i++){
    blockColorIndex[shapedBlocks["lead"].blockIds[i]] = selectedcolor;
   }
  }
 }
}


function slopeBeamToBlockOrientation(blockrotate, mirrored){
 if(mirrored){
  switch (blockrotate) {
   case 0:
    return 1;
   case 1:
    return 2;
   case 2:
    return 3;
   case 3:
    return 0;
   case 4:
    return 16;
   case 5:
    return 17;
   case 6:
    return 19;
   case 7:
    return 18;
   case 8:
    return 18;
   case 9:
    return 16;
   case 10:
    return 17;   
   case 11:
    return 19;   
   case 12:
    return 7;   
   case 13:
    return 4;   
   case 14:
    return 5;   
   case 15:
    return 6;   
   case 16:
    return 5;   
   case 17:
    return 1;   
   case 18:
    return 3;   
   case 19:
    return 7; 
   case 20:
    return 0;    
   case 21:
    return 4;   
   case 22:
    return 6;   
   case 23:
    return 2;      
   default:
    return -1;
  } 
 }else{
 
  switch (blockrotate) {
   case 0:
    return 3;
   case 1:
    return 0;
   case 2:
    return 1;
   case 3:
    return 2;
   case 4:
    return 18;
   case 5:
    return 16;
   case 6:
    return 17;
   case 7:
    return 19;
   case 8:
    return 16;
   case 9:
    return 17;
   case 10:
    return 19;   
   case 11:
    return 18;   
   case 12:
    return 5;   
   case 13:
    return 6;   
   case 14:
    return 7;   
   case 15:
    return 4;   
   case 16:
    return 1;   
   case 17:
    return 5;   
   case 18:
    return 7;   
   case 19:
    return 3; 
   case 20:
    return 4;    
   case 21:
    return 0;   
   case 22:
    return 2;   
   case 23:
    return 6;      
   default:
    return -1;
  }
 }
 return -1;
}

function slopeBlockToBeamOrientation(beamrotate, negative){
 //negative not implemented
 switch (beamrotate) {
  case 0:
  case 8:
   return 1;
  case 2:
  case 10:
   return 22;
  case 4:
  case 12:
   return 20;
  case 6:
  case 14:
   return 13;
  case 1:
  case 9:
   return 16;
  case 3:   
  case 11:
   return 0;   
  case 5:  
  case 13:
   return 12;   
  case 7:  
  case 15:
   return 18;   
  case 16:  
  case 20:
   return 8;   
  case 17:  
  case 22:
   return 9; 
  case 18:   
  case 21:
   return 11;   
  case 19:   
  case 23:
   return 10;      
  default:
   return -1;
 }
 return -1;
}



function quatMirror(quat){
	var resquat = stoa(quat);
	resquat[0] = -resquat[0];
	resquat[3] = -resquat[3];
	return atos(resquat);
}

function getMirrorData(blockID,position,rotation){
	var newRotation = rotationMirror(rotation);
	var newBlock = blockID;
	var pa=stoar(position);
	pa[0]=(-pa[0]);


	if((ItemDic[blockID])&&(getBlock(blockID))){
		var curBlock = getBlock(blockID);
		var xdiff=Math.round(curBlock.XDiff);

		if(curBlock.MirrorBlock){
			var tempBlock=ItemTable[curBlock.MirrorBlock];
			if(tempBlock.BlockId>=0){
				newBlock=tempBlock.BlockId;
				xdiff=Math.round((xdiff+tempBlock.XDiff)/2);	
				
			}
			
		}
		if(xdiff!=0){
			var q=getQuat(newRotation);
			var positionshift=posTransform([-xdiff,0,0],q);
			pa[0]+=positionshift[0];
			pa[1]+=positionshift[1];
			pa[2]+=positionshift[2];
		} 
	}
	pa[0]=Math.round(parseFloat(pa[0]));
	pa[1]=Math.round(parseFloat(pa[1]));
	pa[2]=Math.round(parseFloat(pa[2]));

	var strposition = atos(pa);

	var mirrordata={}
	mirrordata.blockID=newBlock;
	mirrordata.position=strposition;
	mirrordata.rotation=newRotation;
	return mirrordata;
}

function flipX(position){
	var pa=stoar(position);
	pa[0]=(-pa[0]);
	var strposition = ""+pa[0]+","+pa[1]+","+pa[2];
	return strposition;
}

function rotationMirror(blockrotate){
	var q=getQuat(blockrotate);
	if(q){
		q[0]=-q[0];
		q[3]=-q[3];
		return getRot(q);
	}else{
		return -1;
	}
}

//rotate block rotation
function blockRotate(blockrotate,dir){
	var q=getQuat(blockrotate);
	if(q){
		var q1=getQuat(dir); 
		return getRot(quatmul(q1,q));
	}else{
		return -1;
	}
}

//rotate block position
function positionRotate(position,dir){
	pa=stoar(position);
	return atos(posTransform(pa,getQuat(dir)));
}

//rotate block quat
function quatRotate(quat,dir){
	return atos(quatmul(getQuat(dir),stoa(quat)));
}

function sameSlopeBlockOrientation(rotate1,rotate2){
	if(rotate1==rotate2){
		return true;
	}
	var r1=Math.min(rotate1,rotate2);
	var r2=Math.max(rotate1,rotate2); 
	if((r1==0&&r2==8)||(r1==1&&r2==9)||(r1==2&&r2==10)||(r1==3&&r2==11)||(r1==4&&r2==12)||(r1==5&&r2==13)||(r1==6&&r2==14)||(r1==7&&r2==15)||(r1==16&&r2==20)||(r1==17&&r2==22)||(r1==18&&r2==21)||(r1==19&&r2==23)){
		return true;
	}else{
		return false;
	}
}


//download file
//text/plain
//application/json
function download(filename, data) {
    var blob = new Blob([data], {type: 'text/plain'});
    if(window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
    }
    else{
        var elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;        
        document.body.appendChild(elem)
        elem.click();        
        document.body.removeChild(elem);
    }
}



//loads color palette
function getpalette(blocks){
	colorTableInverse=[];
	colorTable=[];
 var palettedata = blocks.COL;
 for(var palID = 0; palID < palettedata.length; palID++){
  palStr = "" + palID;
  if (palStr.length<2){
   palStr = "0" + palStr;
  }
  var colorString = palettedata[palID];
  var colorArray = colorString.split(',');
  
  var tempr = (colorArray[0] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var tempg = (colorArray[1] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var tempb = (colorArray[2] * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  
  var rtempr = ((1-colorArray[0]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var rtempg = ((1-colorArray[1]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  var rtempb = ((1-colorArray[2]) * 255 * (colorArray[3])) +(255*(1-colorArray[3]));
  
  
  colorTable[palID]=rgb2hex(tempr,tempg,tempb);
  colorTableInverse[palID]=rgb2hex(rtempr,rtempg,rtempb);
  document.getElementById("pal" + palStr).style.backgroundColor = colorTable[palID];
  document.getElementById("pal" + palStr).style.color = colorTableInverse[palID];
  document.getElementById("co" + palStr).style.backgroundColor = colorTable[palID];
  document.getElementById("co" + palStr).style.color = colorTableInverse[palID];

 }
 $( ".palette" ).change();
}

function countblocks(blocks){
	blockRenderData={};
	blockRenderIndex=0;
	maxc=[0,0,0,0];
	minc=[0,0,0,0];	
	return countblocksR(blocks,false,{},[0,0,0],[0,0,0,1]);	
}

//counts blocks and accumulate vehicle data
function countblocksR(blocks,notmain,parentpalette,parentposition,parentrotation){
	var shiftposition =[0,0,0];
	var shiftRotation =[0,0,0,1];

	if(notmain){
		shiftposition=stoa3(blocks.LocalPosition);
		shiftRotation=stoa(blocks.LocalRotation); 
	}
	
	var SClist=blocks.SCs;
	for(var scID = 0; scID < SClist.length; scID++){
		countblocksR(SClist[scID],true,blocks.COL,shiftposition,shiftRotation);
	}

	totalstats["Max Power*"] += Math.max(0,blocks.CSI[7]);
	totalstats["Max Battery Capacity*"] += Math.max(0,blocks.CSI[49]);
	totalstats["Max Ammo Capacity*"] += Math.max(0,blocks.CSI[38]);
	totalstats["Max Fuel Capacity*"] += Math.max(0,blocks.CSI[40]);
	totalstats["Max Natural Storage*"] += Math.max(0,blocks.CSI[23]);
	totalstats["Max Metal Storage*"] += Math.max(0,blocks.CSI[24]);
	totalstats["Max Oil Storage*"] += Math.max(0,blocks.CSI[25]);
	totalstats["Max Scrap Storage*"] += Math.max(0,blocks.CSI[26]);
	totalstats["Max Crystal Storage*"] += Math.max(0,blocks.CSI[27]);

	if(blocks.designChanged){
		totalstats["Blueprint Modified*"] = true;
	}



	var blocklist=blocks.BlockIds;
	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		countID[blocklist[blockIndex]] +=1;
		var currentBlock = getBlock(blocklist[blockIndex]);
		var tempRender={}

		var tempPosition=stoa3(blocks.BLP[blockIndex]);
		var tempRotation=getQuat(blocks.BLR[blockIndex]);
		
		
		if(notmain){
			var ttPosition=posTransformNR(shiftposition,parentrotation);
			//tempPosition=(tempPosition[0]+shiftRotation[0],tempPosition[1]+shiftRotation[1],tempPosition[2]+shiftRotation[2]);
			tempPosition=posTransformNR(tempPosition,shiftRotation);
			tempPosition=posTransformNR(tempPosition,parentrotation);
			
			tempPosition=[tempPosition[0]+ttPosition[0]+parentposition[0],tempPosition[1]+ttPosition[1]+parentposition[1],tempPosition[2]+ttPosition[2]+parentposition[2]];
			var ttrotation=quatmul(parentrotation,shiftRotation);
			//tempRotation=quatmul(shiftRotation,tempRotation);  
			//tempRotation=quatmul(parentrotation,tempRotation);  
			tempRotation=quatmul(ttrotation,tempRotation);  
		}
		
		var tempColor=[80,80,80,1];
		if(colorID[blocklist[blockIndex]]){
			tempColor=colorID[blocklist[blockIndex]];
		}
		var paintColor=[0,0,0,0];
		if(blocks.COL){
			paintColor=stoa(blocks.COL[blocks.BCI[blockIndex]]);
		}else{
			paintColor=stoa(parentpalette[blocks.BCI[blockIndex]]);
		}
		
		var tempr = (paintColor[0] * 255 * (paintColor[3])) +(tempColor[0]*(1-paintColor[3]));
		var tempg = (paintColor[1] * 255 * (paintColor[3])) +(tempColor[1]*(1-paintColor[3]));
		var tempb = (paintColor[2] * 255 * (paintColor[3])) +(tempColor[2]*(1-paintColor[3]));		
		var tempa = Math.max(paintColor[3]+tempColor[3],1);
		
		//tempColor = [tempr,tempg,tempb,tempa];
		tempColor=rgb2hex(tempr, tempg, tempb);
			
		var posx=0;
		var negx=0;
		var posy=0;
		var negy=0;
		var posz=0;
		var negz=0;

		if(currentBlock){
			posx=currentBlock.posx;
			negx=currentBlock.negx;
			posy=currentBlock.posy;
			negy=currentBlock.negy;
			posz=currentBlock.posz;
			negz=currentBlock.negz;   
			totalstats["Natural Cost"]+=currentBlock.Natural;
			totalstats["Metal Cost"]+=currentBlock.Metal;
			totalstats["Oil Cost"]+=currentBlock.Oil;
			totalstats["Scrap Cost"]+=currentBlock.Scrap;
			totalstats["Crystal Cost"]+=currentBlock.Crystal;
			totalstats["RP Cost"]+=currentBlock.SparesCost;
			totalstats["Volume"]+=currentBlock.Volume;			
		}
		tempRender.position=tempPosition;
		tempRender.rotation=tempRotation;
		tempRender.posx=posx;
		tempRender.negx=negx;
		tempRender.posy=posy;
		tempRender.negy=negy;
		tempRender.posz=posz;
		tempRender.negz=negz;
		tempRender.color=tempColor;
		maxc[0]=Math.max(maxc[0],tempPosition[0]);
		maxc[1]=Math.max(maxc[1],tempPosition[1]);
		maxc[2]=Math.max(maxc[2],tempPosition[2]);
		minc[0]=Math.min(minc[0],tempPosition[0]);
		minc[1]=Math.min(minc[1],tempPosition[1]);
		minc[2]=Math.min(minc[2],tempPosition[2]);		
		blockRenderData[blockRenderIndex]=tempRender;
		blockRenderIndex++
	}
}

//check for numeric
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

//change colors to hex format
function rgb2hex(red, green, blue) {
	var rgb = blue | (green << 8) | (red << 16);
	return '#' + (0x1000000 + rgb).toString(16).slice(1)
}

//getblockdata
function getBlock(bid){
	return ItemTable[ItemDic[bid]];
}

function roundToTwo(num) {
    return +(Math.round(num + "e+2")  + "e-2");
}


function cleanBlueprint(blocks){
	var SClist=blocks.SCs;
	var blocklist=blocks.BlockIds;
	var blrlist=blocks.BLR;
	var blplist=blocks.BLP;
	var bp1list=blocks.BP1;
	var bp2list=blocks.BP2;
	var bcilist=blocks.BCI; 
	var beilist=blocks.BEI;
	var blocknew=[];
	var blrnew=[];
	var blpnew=[];
	var bp1new=[];
	var bp2new=[];
	var bcinew=[];
	var beinew=[];
	var scnew=[];
	var newbeiindex=0;
	var currentIndex = 0;
	var beiIndex = 0;
	var newscindex=0;

	for(var scID = 0; scID < SClist.length; scID++){
		if(SClist[scID].ItemNumber>0){
			scnew[newscindex]=SClist[scID];
			newscindex++;
		}
	}

	for(var blockIndex = 0; blockIndex < blocklist.length; blockIndex++){
		if(blocklist[blockIndex]>=0){
			blocknew[currentIndex]=blocklist[blockIndex];
			blrnew[currentIndex]=blrlist[blockIndex];
			blpnew[currentIndex]=blplist[blockIndex];
			bp1new[currentIndex]=bp1list[blockIndex];
			bp2new[currentIndex]=bp2list[blockIndex];   
			bcinew[currentIndex]=bcilist[blockIndex];   

			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				beilist[beiIndex]=currentIndex;
				var beiIncrement = beilist[beiIndex+1]+2;
				for(var i=0;i<beiIncrement;i++){
					beinew[newbeiindex+i]=beilist[beiIndex+i];
				}
				beiIndex+=beiIncrement;
				newbeiindex+=beiIncrement;
			}
			currentIndex +=1;
		}else{
			//need to remove stringid references if block is removed
			if((beilist[beiIndex])&&(beilist[beiIndex]==blockIndex)){
				var beiIncrement = beilist[beiIndex+1]+2;
				beiIndex+=beiIncrement;
			}
		}
		if((beilist[beiIndex])&&(beilist[beiIndex]<blockIndex)){
		var beiIncrement = beilist[beiIndex+1]+2;
		beiIndex+=beiIncrement;
		}
	}
	
	blocks.BlockIds=blocknew;
	blocks.BLR=blrnew;
	blocks.BLP=blpnew;
	blocks.BP1=bp1new;
	blocks.BP2=bp2new;
	blocks.BCI=bcinew;
	blocks.BEI=beinew;
	blocks.SCs=scnew;
}

function getType(blockid){
	var curBlock = getBlock(blockid);
	if(curBlock){
		return curBlock.ItemType;
	}else{
		return -1;
	}
}



</script>	
		
	</head>
	<body>
	
	

<div data-role="page">
	
	<div data-role="header">
	<a href="#popupMenu" data-rel="popup" class="ui-btn ui-corner-all ui-shadow ui-btn-inline ui-icon-gear ui-btn-icon-left ui-btn-a">Links</a>
		<h1>Blueprint Modification Tool</h1>
	</div><!-- /header -->
	<div data-role="content">	
	<div data-role="popup" id="popupMenu">
        <ul id="linklist" data-role="listview" data-inset="true" style="min-width:210px;">
        </ul>
	</div>
	<p>Last updated for FTD v1.9572</p>
	<p>To start, click on the button below and choose a blueprint file.</p>
	
	<p>*Heavy Armour related features will only work with blueprints saved in v1.9565 and above.</p>
	<p>Please report any issues in the forum thread <a href="http://www.fromthedepthsgame.com/forum/showthread.php?tid=19547">here</a></p>
	<div class="hidden"><input type="file" id="blueprintfile" accept=".blueprint" onchange="openFile();"></div>
	<div class="ui-grid-solo">
		<div class="ui-block-a"><input class="lb" type="button" btarget="#blueprintfile" value="Open Blueprint" disabled>
		</div>
	</div>	
	<div class="ui-grid-a">
		<div class="ui-block-a">
	<div id="blocktoolpanel" data-role="collapsible">
		<h4>Block Modification Tools</h4>

		
<br>
<div class="ui-grid-a">
<div class="ui-block-a"><label class="checkbox" ><input class="bigbox" id="paintrestrict" type="checkbox" data-role="none">Restrict block modifications to blocks colored: </label></div>
<div class="ui-block-b">
<select id="paintallow" class="palette">
<option id="co00" value="0" selected="selected">00</option>
<option id="co01" value="1">01</option>
<option id="co02" value="2">02</option>
<option id="co03" value="3">03</option>
<option id="co04" value="4">04</option>
<option id="co05" value="5">05</option>
<option id="co06" value="6">06</option>
<option id="co07" value="7">07</option>
<option id="co08" value="8">08</option>
<option id="co09" value="9">09</option>
<option id="co10" value="10">10</option>
<option id="co11" value="11">11</option>
<option id="co12" value="12">12</option>
<option id="co13" value="13">13</option>
<option id="co14" value="14">14</option>
<option id="co15" value="15">15</option>
<option id="co16" value="16">16</option>
<option id="co17" value="17">17</option>
<option id="co18" value="18">18</option>
<option id="co19" value="19">19</option>
<option id="co20" value="20">20</option>
<option id="co21" value="21">21</option>
<option id="co22" value="22">22</option>
<option id="co23" value="23">23</option>
<option id="co24" value="24">24</option>
<option id="co25" value="25">25</option>
<option id="co26" value="26">26</option>
<option id="co27" value="27">27</option>
<option id="co28" value="28">Detail</option>
<option id="co29" value="29">Trim</option>
<option id="co30" value="30">Secondary</option>
<option id="co31" value="31">Main</option>
</select>
</div>
</div>
		<hr>
		
<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="wood" type="checkbox" data-role="none">Convert Wood: 
		<select id="woodto" data-role="none"><option value="wood" selected="selected"> to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>		


<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="metal" type="checkbox" data-role="none">Convert Metal: 
		<select id="metalto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal" selected="selected">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="alloy" type="checkbox" data-role="none">Convert Alloy: 
		<select id="alloyto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" selected="selected">to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="glass" type="checkbox" data-role="none">Convert Glass: 
		<select id="glassto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass" selected="selected">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="heavyarmour" type="checkbox" data-role="none">Convert Heavy Armour: 
		<select id="heavyarmourto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour" selected="selected">to Heavy Armour</option> <option value="stone">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>

<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="stone" type="checkbox" data-role="none">Convert Stone: 
		<select id="stoneto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone" selected="selected">to Stone</option> <option value="lead">to Lead</option><option value="0" >delete!</option></select>	
		</label>
	</div>
</div>


<div class="ui-grid-solo">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="lead" type="checkbox" data-role="none">Convert Lead: 
		<select id="leadto" data-role="none"><option value="wood" > to Wood</option><option value="alloy" >to Alloy</option><option value="metal">to Metal</option> <option value="glass">to Glass</option> <option value="heavyarmour">to Heavy Armour</option>  <option value="stone">to Stone</option> <option value="lead" selected="selected">to Lead</option><option value="0" >delete!</option></select>
		</label>
	</div>
</div>
<hr>
<div class="ui-grid-a">
	<div class="ui-block-a">
		<label class="checkbox" >
		<input class="bigbox" id="paint" type="checkbox" data-role="none">Paint:
		<select id="painttarget" data-role="none"><option value="all" selected="selected"> all blocks</option> <option value="wood"> Wood </option> <option value="metal"> Metal </option><option value="alloy"> Alloy </option><option value="glass"> Glass </option><option value="heavyarmour"> Heavy Armour </option><option value="stone"> Stone </option><option value="lead"> Lead </option><option value="paintstruct"> All of the above </option><option value="paintothers"> None of the above</option></select>
		</label>
	</div>
	<div class="ui-block-b">
<select id="tocolor" class="palette">
	<option id="pal00" value="0" selected="selected">00</option>
	<option id="pal01" value="1">01</option>
	<option id="pal02" value="2">02</option>
	<option id="pal03" value="3">03</option>
	<option id="pal04" value="4">04</option>
	<option id="pal05" value="5">05</option>
	<option id="pal06" value="6">06</option>
	<option id="pal07" value="7">07</option>
	<option id="pal08" value="8">08</option>
	<option id="pal09" value="9">09</option>
	<option id="pal10" value="10">10</option>
	<option id="pal11" value="11">11</option>
	<option id="pal12" value="12">12</option>
	<option id="pal13" value="13">13</option>
	<option id="pal14" value="14">14</option>
	<option id="pal15" value="15">15</option>
	<option id="pal16" value="16">16</option>
	<option id="pal17" value="17">17</option>
	<option id="pal18" value="18">18</option>
	<option id="pal19" value="19">19</option>
	<option id="pal20" value="20">20</option>
	<option id="pal21" value="21">21</option>
	<option id="pal22" value="22">22</option>
	<option id="pal23" value="23">23</option>
	<option id="pal24" value="24">24</option>
	<option id="pal25" value="25">25</option>
	<option id="pal26" value="26">26</option>
	<option id="pal27" value="27">27</option>
	<option id="pal28" value="28">Detail</option>
	<option id="pal29" value="29">Trim</option>
	<option id="pal30" value="30">Secondary</option>
	<option id="pal31" value="31">Main</option>
 </select>	
	</div>
</div>


<hr>

<div class="ui-grid-a">
<div class="ui-block-a"><label class="checkbox"><input class="bigbox" id="shieldcolor" type="checkbox" data-role="none">Modify all shield color changers </label><div class="subtext"><i>Limits: <br>R, G, B between 0 and 1,<br>Alpha between 0.10 and 10.<br><br>Only affect shields with shield color changers. <br></i></div></div>
<div class="ui-block-b">
<div class="ui-field-contain"><label for="shieldr">R</label><input type="range" name="shieldr" style="background-color:#FF7F7F;" id="shieldr" min="0" max="1" step="0.01" value="1"></div>
<div class="ui-field-contain"><label for="shieldg">G</label><input type="range" name="shieldg" style="background-color:#7FFF7F;" id="shieldg" min="0" max="1" step="0.01" value="1"></div>
<div class="ui-field-contain"><label for="shieldb">B</label><input type="range" name="shieldb" style="background-color:#7F7FFF;" id="shieldb" min="0" max="1" step="0.01" value="1"></div>
<div class="ui-field-contain"><label for="shielda">A</label><input type="range" name="shielda" id="shielda" min="0.1" max="10" step="0.01" value="1"></div>
</div>
</div>


</div>


	

		
		
		

<div id="vehicletoolpanel" data-role="collapsible">
<h4>Vehicle Modification Tools</h4>

<br>
<div class="ui-grid-a">
<div class="ui-block-a">
<label><input id="highlightAI" type="checkbox" data-mini="true">Highlight AI, ACB, PID blocks (will overwrite paint settings)</label>
</div>
<div class="ui-block-b">
<label><input id="randomcolor"  type="checkbox" data-mini="true">Randomly paint main vehicle (will overwrite paint settings)</label>
</div>
</div>

<div class="ui-grid-a">
<div class="ui-block-a">
<label><input id="replaceold" type="checkbox" data-mini="true">Replace old armor blocks (1m and 2m left,right,and up slopes)</label>
</div>
<div class="ui-block-b">
<label><input id="clearhull" type="checkbox" data-mini="true">Delete all blocks except Wood/Alloy/Metal/Glass/HA/Stone/Lead.</label>
</div>
</div>


<div class="ui-grid-a">
<div class="ui-block-a">
<label><input id="becomeVehicle" type="checkbox" data-mini="true">Turn blueprint into a Vehicle (Invalid blocks will be deleted!)</label>
</div>
<div class="ui-block-b">
<label><input id="becomeStructure" type="checkbox" data-mini="true">Turn blueprint into a Structure (Invalid blocks will be deleted!)</label>
</div>
</div>

<hr>


<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="rotateVehicle" type="checkbox" data-role="none">Rotate vehicle: </label>
</div>
<div class="ui-block-b">
<select id="rotatedir" data-mini="true" >
	<option value="1" selected="selected">Turn Right</option>
	<option value="3" >Turn Left</option>
	<option value="10" >Nose Up</option>
	<option value="4" >Nose Down</option>
	<option value="16" >Roll Right</option>
	<option value="18" >Roll Left</option>	
</select>
</div>
</div>
<hr>



<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="debeamify" type="checkbox" data-mini="true">DeBeamify. Turns Wood/Alloy/Metal/Glass/HA/Stone/Lead 4m beams and diagonal slopes into 1m blocks and slopes.</label>
</div>
</div>
<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="beamify2" type="checkbox" data-mini="true">Beamify. Turns Wood/Alloy/Metal/Glass/HA/Stone/Lead 1m blocks and slopes into 4m beams and diagonal slopes.</label>
</div>
</div>

<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="beamifyOptimized" type="checkbox" data-mini="true">Beamify using an optimization algorithm. Slower but will fit in more beams. It can take up to a few minutes for large unbeamed vehicles.</label>
</div>
</div>

<hr>

<div class="ui-grid-solo">
<div class="ui-block-a">
<label><input id="mirrorLateral" type="checkbox" data-mini="true">Mirror vehicle laterally (flip left and right sides)</label>
</div>
</div>
<hr>



<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="cutinhalf" type="checkbox" data-role="none">Cut the blueprint in half! Only left side remains!</label>
</div>
<div class="ui-block-b" >
<div class="ui-field-contain"><label for="centershift">Cut position</label><input  data-mini="true" type="range" min="-100" max="100" name="centershift" id="centershift"  step="1" value="0"></div>
</div>
</div>
<hr>

<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="jointmirror" type="checkbox" data-role="none">Attach a mirrored copy of the vehicle on the right!</label>
</div>
<div class="ui-block-b">
<label><input  id="evenclone2" type="checkbox" data-mini="true">Even Width?</label>
</div>
</div>
<hr>

<div class="ui-grid-a">
<div class="ui-block-a">
<label class="checkbox"><input class="bigbox" id="cutandmirror" type="checkbox" data-role="none">Replace the right side with a mirrored copy of the left!</label>
</div>
<div class="ui-block-b">
<label><input id="evenclone1" type="checkbox" data-mini="true">Even Width?</label>
<div class="ui-field-contain"><label for="cloneshift">Flip position:</label><input data-mini="true" type="range" min="-100" max="100" name="cloneshift" id="cloneshift"  step="1" value="0"></div>
</div>
</div>

<hr>


<div class="ui-grid-a">
<div class="ui-block-a">
<label  class="checkbox"><input class="bigbox" id="widen" type="checkbox" data-role="none">Widen the vehicle by splitting it apart!</label>
</div>
<div class="ui-block-b">
<div class="ui-field-contain"><label for="widendistance">Distance:</label><input data-mini="true" type="range" min="-100" max="100" name="widendistance" id="widendistance"  step="1" value="1"></div>
<div class="ui-field-contain"><label for="widenshift">Split position:</label><input data-mini="true" type="range" min="-100" max="100" name="widenshift" id="widenshift"  step="1" value="0"></div>
</div>
</div>

<!--<input id="removeoverlap" type="checkbox">Remove Overlapped blocks<br>-->


</div>	

<input type="button" class="dl" value="Apply Modifications & Download" onclick="downloadBlueprint();" disabled>	
<div id="filecontent" class="hidden">
<a href="#filetext" onClick="togglefiletext();"><i>Blueprint not downloading?</i></a>
<div id="filetext" name="filetext">
<br>
Copy and paste the following into a new .blueprint file!<br>
<textarea id="filetextbox" wrap="hard" cols="45" rows="30" readonly></textarea>
</div>
</div>
</div><!--end of left block-->
		
		
		<div class="ui-block-b">
	<div id="renderpanel" data-role="collapsible">
	<h4>3D Preview</h4>
		<div id="container"></div>
	
	</div>
	<div id="blockcountpanel" data-role="collapsible" >
		<h4>Block Count</h4>
		<table id="table1"  class="table1 tablesorter">
		  <thead>
			<tr>
			  <td colspan="2" align="center" class="b1name">Blueprint</td>
			</tr>
		  <tr>
			  <th>Block</th>
			  <th>Count</th>
			</tr>
		  </thead>
		  <tbody>

		  </tbody>
		</table>

	</div>
	<div id="blockstatpanel" data-role="collapsible">
		<h4>Blueprint Statistics</h4>
		<table id="table2"  class="table2 tablesorter">
		  <thead>
			<tr>
			  <td colspan="2" align="center" class="b1name">Blueprint</td>
			</tr>
		  <tr>
			  <th>Statistic</th>
			  <th>Value</th>
			</tr>
		  </thead>
		  <tbody>

		  </tbody>
		</table>
		<div class="subtext"><i>*These numbers are based on saved values in the blueprint, and might not be accurate especially after block modification.</i></div>
	</div>		
		
		</div>
	</div>

	<div id="commentpanel" data-role="collapsible">
		<h4>Comments</h4>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "http://zyonixgaming.github.io/ftd-blueprint-tools/";
this.page.identifier = "zyonixgaming-ftd-blueprint-tools";
};
(function() {
var d = document, s = d.createElement('script');
s.src = '//ftdblueprinttools.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
	</div>
	<p></p>
	<p>Copyright &copy; 2016 Zyonix Gaming</p>	
	</div>
</div>


<script>
loadLinks();
$(".lb").prop('disabled',false);		
$(".lb").parent().removeClass('ui-state-disabled');		

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77242087-2', 'auto');
  ga('send', 'pageview');
</script>
		
	</body>
</html>